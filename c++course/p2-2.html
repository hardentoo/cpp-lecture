<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 2</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 2</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>С++ как "расширенный" C
	<ul>
          <li><a href="p2-2.html#namespaces">Пространства имен.</a>
          <li><a href="p2-2.html#cpp_io">С++-стиль ввода-вывода.</a>
          <li><a href="p2-2.html#ovld">Перегрузка функций. Прототипы и  сигнатуры.</a>
          <li><a href="p2-2.html#templates">Шаблоны (templates)</a>
          <li><a href="p2-2.html#refs">Ссылки</a>
          <li><a href="p2-2.html#exceptions">Исключения (exceptions)</a>
	</ul>
      </ul>
    </td>
  </tr>
</table>

<!--
Внести во введение - STL and templates
Внести в резюме введения - STL and templates and exceptions
Внести в первую лекцию
       bool
       unnamed parameters in functions
       default function arguments
       передача по значению структур (аргументы и return) 
--!>

<hr align="center" width="50%">
<h1 align="center"><a name="namespaces"></a>
     С++ как "расширенный" С</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Пространства имен.</h2>

<p>

Эта тема достойна отдельного длинного  разговора, но я уделю ей совсем
немного времени - лишь бы вы понимали, о чем идет речь, когда придется
с ними столкнуться.

</p><p>

Пространства   имен  помогают   избегать  конфликтов   имен  (функций,
переменных  и так  далее). Думаю,  сама проблема  очевидна, но  тем не
меннее  поясню  на  простом  примере.  Если  вы  попытаетесь  сравнить
<em>random()</em>  из  стандартной библиотеки  
со  своим генератором  случайных
чисел,  то  в  программе  на  С вам  придется  изобретать  для  своего
генератора другое имя. 

</p><p>

В С++  вы можете  поместить свою функцию  в пространство имен,  как бы
расширить ее имя

<div class="incode">
             namespace my_funcs {<br>
             &nbsp;&nbsp;long random() { ... };<br>
             };<br>
</div>

и после этого использовать следующим образом:

<div class="incode">
             long l;<br>
             l = my_funcs::random();<br>
</div>

Здесь <em>::</em>  (двойное двоеточие) - оператор  разрешения 
области видимости (scope  resolution operator).  Кстати,  вы его  
уже видели  на прошлом
занятии  (мы с  его помощью  добирались до  замаскированной глобальной
переменной), но тогда перед ним не стояло никакого имени.  

</p><p>

Аналогичным
способом застраховались  от конфликта имен  и разработчики стандартной
библиотеки -  только пространство имен  у них называется <em>std</em>.  
Так что теперь вы можете пользоваться обеими функциями:

<div class="incode">
             l = std::random();   // из stdlib<br>
             l = my_funcs::random(); // my own function<br>
</div>

Указывать для  каждой функции пространство  имен довольно утомительно,
так  что вы  с помощью  директивы <em>using</em>  можете сказать,  
какой именно функцией (или набором функций) хотите пользоваться:

<div class="incode">
             using my_funcs::random;<br>
             using std::abs;<br>
<br>
             l = random();   // my_funcs::random()<br>
             l = abs(l);     // std::abs();<br>
</div>

Можно в директиве  <em>using</em> поставить не имя функции,  
а все пространство
имен, при  этом все  имена без  <em>::</em> будут ссылаться  
либо на  функции в
текущем файле (если они не вынесены, как <em>my_funcs::random</em>, 
в отдельное пространство имен), либо на пространство, 
указанное в директиве <em>using</em>:

<div class="incode">
             using namespace std;<br>
             l = random();   // std::random()<br>
             l = abs();      // std::abs()<br>
<br>
             l = my_funcs::random();  // own function<br>
</div>
             
Теперь  осталось   сказать,  как  пользоваться   стандартными  файлами
заголовков в С++.

</p><p>

До  того,  как был  принят  стандарт, довольно  долго  в  С++ не  было
пространств имен,  а стандартные файлы заголовков  так же, как  и в С,
заканчивались суффиксом .h - например &lt;iostream.h>. 

</p><p>

С принятием стандарта все  имена библиотеки вынесли в пространсво std,
однако  к  тому   времени  на  С++   было  написано много  программ  и
библиотек. И  для того, чтобы сохранилась совместимость  с ними, файлы
заголовков пришлось исполнить в двух вариантах - в старом, с суффиксом
.h, и в новом - вообще  без суффикса. При этом к заголовкам, пришедшим
из  С, прибавили  спереди букву  c, например  &lt;stdio.h>  превратился в
&lt;cstdio>. А у заголовков, которых в С не было, просто убрали суффикс -
&lt;iostream.h> стал называться &lt;iostream>.

</p><p>

А  разница между  старым и  новым  набором очень  простая -  заголовок
"старого"  образца -  это  соответсвующий новый  плюс директива  
<em>using&nbsp;namespace&nbsp;std</em>. Например, старая запись

<div class="incode">
          #include &lt;stdio.h>
</div>

и более новая и правильная

<div class="incode">
          #include &lt;cstdio><br>
          using namespace std;<br>
</div>

это одно и то же. 

</p><p>

Возможности пространств имен гораздо шире, чем я рассказал, но, думаю,
для целей нашего курса этого  хватит. На самом деле, нам вполне хватит
умения подключать  файлы заголовков "нового образца", как  в примере c
&lt;cstdio>. Я даже призываю этим и ограничиться на первых порах, чтобы у
вас в голове было поменьше путаницы.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="cpp_io"></a>С++-стиль ввода-вывода.</h2>
<p>

Давайте теперь посмотрим,  как выглядит ввод-вывод в С++.  Для этого я
написал коротенькую программу:

<div class="code">
        // file c++io.cc<br>
        #include &lt;string><br>
        #include &lt;iostream><br>
<br>
        using namespace std;<br>
<br>
        main() {<br>
        &nbsp;&nbsp;string name;<br>
        &nbsp;&nbsp;int age;<br>
<br>
        &nbsp;&nbsp;cout &lt;&lt; "Enter your name and age" &lt;&lt; endl;<br>
<br>
        &nbsp;&nbsp;cin >> name >> age ;<br>
<br>
        &nbsp;&nbsp;cout &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; ", your age is " &lt;&lt; age &lt;&lt; endl;<br>
<br>
        }<br>
</div>

Что  в ней  имеется? Сначала  в программу  включаются  два стандартных
файла заголовков

<div class="incode">
        #include &lt;string><br>
        #include &lt;iostream><br>
</div>

для  работы со  строками и  с вводом-выводом  в С++  стиле.   Затем мы
директивой

<div class="incode"> 
        using namespace std;
</div>

указываем, что собираемся работать с именами из стандартной библиотеки
(я только что это объяснял).

</p><p>

Затем идет функция <em>main()</em>:

<div class="incode">
        main() {<br>
        &nbsp;&nbsp;string name;<br>
        &nbsp;&nbsp;int age;<br>
        &nbsp;&nbsp;...<br>
</div>

В ней мы  объявляем две переменные - <em>name</em> и <em>age</em>.  
Тип <em>string</em> вы видите
впервые. Мы не раз будем им  пользоваться, но пока скажу лишь, что это
- не встроенный тип, а  пользовательский (С++ класс). Именно ради него
мы и включили стандартный заголовок &lt;string>.

</p><p>

Дальше идет собственно С++-вывод. Инструкция 

<div class="incode">
          cout &lt;&lt; "Enter your name and age" &lt;&lt; endl;
</div>

печатает  приглашение,  а затем  переходит  на  новую  строку 
(<em>endl</em>  - сокращение от end of line -  делает то же, 
что "\n" в форматной строке
<em>printf</em>). Вывод  попадает в выходной поток  <em>cout</em> - 
это  аналог <em>stdout</em> в
С. Оператор  сдвига  &lt;&lt;  здесь  служит для  целей вывода, так сказать, 
сдвигает печатаемые значения в поток.

</p><p>

Похожим образом выглядит и чтение данынх из потока, только вместо 
<em>cout</em>
стоит <em>cin</em> (аналог  <em>stdin</em>), и используется 
оператор >>  сдвига вправо -
данные сдвигаются из потока в программу:

<div class="incode">
          cin >> name >> age ;
</div>

и затем  в <em>cout</em> выводится приветствие и  
печатаются значения введенных
переменных:

<div class="incode">
          cout &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; ", your age is " &lt;&lt; age &lt;&lt; endl;
</div>

Собрав и  запустив такую программу, можно уебдиться,  что она работает
именно так, как я рассказал:

<div class="session">
      ~/c++course/praktikum> c++ c++io.cc  -o c++io<br>
      ~/c++course/praktikum> ./c++io<br>
      Enter your name and age<br>
      Anonymous 24<br>
      Hello Anonymous, your age is 24<br>
      ~/c++course/praktikum><br>
</div>

Это  и есть  тот новый  стиль ввода-вывода,  о котором  я  упоминал на
предыдущем  занятии.  В   основе  его  лежат  объектно-ориентированные
возможности языка.  В С++ есть классы потоков  ввода-вывода, в которых
перегружены  операторы &lt;&lt;  и >>.  А cin  и cout  -  представители этих
классов.

</p><p>

Теперь о том, какие в С++-стиле есть стандартные потоки:

</p><p>

<ul>
    <li><em>cin</em>   - стандартный поток ввода. 
            Аналог <em>stdin</em> в С. Буфуризованный. 
    <li><em>cout</em>  - стандартный поток вывода. 
            Аналог <em>stdout</em> в С. Буферизованный.  
    <li><em>cerr</em>  - стандартный поток сообщений об ошибках. 
            Аналог <em>stderr</em> в С. Небуферизованный.

    <li><em>clog</em> -  Буферизованный вариант cerr (это не 
        самостоятельный поток, он связан с тем  же устройством
        или    файлом, что и <em>cerr</em>). Предназначен для вывода    
	больших диагностических  сообщений, поскольку за  счет буферизации
        работает быстрее.
    </ul>

</p><p>

Как  и в С,  стандартные потоки  открываются автоматически  при старте
программы,   и   так  же   автоматически   закрываются  при   успешном
завершении. Разумеется,  как и в С, программа  может при необходимости
использовать и другие  потоки, но  их придется  открывать  и закрывать
самостоятельно. О том, как это  делается, и какие еще есть возможности
у С++-стиля ввода-вывода, я рассчитываю поговорить на одном из будущих
занятий. А первое знакомство с С++-потоками мы на этом завершим.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="ovld"></a>
	     Перегрузка функций. Прототипы и  сигнатуры.
	 </h2>
<p>

Напомню, перегрузка  функций - механизм, который  позволяет вам писать
функции  с  одним  и  тем  же  именем, но  с  разными  параметрами,  а
транслятору,  соответственно, догадываться,  когда какую  функцию надо
вызывать. Сейчас, мы, разумеется,  будем работать только с глобальными
функциями (то есть,  с обычными функциями в понимании  С), но механизм
этот в первую  очередь предусмотрен для методов класса  - тех функций,
которые наравне с данными включаются в пользовательские типы данных.

</p><p>

Но, чтобы  понять, как работает перегрузка функций,  вам нужно освоить
два новых термина.  Делать мы это будем на примере функции 
<em>strcpy()</em> из
стандартной   библиотеки  С   (заголовок  &lt;string.h>).    Причем  само
определение функции,  ее тело, нас сейчас не  интересует, обсуждать мы
будем только объявление функции. Итак, согласно странице описания 
(<em>man&nbsp;strcpy</em>) функция объявлена следующим образом

<div class="incode">
          char *strcpy(char *dst, const char *src);
</div>

Такое объявление - тип функции (<em>char&nbsp;*</em>), 
ее имя (<em>strcpy</em>), количество и
типы  параметров  
(<em>char&nbsp;*dst,&nbsp;const&nbsp;char&nbsp;*src</em>)  - принято  называть
прототипом  функции.  Я специально  не  упомянул  имена параметров,  в
прототипе  они   нужны  не  транслятору,  а   человеку  для  улучшения
читабельности программ. Так что прототип функции <em>strcpy</em> 
можно записать еще короче:

<div class="incode">
          char *strcpy(char *, const char *);
</div>

Итак, прототип  функции включает  в себя тип  самой  функции, ее  имя,
количество  и  типы ее  параметров.  Именно  прототип указывается  при
объявлении функции.

</p><p>

Сигнатура функции - это прототип за вычетом типа функции, то есть

<div class="incode">
          strcpy(char *, const char *);
</div>

Зачем в С++ понадобился не только прототип функции, но и ее сигнатура,
и почему я рассказал о них именно сейчас, вы скоро поймете.

</p><p>

Теперь собственно о перегрузке функций. Мы в первой части курса как-то
вычисляли наибольшее  из двух  значений с помощью  троичного оператора
<em>(?:)</em>. <em>max()</em>  - вполне естественное  название для 
подобной  функции. Но
сам оператор умеет работать с разными типами данных, например, с <em>int</em> 
и <em>double</em>. В С, чтобы использовать одно  и то же имя для разных 
типов, мы применяли макроподстановку с параметрами:

<div class="incode">
          #define max(x,y)  ( (x)>(y) ? (x) : (y) )
</div>

С++ позволяет поступить проще

<div class="incode">
          int max(int x, int y) { return x>y ? x : y ; } <br>
<br>
          double max(double x, double y) { return x>y ? x : y ; }<br>
</div>

Как видите, мы написали две  функции max под разные наборы параметров.
Это и есть перегрузка (overloading) функций.

</p><p>

Теперь, когда транслятор встретит в программе вызовы <em>max()</em>:

<div class="incode">
          int a;<br>
          a = max(1, 3);<br>
<br>
          double d;<br>
          d = max(2.5, -1.0);<br>
</div>

он  по  типу используемых  параметров  подберет  и вызовет  подходящий
вариант функции, в первом случае <em>max(int,int)</em>, во втором 
- <em>max(double,double)</em>. Мы можем написать  и функцию, 
которая определяет максимальное из трех значений

<div class="incode">
         double max(double x, double y, double z) {<br>
         &nbsp;&nbsp;return max( max(x,y), z);<br>
         }<br>
<br>
         double d = max( 1.0, 2.0, 3.0); <br>
</div>

Такой  код   тоже  будет  работать,   поскольку  транслятор  подбирает
подходящую функцию не только по  типам, но и по количеству параметров.
Вот на  что транслятор при  таком подборе не  смотрит, так это  на тип
самой функции. Написать

<div class="incode">
        double max(int x,int y) { ... };<br>
        int max(int x,int y) { ... };<br>
</div>

он просто не позволит - даст сообщение об ошибке. И понятно почему - по
правилам  языка вы, вызвав  функцию, можете  использовать возвращаемое
значение, а можете его проигнорировать

<div class="incode">
         double d;<br>
	 // No info about type of return value
         max( 1.0, 2.0); <br>
</div>

И в этом случае у  транслятора просто нет возможности узнать, какую
же функцию вы имели в виду.

</p><p>

Теперь  вам  должно  быть  ясно,  зачем наряду  с  прототипом  функции
понадобилась  и сигнатура  -  именно ее  транслятор использует,  когда
отыскивает  среди  перегруженных  функций  подходящую. И  поэтому  С++
требует, чтобы сигнатуры всех  функций были разными.  Чтобы проще было
к этому привыкнуть,  вы можете думать о сигнатуре  функции как о неком
аналоге имени функции в обычном С.  Собственно, за кулисами дело так и
обстоит - свои внутренние ("для служебного пользования") имена функций
транслятор  строит именно на  основе сигнатур,  и называется это "name
mangling".

</p><p>

Все это,  конечно, очень приятно, но писать  перегруженные функции для
всех  возможных   комбинаций  типов  параметров   -  занятие  довольно
утомительное.  Например,  для разных  сочетаний  float  и double  даже
функцию  max() c  двумя аргументами  пришлось бы  исполнить  в четырех
вариантах:

<div class="incode">
        float max(float, float)     { ... };<br>
        double max(float, double)   { ... };<br>
        double max(double, float)   { ... };<br>
        double max(double, double)  { ... };<br>
</div>

К счастью,  С++ не требует  точного соответствия сигнатуры  при вызове
сигнатуре  одной  из  имеющихся  функций.  Если  точно соответствующей
перегруженной функции нет, он в состоянии подобрать из набора наиболее
подходящую.   Наиболее  понятная  аналогия   из  С   -  арифметические
выражения, в которых можно перемешивать переменные разных типов

<div class="incode">
           // '9' will be used as (double)'9'
           double x = '9'* 0.5; 
</div>

Так и с перегруженными функциями  - для работы с четырьмя приведенными
комбинациями  float и double  достаточно одной-единственной  функции -
<em>max(double,double)</em>.

</p><p>

Правила, по  которым транслятор определяет подходящую  функцию, не то,
чтобы слишком сложны, но за 5 минут о них не расскажешь, так что мы не
будем в  них углубляться.  Скажу  только, что больше  всего транслятор
любит точное совпадение сигнатур, потом пытается подобрать сигнатуры с
наиболее близкими и достаточными  по размеру типами (например, float в
вызове может соответствовать типу double в сигнатуре, но не наоборот),
а  некоторые  варианты (например,  замену  char  на  char*) вообще  не
рассматривает.

</p><p>

И последнее  - как бороться с конфликтами  имен перегруженных функций.
Если, имея в распоряжении  функции <em>max(int,int)</em> 
и <em>max(double, double)</em>,
вы напишете

<div class="incode">
        int i = max(2.5, 1);
</div>

вы поставите транслятор в затруднительное положение - точная сигнатура
вызова - <em>max(double,int)</em>,  а для нее одинаково хороши  
обе имеющиеся в
наборе функции (у обеих - точное совпадение типа одного из параметров,
и совместимый тип другого параметра). И транслятор сообщит вам об этом
двусмысленном вызове, и даже укажет возможных кандидатов:

<div class="incode">
   ovld.cc:5: error: call of overloaded `max(double, int)' is<br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ambiguous <br>
   ovld.cc:1: error: candidates are: int max(int, int)<br>
   ovld.cc:2: error:                 double max(double, double)<br>
</div>

В  подобной  ситуации  проще  всего  сделать одну  из  сигнатур  более
предпочтительной с помощью явного приведения типа прямо при вызове:

<div class="incode">
        // will call max(double, double)<br>
        int i = max(2.5, double(1));<br>
</div>

и после такой подсказки транслятор легко отыщет нужную функцию.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="templates"></a>Шаблоны (templates)</h2>
<p>

Как  и в  других  случаях,  это лишь  первое  знакомство с  шаблонами.
Шаблоны  могут использоваться  для создания  не только  функций,  но и
пользовательских типов  данных.  Но сейчас мы будем  говорить только о
шаблонах функций.

</p><p>

Мы только что с вами разбирались с перегруженными функциями, используя
для примеров  разные варианты  функции <em>max</em>. При  этом 
функции  с двумя
аргументами отличались лишь используемым типом данных:

<div class="incode">
       int max(int x, int y) { return x>y ? x : y ; } <br>
       double max(double x, double y) { return x>y ? x : y ; }<br>
</div>

С++   позволяет   в  подобных   случаях   избежать  рутинной   работы.
Для автоматизации процесса надо  написать шаблон:

<div class="incode">
  template&lt;class T><br>
  &nbsp;&nbsp;&nbsp;&nbsp;T max(T x, T y) {  return x>y ? x : y; }<br>
</div>

(здесь &lt;class T> - не С++-класс, а так называемый параметр шаблона).

</p><p>

Сам по  себе такой шаблон  еще ни к  чему не обязывает  транслятор. Но
если в программе появится вызов <em>max()</em> c двумя аргументами 
одного типа,
то транслятор создаст для него по шаблону соответсвующую функцию (если
он это не сделал раньше). Так, для двух первых вызовов
  
<div class="incode"> 
      max('c','d');    // instantiate max(char,char)<br>
      max(1.0,2.0);    // instantiate max(double,double)<br>
      max('c','d');    // max(char,char) already exists<br>
</div>

транслятор   создаст  функции  <em>max(char,char)</em>   
и  <em>max(double,double)</em>,
заменив в теле шаблона тип-параметр T реальным типом, использованным в
выводе. К  моменту третьего  вызова у него  уже будет  создана функция
<em>max(char,char)</em>, которую он и использует.

</p><p>

Такое  поведение   немного  похоже  на   макроподстановки,  но  только
текстовая  замена  формального   параметра  шаблона  на  реальный  тип
происходит не в месте, где  max() используется, а в теле автоматически
созданной по заданному образцу функции.

</p><p>

Шаблону  можно указать  не один  параметр-тип, а  несколько. Например,
такой  шаблон  будет создавать  функции,  находящие  аргумент с  типом
большего размера, и возвращающие этот размер в байтах:

<div class="incode">
         template&lt;class T1, class T2><br>
         &nbsp;&nbsp;&nbsp;&nbsp;int maxsize(T1 a, T2 b) {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size_a = sizeof(a);<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size_b = sizeof(b);<br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return size_a>size_b ? size_a : size_b;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;}<br>
</div>

Подобная автоматизация  выглядит очень  привлекательно, и она  в самом
деле  может  заметно  облегчить  работу. Например,  часть  стандартной
библиотеки С++ - STL (standard  templates library) - это как раз набор
хорошо  продуманных и  готовых к  использованию шаблонов  (правда, там
шаблоны не для  функций, а для типов данных). Но  в работе с шаблонами
есть  и своя  специфика,  и при  неумелом  использовании они  способны
принести  больше   хлопот,  чем   пользы.  Не  хочу   перегружать  вас
подробностями, так  что лишь намекну на два  наиболее частых источника
разочарований:

<ul>
  <li>Текстовая  замена формального  типа на  фактический в  теле шаблона
   порой  приводит к  весьма причудливым  конструкциям,  которые могут
   давать  ошибки при  трансляции,  или работать  совсем  не так,  как
   замышлялось разработчиком  шаблона. В общем,  ситуация очень похожа
   на проблемы с макроподстановками в С.

  <li> Имея в распоряжении  шаблон функции, транслятор, естественно, будет
   создавать  по  нему тела  функций,  точно соответсвующие  сигнатуре
   вызова.  Даже в тех случаях, когда вполне можно было обойтись одной
   функцией с  сигнатурой, пусть не точно  совпадающей, но совместимой
   сразу с  несколькими вызовами.  Так  что неаккуратное использование
   шаблонов временами приводит к тому, что программа "распухает" - код
   автоматически сгенерированных  функций занимает необоснованно много
   места в памяти.
</ul>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="refs"></a>Ссылки</h2>
<p>

Я вам,  наверное, уже все уши  прожужжал на прошлых занятиях  - "в С++
передача параметров по ссылке есть". Вот, наконец, и пришла пора с ней
познакомиться.

</p><p>

На  самом деле,  передача параметров  по ссылке  лишь  побочный эффект
появления нового типа данных - ссылок. Так что и знакомиться мы сейчас
будем  в   первую  очередь  с  этим   новым  типом  данных   и  с  его
особенностями. А  параметры функций будем  использовать как "наглядное
пособие".

</p><p>

Само создание ссылки похоже на создание обычной переменной - тип, имя,
инициализатор.   Но  справа  от   типа  надо  поставить  символ  &,  и
обязательно явно инициализировать ссылку  - связать с тем объектом, на
который она должна ссылаться:

<div class="incode">
        int i;  // целая переменная<br>
        int& ref = i;<br>
</div>

После  этого вы  можете пользоваться  ссылкой  ref так  же, как  самой
переменной i  - вы при этом будете  обращаться не к ссылке,  а к самой
переменной:

<div class="incode">
        i = 8;   // "прямой" доступ к i<br>
        ref = 8; // то же действие, но доступ к i через ссылку<br>
</div>

Иногда говорят  даже, что, создавая  ссылку, вы создаете еще  одно имя
для имеющейся переменной.

</p><p>

Даже из приведенного примера ясно, что создавать и использовать ссылки
не  сложнее, чем  обычные переменные.  Однако при  работе  со ссылками
всегда надо держать в уме две вещи:

<ul>
<li> Ссылка никогда не может существовать сама по себе - она обязательно
связана с какой то переменной. У  нее даже нет своего адреса - если вы
попробуете  взять адрес  ссылки,  то получите  адрес  связанной с  ней
переменной.

<li> Все, что вы можете сделать с  самой ссылкой - это создать ее. После
создания  вы  повлиять  на  ее  дальнейшую судьбу  никак  не  сможете,
поскольку работать будете не со ссылкой, а с самой переменной.  Ссылку
нельзя уничтожить, она может "умереть" только своей смертью, например,
когда программа  выйдет из локального блока, где  ссылка объявлена. Не
удастся и перенаправить ее на другую переменную. И так далее.
</ul>

А теперь посмотрим, как выглядит работа со ссылками в функциях.

</p><p>

Если бы вам захотелось в  рамках С написать функцию, меняющую значения
двух аргументов, вы бы воспользовались указателями:

<div class="incode">
     // swap() function definition, C-style (pointers)<br>
     void swap(int *a, int *b) {<br>
     &nbsp;&nbsp;int temp = *a;<br>
     &nbsp;&nbsp;*a = *b;<br>
     &nbsp;&nbsp;*b = temp;<br>
     }<br>
<br>
     // swap() function usage, C-style<br>
     int i = 1, j = 2;<br>
     swap(&i,&j);  // Now i==2 and j==1<br>
</div>

Со ссылками все это записывается проще:

<div class="code">
     // swap() function definition, C++-style (references)<br>
     void swap(int& a, int& b) {<br>
     &nbsp;&nbsp;int temp = a;<br>
     &nbsp;&nbsp;a = b;<br>
     &nbsp;&nbsp;b = temp;<br>
     }<br>
<br>
     // swap() function usage, C++-style<br>
     int i = 1, j = 2;<br>
     swap(i,j);  // Now i==2 and j==1<br>
</div>

Точно так  же можно использовать ссылку  и для типа  функции (то есть,
для типа возвращаемого ею значения). Например, можно вернуть ссылку на
переменную, заданную аргументом:

<div class="incode">
            int& ret_arg(int &arg) {<br>
            &nbsp;&nbsp;return arg;<br>
            }<br>
</div>

Такая функция  вернет не  значение аргумента, а  именно ссылку  на сам
аргумент.  Возможно, вы  еще не  почувствовали разницы,  но  понять ее
поможет вот такое использование только что определенной функции:

<div class="incode">
           int i;<br>
           ret_arg(i) = 2;    // Now i==2<br>
</div>

Выглядит странновато - мы присваиваем  что-то вызову функции. Но это и
есть самое ценное.  Функции,  возвращающие ссылки - это левые значения
(lvalues), то, что можно ставить слева от оператора присваивания.

</p><p>

Теперь можно приоткрыть завесу  над тайной  ввода-вывода в  С++-стиле.
Когда вы пишете

<div class="incode">
      cout &lt;&lt; i ;
</div>

программа   вызывает  функцию,   соответствующую   оператору  &lt;&lt;   (это
называется  перегрузкой операторов,  operator  overloading). Причем  в
качестве одного из аргументов  используется <em>ссылка</em>на поток cout.  И
сама функция  тоже возвращает ссылку  на этот поток. Так  что значение
выражения

<div class="incode">
      (cout &lt;&lt; i)
</div>

это  тот же  cout,  и мы  можем  таким же  оператором  вывести в  него
что-нибудь еще:

<div class="incode">
     (cout &lt;&lt; i) &lt;&lt; j;
</div>

А поскольку  вызов, соответсвующий  второму оператору &lt;&lt;,  тоже вернет
ссылку на поток, мы можем продолжать

<div class="incode">
     ( (cout &lt;&lt; i) &lt;&lt; j )  &lt;&lt; k;
</div>

и так далее в том же духе.

</p><p>

Заканчивая разговор о ссылках,  хочу уберечь вас от одного популярного
заблуждения.   Многие  (особенно   начинающие)  думают,  что  одно  из
преимуществ ссылок - их связь с реальным объектом. Дескать, когда вы в
С  работаете  с  указателями,  вы должны  для  подстраховки  смотреть,
указывают ли  они куда-нибудь  (проверять их на  <em>NULL</em>).  
А  вот ссылка
всегда  смотрит на переменную,  так что  подобных неприятностей  с ней
быть не может.  Так то оно так, но только до известного предела.  Дело
в том,  что переменная  может умереть раньше  ссылки, как  например, в
таком фрагменте программы.

<div class="code">
        // Allocate variable of type double on heap<br>
        double *p = (double*)malloc(sizeof(double));  <br>
<br>
        // Create reference to variable just allocated<br>
        double& ref = *p;<br>
<br>
        ref = 1.0; // same as *p = 1.0<br>
<br>
<br>
        // delete allocated variable<br>
        free(p);<br>
<br>
        // ref is still alive, but its variable already dead,<br>
        // so next line will cause trouble<br>
        ref = 1.5;  // same as *p=1.5, but *p already destroyed<br>
</div>

Разумеется,   пример    упрощенный,   чтобы   легче    было   показать
проблему. Специально  так писать  никто не станет,  разве что  со злым
умыслом. Но подобный сюжет может реализоваться и "нечаянно", особенно,
когда речь заходит о передаче по ссылке результата функции.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="exceptions"></a>Исключения (exceptions)</h2>
<p>

На   прошлом  занятии  я   вам  уже   рассказывал  об   исключениях  -
С++-механизме для обработки ошибок. Но тогда я говорил о самой идее, а
сейчас хочу показать, как это выглядит в коде.

</p><p>

Итак, когда какая-нибудь функция  обнаруживает ошибку, она сообщает об
этом  вызывающему коду,  посылая  исключение. Делается  это с  помощью
оператора  <em>throw</em>.  Наша  функция  будет вычислять  факториал,  
посылая
исключение при слишком большом значении аргумента

<div class="incode">
           unsigned factorial(unsigned val) {<br>
           &nbsp;&nbsp;if (val > 22)<br>
           &nbsp;&nbsp;&nbsp;&nbsp;throw "Argument too large";<br>
           &nbsp;&nbsp;return (val == 0 ? 1 : val*factorial(val-1));<br>
           }<br>
</div>

Как видите,  третьей строкой стоит  ключевое слово <em>throw</em>, 
а  затем тот
объект, который  содержит информацию об  ошибке - в нашем  случае, это
строка, но с тем же  успехом можно послать и переменную или структуру.
Причем этот  объект несет двоякую  информацию - тип  исключения 
(<em>const&nbsp;char*</em>, текстовая  строка), 
и описание нашего  конкретного случая (само
содержимое  этой  строки).    Послав  исключение,  функция  больше  не
заботится о  его судьбе,  да она и  не может этого  сделать, поскольку
оператор <em>throw</em> приводит к немедленному прекращению ее работы.

</p><p>

Дальнейшие события происходят в  вызвавшем функцию коде, и развиваться
они могут по двум сценариям.

</p><p>

Первый сценарий, когда никаких проверок в вызывающем коде не делается:

<div class="code">
    main() {<br>
    &nbsp;&nbsp;unsigned result;<br>
    &nbsp;&nbsp;result = factorial(25);<br>
    &nbsp;&nbsp;cout &lt;&lt;  result &lt;&lt; endl;<br>
    &nbsp;&nbsp;cout &lt;&lt; "Goodbye" &lt;&lt; endl;<br>
    }<br>
</div>

В  этом  случае  исключение,  дойдя  до  функции  <em>main()</em>,  
приведет  к
аварийному завершению программы

<div class="session">
    ~> ./exceptions<br>
    Abort (core dumped)<br>
    ~><br>
</div>

(как при вызове функции <em>abort()</em>).

</p><p>

Во  втором сценарии вызывающий  код обрабатывает  исключения, заключая
код, который  может их генерировать, в try-блок  и назначая обработчик
для нужного типа исключения с помощью catch-блока:

<div class="code">
    main() {<br>
    &nbsp;&nbsp;unsigned result;<br>
<br>
    &nbsp;&nbsp;try {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;result = factorial(25);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;  result &lt;&lt; endl;<br>
    &nbsp;&nbsp;}<br>
    &nbsp;&nbsp;catch (const char *msg) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; " Factorial raised exception " &lt;&lt; msg &lt;&lt; endl;<br>
    &nbsp;&nbsp;}<br>
<br>
    &nbsp;&nbsp;cout &lt;&lt; "Goodbye" &lt;&lt; endl;<br>
<br>
    }<br>
</div>

Работает подобная  конструкция следующим образом -  если исключения не
возникает, то catch-блок не  получает управления. Так что после вызова
<em>factorial()</em>  печатается  результат   и  сразу  
после  этого  сообщение <em>Goodbye</em>.

</p><p>

Когда же <em>factorial()</em> взводит  исключение, 
то остальные операторы блока
try не  выполняются (в нашем  примере не выполняется строка  с печатью
результата),  и  просматриваются  catch-блоки, относящиеся  к  данному
блоку try. Если удается отыскать подходящий по типу исключения, то его
код  и выполняется,  причем в  параметр "шапки"  блока  засылается тот
объект,  который пришел  с исключением.  Мы в  нашем  примере получаем
строку  с описанием  ошибки в  параметре  msg блока  catch, которую  и
печатаем.

<div class="session">
    ~> ./exceptions<br>
    Factorial raised exception Argument too large<br>
    Goodbye<br>
    ~><br>
</div>

(Вы  можете спросить: -  что случается,  если подходящего  блока catch
нет? В этом случае try-catch не перехватывает исключение и реализуется
не второй, а первый сценарий.)

</p><p>

Для тех, кто захочет  немного попрактиковаться с исключениями, приведу
программу  целиком,  чтобы  ее  можно  было  использовать  в  качестве
отправной  точки (в  ней  для удобства  аргумент  факториала не  задан
жестко, а в цикле считывается из cin).

<div class="code">
        #include &lt;iostream><br>
<br>
        using namespace std;<br>
<br>
        unsigned factorial(unsigned val) {<br>
        &nbsp;&nbsp;if (val > 22)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;throw "Argument too large";<br>
        &nbsp;&nbsp;return (val == 0 ? 1 : val*factorial(val-1));<br>
        } <br>
<br>
        main() {<br>
        &nbsp;&nbsp;unsigned n;<br>
        &nbsp;&nbsp;while (cin >> n)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt;  "factorial(" &lt;&lt; n &lt;&lt; ")="&lt;&lt;factorial(n) &lt;&lt; endl;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
        &nbsp;&nbsp;&nbsp;&nbsp;catch (char *msg) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; "exception " &lt;&lt; msg &lt;&lt; endl;<br>
       &nbsp;&nbsp;&nbsp;&nbsp;}<br>
       }<br>
</div>

Естественно,  код  в try-блоке  может  взводить  исключения не  только
одного  типа, соответственно  и catch-блоков  в этой  конструкции может
быть несколько. При генерации исключения программа будет просматривать
их один  за другим, в  том порядке, как  они написаны, и  выполнит код
первого же подходящего по типу catch-блока:

<div class="incode">
     try { <br>
     &nbsp;&nbsp;... <br>
     }<br>
     catch (const char *msg) {<br>
     &nbsp;&nbsp;cerr &lt;&lt; "const char * exception handled" &lt;&lt; endl;<br>
     } <br>
     catch (int error_number) {<br>
     &nbsp;&nbsp;cerr &lt;&lt; "int exception handled" &lt;&lt; endl;<br>
<br>
     } <br>
     catch(...)  {<br>
     &nbsp;&nbsp;cerr &lt;&lt; "Handler for any type of exception called" &lt;&lt; endl;<br>
     }<br>
</div>

Обратите   внимание  на  последний   catch-блок  -   он  перехватывает
исключения любого типа. И поэтому, кстати, стоит последним - поставьте
его первым, и все остальные catch-блоки никогда не вызовутся.

</p><p>

Что именно принято делать в  блоках catch? Ответ зависит от того, чего
вы   хотите    добиться   и   какой    стратегией   обработки   ошибок
пользуетесь.  Можно подправить какие-то  параметры и  снова попытаться
выполнить  блок try. Можно  напечатать сообщение  об ошибке.  А иногда
достаточно вызвать  в catch-блоке <em>exit()</em>,  чтобы 
программа завершилась не аварийно, без дампа памяти.

</p><p>

И  последнее об  исключениях.   Я только  что  сказал, что  взведенное
исключение   несет    в   себе   двоякую   информацию    -   сам   тип
объекта-исключения, и его значение,  содержимое. Однако, если вам само
значение  не требуется,  вы вполне  можете ограничиться  только первой
половиной - типом.  Посмотрите на такой пример:

<div class="code">
          #include &lt;iostream&gt;<br>
          using namespace std;<br>
<br>
          struct my_exception {};<br>
<br>
          main() {<br>
<br>
          &nbsp;&nbsp;try {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;throw 1;<br>
          &nbsp;&nbsp;}<br>
          &nbsp;&nbsp;catch (int) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; "integer exception caught"&lt;&lt;endl;<br>
          &nbsp;&nbsp;}<br>
<br>
          &nbsp;&nbsp;try {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;struct my_exception m;<br>
          &nbsp;&nbsp;}<br>
          &nbsp;&nbsp;catch (my_exception) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; "my_exception caught" &lt;&lt; endl;<br>
          &nbsp;&nbsp;}<br>
          }<br>
</div>

В  первом  try-блоке значение  (1)  передается,  но  при обработке  не
используется.   А вторая  пара  try-catch даже  использует в  качестве
исключения структуру my_exception,  у которой нет никакого содержимого
- только тип.

</p><p>

Думаю, что для сегодняшнего  занятия достаточно.  Следующее занятие мы
начнем  со знакомства с  динамической памятью  в С++,  которую принято
называть free store.

</p>
    </td>
  </tr>
</table>


</div>
</body>
</html>
