<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 1</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 1</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Вступление: С++ - объектно-ориентированный язык
	<ul>
          <li><a href="p2-1.html#comparison">Сравнение С++ и С.</a>
          <li><a href="p2-1.html#internals">Как С++ устроен?</a>
	    <ul>
              <li><a href="p2-1.html#methods">Функции - часть типа данных</a>
              <li><a href="p2-1.html#ctors">Конструкторы и деструкторы</a>
              <li><a href="p2-1.html#freestore">Динамическая память-С++-стиль</a>
              <li><a href="p2-1.html#ovld">Перегрузка операторов и функций</a>
              <li><a href="p2-1.html#refs">Ссылки (references)</a>
              <li><a href="p2-1.html#exceptions">Исключения (exceptions)</a>
              <li><a href="p2-1.html#inh">Наследование и полиморфизм</a>
              <li><a href="p2-1.html#cppio">Новый стиль ввода-вывода</a>
              <li><a href="p2-1.html#view">Общая картина</a>
	    </ul> 
          <li><a href="p2-1.html#compiler">Как пользоваться транслятором</a>
          <li><a href="p2-1.html#compat">Несовместимость C и C++</a>
	</ul>
        <li><a href="p2-1.html#c_enhanced">С++ как "улучшенный" C</a>
	<ul>
          <li><a href="p2-1.html#comments">Новый вариант комментариев</a>
          <li><a href="p2-1.html#unnamedparams">Неименованные параметры</a>
          <li><a href="p2-1.html#newinit">
	          Новый синтаксис приведения типов и инициализации</a>
          <li><a href="p2-1.html#hiddenglobal">
	          Доступ к замаскированной глобальной переменной</a>
          <li><a href="p2-1.html#anyplace">Создание переменных</a>
          <li><a href="p2-1.html#inlines">Встроенные (inline) функции</a>
	</ul>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="comparison"></a>
     Вступление: С++ - объектно-ориентированный язык</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Сравнение С++ и С</h2>

<p>

Прежде всего - сугубо личные впечатления от С++ в сравнении с С.

</p><p>

Язык  программирования задает  некоторый предел  на сложность  задач и
размер  программ, которые на  нем можно  писать.  Понятно,  что размер
этот зависит от  языка, стиля программирования, задачи, да  и от того,
кто пишет.   Но, скажем,  написать "на коленке"  программу в  10 тысяч
строк  вряд  ли удастся  -  придется  всерьез озаботиться  проработкой
структуры,  интерфейсов,  написанием  документации  - либо  чтобы  "не
заблудиться"  в  программе самому,  либо  чтобы разработкой  программы
могли заниматься несколько человек, команда.

</p><p>

Так вот, по моему опыту, С++ выигрывает у С в случаях совсем маленьких
и  очень больших  программ. Причем  наиболее привлекателен  именно при
написании программ "на коленке" -  когда пишешь сам, не обременяя себя
себя  прилежным  и   правильным  стилем  программирования  и  ведением
документации. Но создавался этот язык, разумеется, для сложных задач и
больших проектов.

</p><p>

Дело в том, что объектный код читать гораздо труднее процедурного. Так
что  в  больших  проектах  приходится  полагаться  на  документацию  и
интерфейсы, причем гораздо  больше, чем при работе на  С.  А оборотная
сторона медали - в больших проектах и самому приходится гораздо строже
относиться к тому, что и как пишешь. Это безусловно хорошо и правильно
для очень  крупных программ  и при работе  в команде. Но  на программу
"среднего размера" порой приходится тратить несоразмерно много усилий.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="internals"></a>Как С++ устроен?</h2>
<p>

Теперь, чтобы вам легче было ориентироваться в С++, я изложу некоторые
мысли о его внутренней логике (разумеется, как я ее понимаю).  Попутно
для  этого   придется  познакомить   вас  с  некоторыми   понятиями  и
нововведениями.

</p><p>

Итак, С++ - потомок С, и он намеренно создан максимально совместимым с
С,  включая его  как  подмножество.  Однако для  того,  чтобы он  стал
объектно-ориентированным языком,  автор языка вынужден  был добавить в
него много  нового. Это  новое мы попытаемся  освоить во  второй части
нашего курса, но мне бы хотелось, чтобы у вас с самого начала в голове
сложилась некоторая картина, увязывающая нововведения в единое целое.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="methods"></a>Функции - часть типа данных</h3>
<p>


Напомню,  основная  идея  объектно  ориентированного языка  -  объекты
(читай  - переменные  пользовательских  типов) сами  знают, как  нужно
работать  со  своими данными.   А  если  говорить техническим  языком,
функции для обработки данных того или иного типа должны быть связаны с
самими данными - быть частью  объектов. Такие функции, принадлежащие
типу данных, в объектно-ориентированных языках принято называть
методами объекта.

</p><p>

В  С++ сам  тип  данных, который  может  включать и  данные, и  методы
(функции),  называется классом  (class),  а переменная  такого типа  -
объектом, или, чаще, представителем (instance) класса.  При этом в С++
есть все  средства для  того, чтобы сделать  классы очень  похожими на
встроенные типы -  позволяющими инициализировать своих представителей,
использовать  их в выражениях,  обеспечить возможности  ввода-вывода и
обработки ошибок и так далее.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="ctors"></a>Конструкторы и деструкторы</h3>
<p>

Важный этап в жизни переменных  - их создание и уничтожение. Например,
когда вы  создаете статическую переменную встроенного  типа, вы можете
рассчитывать,  что она  будет инициализирована  нулем. Либо  вы можете
явно    инициализировать   ее    при   создании    другим   значением.
Соответственно,  в  какой-то момент  работы  программы приходит  время
уничтожить переменную и освободить отведенную под нее память.

</p><p>

Чтобы  представитель  класса  вел  себя  подобным  образом,  в  классе
определяют  специальные функции -  конструкторы, которые  и занимаются
инициализацией.  Когда  переменная должна быть  уничтожена, вызывается
другая   функция  -  деструктор,   которая  аккуратно   выполняет  все
завершающие операции (например, закрывает вспомогательные файлы).
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="freestore"></a>Динамическая память - С++-стиль</h3>
<p>

Раз  уж  в классе  есть  возможности  для  аккуратной инициализации  и
уничтожения  переменных,  нужно  позаботиться, чтобы  эти  возможности
работали и при динамическом создании переменных. В С-стиле, основанном
на функциях  <em>malloc()</em> и <em>free()</em>, такого добиться  
трудновато. Поэтому в
С++  использован другой  подход -  в  язык добавлены  операторы 
<em>new</em>  и
<em>delete</em>. Делают  они примерно  
то же,  что <em>malloc</em> и  <em>free</em>, но  при этом
знают о существовании конструкторов и деструкторов. Кстати, и для
встроенных типов данных эти операторы прекрасно работают.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="ovld"></a>Перегрузка операторов и функций</h3>
<p>

Чтобы  переменные  пользовательского типа  можно  было использовать  в
выражениях наравне со встроенными типами, С++ позволяет определять для
них функции,  которые вызываются при  обработке операторов.  Например,
определив  в  соответсвующем  классе  подходящую  функцию,  вы  можете
определить оператор  умножения для  матриц или комплексных  чисел. Это
называется перегрузкой операторов (operator overloading).

</p><p>

Однако  при  этом  зачастую  одной  функции  на  оператор  оказывается
недостаточно.   Например,  ту  же  матрицу можно  умножить  на  другую
матрицу, а можно на константу. Ясно, что список параметров у этих двух
функций будет разным. В С++ позволительно определять несколько функций
с одним и  тем же именем -  лишь бы эти функции различались  по типу и
количеству параметров. Это и само по себе весьма удобное нововведение,
но,  главное, такая  возможность позволяет  задавать в  классах наборы
функций для перегружаемых операторов.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="refs"></a>Ссылки (references)</h3>
<p>

Да, как  я упоминал в первой части  курса, в С++ ссылки  есть. С точки
зрения С-программиста тут  можно отыскать и плюсы, и  минусы, но я так
понимаю, что без ссылок просто  нельзя было обойтись при создании С++.
Поясню на примере. В  выражении <em>i=++k</em> префиксный 
инкремент (++) делает
сразу  две вещи  -  он изменяет  переменную  k и  возвращает ее  новое
значение, которое и служит аргументом оператору присваивания.

</p><p>

Но,  как  только что  говорилось,  в  С++  для пользовательских  типов
оператор  вызывает соответсвующую функцию  класса.  Так  вот, ключевое
преимущество  передачи параметров  по  ссылке состоит  в  том, что  вы
можете  передать функции переменную,  функция изменит  ее, да  еще при
необходимости и результат вернет по  ссылке.  При этом в обоих случаях
вы  будете  иметь  дело не  с  копией  с  таким  же значением,  как  у
оригинала, а с самой оригинальной переменной -  именно это и требуется
в выражениях вроде приведенного выше.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="exceptions"></a>Исключения (exceptions)</h3>
<p>

При создании С++ пришлось подумать и об обработке ошибок. Использовать
в объектном коде С-стиль, проверяя, какое значение вернула функция, не
то  что утомительно,  а просто  не всегда  возможно. А  уж  о схожести
поведения  встроенных и  пользовательских  типов и  вовсе пришлось  бы
забыть. Поэтому  в С++ предусмотрен другой принцип  работы с ошибками,
более  гибкий и  универсальный.  И  средства для  этого внесены  в сам
синтаксис языка.

</p><p>

Когда какая-то  функция в С++ обнаруживает ошибку,  она генерирует так
называемое  исключение (exception), причем  вместе с  этим исключением
она может передавать на верхний уровень практически любую информацию о
подробностях возникшей ошибки.  И  при этом генерация исключения никак
не  связана с возвращаемым  значением функции  (тем, которое  ставят в
операторе  return). Если на  верхних уровнях  никто не  позаботился об
обработке ошибок такого типа,  то программа аварийно завершится.  Если
же обработка для них предусмотрена, то соотвествующий уровень, получив
информацию,  переданную  с  исключением,  может  попытаться  исправить
ситуацию и повторить вызов функции.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="inh"></a>Наследование и полиморфизм</h3>
<p>

Представьте себе  - у вас есть прекрасно  разработанный класс, который
описывает точку  на экране.  А вам хочется  иметь класс  для _цветной_
точки.  Обидно было бы  дублировать 90  процентов уже  имеющегося кода
только  для того, чтобы  добавить к  классу цвет.  К счастью,  в такой
ситуации достаточно заявить, что  новый класс "цветная точка" является
наследником класса "точка" -  при этом у "цветной точки" автоматически
появится  вся  начинка "точки"  (и  поля  данных,  и функции),  и  вам
придется писать  только то, что действительно отличает  новый класс от
предшественника. Это  и есть наследование (inheritance).  А исходный и
новый классы при этом называют базовым (base) и производным (derived),
соответственно.

</p><p>

Разумеется, такой  подход экономит  время и силы,  позволяя эффективно
использовать уже написанный  код. Но главное даже не  в этом. Построив
такую схему  наследования, вы сможете работать с  точкой независимо от
того,  цветная она  или нет  -  разумеется, до  тех пор,  пока вас  не
интересует  сам цвет.   Иными  словами, объекты  типа "цветная  точка"
смогут вести  себя как объекты "точка".  Подобная способность объектов
вести  себя по  разному в  зависимости  от того,  как ими  пользуются,
называется полиморфизмом (polymorphysm).

</p><p>

В  С++  производный  класс  может  наследовать  не  от  одного,  а  от
нескольких  базовых классов,  а те  в  свою очередь,  тоже могут  быть
чьими-то  наследниками, так что  наследование и  полиморфизм открывает
поистине безграничные  возможности для  творчества. Впрочем, они  же и
приводят к нечитабельности объектного кода - попробуй проследить через
десяток предков, что сделает какой-нибудь оператор.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="cppio"></a>Новый стиль ввода-вывода</h3>
<p>

Для завершенности картины не хватает  ввода-вывода, причем не как в С,
не на  основе функций (не  переписывать же printf() всякий  раз, когда
очередному классу потребуются  возможности ввода-вывода). Эта проблема
в  С++  решена  очень  изящно  - никаких  специальных  операторов  для
ввода-вывода  язык  не   предусматривает,  он  просто  использует  уже
имеющиеся операторы  &lt;&lt; и >>  (битового сдвига). Оказывается,  что тех
средств,  о  которых   уже  говорил  (классы,  перегрузка  операторов,
наследование)  вполне  достаточно,  чтобы  сделать  из  них  операторы
ввода-вывода  как для  встроенных,  так и  для пользовательских  типов
данных. Да при этом еще и сохранить их первоначальное назначение.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="view"></a>Общая картина</h3>
<p>


Разумеется, можно было бы еще много  о чем рассказать, и со временем я
буду обо всем этом рассказывать. Но сегодня я пытался рассказать вам о
"скелете"   С++,   увязать   воедино   его  ключевые   возможности   и
принципы. Итак, еще раз, совсем кратко:

<ol>
<li> Класс в С++ включает в себя не только данные, но и методы (функции)
   для работы с этими данными.

<li> Конструкторы и деструкторы позволяют
   правильно создавать и уничтожать представителей классов. 

<li> Благодаря новым операторам new и delete, конструкторы и деструкторы
   вызываются даже при работе с динамической памятью.

<li> Перегрузка функций и операторов и добавление в язык ссылок дают
   возможность использовать в выражениях объекты наравне с переменными
   встроенных типов.

<li> Наследование позволяет расширять функциональность уже имеющихся
   базовых классов, создавая на их основе производные классы. 
   Полиморфизм позволяет при необходимости работать с  производными
   классами так же, как с базовыми.

<li> Используя   перечисленные    выше   средства,   С++   предоставляет
   программисту новый  стиль ввода вывода,  который позволяет работать
   как с переменными встроенных типов, так и с объектами классов.

</ol>

Теперь,  когда  основные   идеи  обрисованы,  перейдем  к  техническим
деталям.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="compiler"></a>Как пользоваться транслятором</h2>
<p>

В качестве  расширений для исходных  файлов на С++  можно использовать
одно из ".C .cc .cxx" (набор может отличаться в зависимости от того, в
какой среде  вы работаете). Я буду использовать  ".cc".

</p><p>

Естественно, для работы с С++  вам понадобится сам транслятор и умение
им пользоваться. К счастью, у вас уже есть подобный опыт с программами
на  С,  так  что  это  будет  совсем просто  (тем,  у  кого  возникнут
затруднения,  советую  повторить  то,   что  я  говорил  о  раздельной
трансляции в первой части  курса).  Сам транслятор вызывается командой
с++, и  набор ключей у него такой  же, как у сс  (транслятора С). Так,
если программа умещается в один файл, то командой

<div class="incode">
        с++ prog.cc -o prog
</div>
вы можете получить из исходного текста готовую к запуску программу.

</p><p>

При раздельной трансляции вы сначала готовите объектные файлы

<div class="incode">
       с++ -с funcs.cc<br>
       с++ -с prog.cc<br>
</div>

а затем командой 

<div class="incode">
       c++ prog.o funcs.o -o prog
</div>

получаете из них исполняемую программу.

</p><p>

Так же, как в трансляторе С, ключ -l 

<div class="incode">
       с++ prog.cc -lm -o prog
</div>

используется  для подключения библиотек. 

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="compat"></a>Несовместимость C и C++</h2>
<p>

Здесь речь пойдет о весьма  прозаической вещи - о том, какие сложности
могут  возникнуть  при  обработке  С-программы  транслятором  С++,  и,
разумеется, о том, как с ними бороться (это не очень сложно, поскольку
отличий между "чистым" С и подмножеством С в С++ немного).  Подробно я
расскажу только  о двух  самых распространенных причинах,  о некоторых
других только упомяну, а кое-что вообще оставлю "за кадром".

</p><p>

Львиная доля неприятностей приходится на сообщения примерно такого
вида

<div class="incode">
prog.cc:3: error: `f' undeclared (first use this function)
</div>

либо 

<div class="incode">
prog.o(.text+0x16): undefined reference to `f(int)'
</div>

Давайте разберемся, откуда берутся эти сообщения. 

</p><p>

Взгляните на такую программу

<div class="incode">
          /* file prog.cc */<br>
          int main() {<br>
          &nbsp;&nbsp;return f(0);<br>
          }<br>
</div>

При попытке оттранслировать ее "c++&nbsp;-c&nbsp;prog.cc" транслятор и выдал
первое сообщение  

<div class="incode">
prog.cc:3: error: `f' undeclared (first use this function)
</div>

Поскольку в нем ясно написано, что у функции f нет объявления, мы его
добавим

<div class="incode">
          /* file prog.cc */<br>
          int f(int x);<br>
          int main() {<br>
          &nbsp;&nbsp;return f(0);<br>
          }<br>
</div>

и повторим попытку "c++&nbsp;-c&nbsp;prog.cc". Теперь все в порядке, все дело
было, как м предполагалось,  в отсутствии объявления для функции f.
Транслятор С успешно оттранслировал бы такой файл, но С++ гораздо
строже относится к типам аргументов у функций, и для него  отсутствие
объявления функции - фатальная ошибка.

</p><p>

Теперь  предположим, что  в файле  <em>func.o</em> находится  
код  функции <em>int&nbsp;f(int  x)</em>, правда,  полученный с  
помощью транслятора  С.  Попытаемся
собрать нашу программу из двух файлов.

<div class="incode">
     c++ prog.o func.o -o prog
</div>

Снова неудача, правда сообщение теперь второго типа

<div class="incode">
prog.o(.text+0x16): undefined reference to `f(int)'
</div>

Это уже непонятно - ведь мы точно знаем, что написали правильное
объявление для внешней функции. 

</p><p>

А дело  в том, что  С++ по другому  работает с именами функций,  и ему
мало сказать, что <em>f()</em> - функция  с одним целым аргументом. 
Нужно еще и
сообщить, что эту функцию транслировал обычный С-транслятором. 

</p><p>

Делается это  указанием "компоновки, принятой в С",  (не самый внятный
и,  подозреваю,  не  единственный   вариант  перевода,  но  с  русской
терминологией  всегда  нескучно.   В  английском варианте  -  external
linkage specification). Выглядит это следующим образом:

<div class="incode">
        extern "C"  объявление_функции;
</div>

(для объявления одной С-функции) или

<div class="incode">
        extern "C"  {<br>
        &nbsp;&nbsp;объявление_функции;<br>
        &nbsp;&nbsp;объявление_функции;<br>
        }<br>
</div>

(для объявления нескольких С-функций).

</p><p>

Внеся подобное объявление в prog.cc

<div class="incode">
          /* file prog.cc */<br>
<br>
          extern "C"  int f(int x);<br>
<br>
          int main() {<br>
          &nbsp;&nbsp;return f(0);<br>
          }<br>
</div>

можно, наконец, заставить нашу программу работать.

</p><p>

Зачем   я  уделил   столько  времени   рассказу  об   этих  источниках
неприятностей?  Дело в том, что подобные проблемы чаще возникают не со
своими функциями,  (свои, в крайнем случае,  можно перетранслировать с
помощью С++), а с библиотечными, к которым порой и исходного кода нет.
Разумеется, на приличном трансляторе в заголовочных файлах стандартной
библиотеки  уже  есть правильные  объявления,  но  заголовки к  другим
библиотекам  частенько  рассчитаны только  на  С,  и  вы, если  будете
программировать, рано или поздно с такими столкнетесь.

</p><p>

Из остальных возможных причин несовместимости С и С++ кода упомяну
только две. 

</p><p>

Во первых, в С++ гораздо больше ключевых слов. И если в вашей
С-программе имя какой-нибудь переменной неудачно совпадет с одним из
новых ключевых слов, вам придется это имя поменять. Упоминаю об этом
только из-за не очень внятного сообщения транслятора о подобных
ошибках - мой транслятор про строку 

<div class="incode">
    int using;
</div> 

написал

<div class="incode">
  error: syntax error before `using'
</div>

Полный  список новых ключевых  слов я  приводить не  буду -  его легко
отыскать в книгах.

</p><p>

Во вторых, оператор <em>goto</em> в С++ не может "перепрыгивать" строки, в
которых создаются переменные (в С, насколько я помню, такого запрета
нет). То есть, нельзя писать так:

<div class="incode">
      goto mark;<br>
      {<br>
      &nbsp;&nbsp;int k;<br>
     mark:<br>
      &nbsp;&nbsp;k++;<br>
      }<br>
</div>

Причина этого вполне понятна - борьба  за правильную инициализацию
переменных. 

</p><p>

Вот и  все, что я собирался  рассказать о несовместимости С  и С++.  И
теперь можно начинать знакомство с  самим языком - с теми новшествами,
которые предлагает С++.
</p>

<hr align="center" width="50%">
<h1 align="center"><a name="c_enhanced"></a>
     С++ как "улучшенный" С</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
<p>

В  попытке  руководствоваться принципом  "от  простого  к сложному"  я
постараюсь  разделить нововведения на  три части  - условно  назовем их
"улучшения", "расширения", "новые возможности" (идея не моя, я
когда-то подсмотрел ее у другого автора). 

</p><p>

В  "улучшения"  попадут  совсем  небольшие изменения,  которые  вполне
разумно  и естественно  выглядели бы  и  в языке  С. Их,  естественно,
немного.

</p><p>

К "расширениям" я отнесу  более существенные нововведения, но такие, к
которым программисту на С было бы легко привыкнуть. Таких нововведений
тоже немного.

</p><p>

И,  наконец, "новые  возможности"  - те  совершенно  новые средства  и
возможности,  благодаря которым С++  стал не  просто расширением  С, а
действительно новым языком - мощным и очень популярным. С этими новыми
средствами мы  и будем знакомиться  основную часть времени,  до самого
конца курса.

</p><p>

Начнем мы с того, что можно было бы назвать "улучшенным" C.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="comments"></a>Новый вариант комментариев</h2>
<p>

В обычном С комментарии
ограничены с обеих сторон специальными комбинациями символов

<div class="incode">
     /* комментарий в стиле C */
</div>

и могут занимать несколько строк.   В С++ можно также поставить подряд
два символа <em>//</em>, при этом все после этих символов до конца 
строки будет
также расцениваться, как комментарий

<div class="incode">
      // Пример комментария в С++<br>
      i++;   // инкрементируем переменную i<br>
</div>

Новшество довольно ценное, особенно если вспомнить, что классические
С-комментарий не могут вкладываться друг в друга. Например, в
программе для "штатных" комментариев можно использовать новый стиль,
а при отладке комментировать целые куски кода, не рискуя получить
ошибку из-за вложенных комментариев:

<div class="incode">
       /* Temporarily commented for debugging<br>
<br>
         // Function for finding substring <br>
         char *substring(char *str) <br>
         {    <br>
         &nbsp;&nbsp;if (str == 0) // Check argument against 0<br>
         &nbsp;&nbsp;{<br>
         &nbsp;&nbsp;&nbsp;&nbsp;return 0;  // invalid argument<br>
         &nbsp;&nbsp;}<br>
<br>
         &nbsp;&nbsp;...<br>
<br>
       END Temporarily commented for debugging */<br>
</div>

Этот  новый  вариант  комментариев  настолько  удобен,  что  его  даже
собирались  включить в  очередной стандарт  С  (а может,  даже, уже  и
включили).
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="unnamedparams"></a>Неименованные параметры</h2>
<p>

Следующее улучшение - неименованные параметры в определении
функций. Случается, в вызове функции стоит большее  число параметров,
чем на самом деле функция использует (причины могут быть разные, но
речь сейчас не о них). В этом случае можно не указывать имя ненужного
параметра при определении функции. Сравните 

<div class="incode">
          int f(int x, int y, int z) {<br>
          &nbsp;&nbsp;return x+z;<br>
          }<br>
</div>

и

<div class="incode">
          int f(int x, int, int z) {<br>
          &nbsp;&nbsp;return x+z;<br>
          }<br>
</div>

В последнем варианте тому, кто смотрит код, сразу ясно - о втором
параметре функции не забыли, его не используют намеренно.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="newinit"></a>
	   Новый синтаксис приведения типов и инициализации
	 </h2>
<p>

В С++ также добавили новый синтаксис  для инициализации переменных и
приведения типов. В следующем примере присутсвуют оба варианта
синтаксиса:

<div class="incode">
            int i=1; // Old style initialization<br>
            int j(1); // New style initialization<br>
            ...<br>
<br>
            i = (int) 1.5/j;   // Old style typecast<br>
            i = int(1.5/j);   // New style typecast<br>
</div>

Как  видите, новый  синтаксис и  для инициализации,  и  для приведения
типов  напоминает вызов  функции. Мне  он особенно  нравится  в случае
приведения типов  - не  приходится напрягаться, соображая,  что именно
приводится - число 1.5 или все выражение 1.5/j.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="hiddenglobal"></a>
            Доступ к замаскированной глобальной переменной
	 </h2>
<p>

В С  параметр или  локальная переменная функции  маскируют одноименную
глобальную переменную, и у вас  нет возможности ее использовать. В С++
в  подобной  ситуации   функция  также  будет  использовать  локальную
переменную или  параметр, но при необходимости вы  сможете добраться и
до глобальной, для этого перед ее именем надо поставить <em>::</em> 
(два символа двоеточия):

<div class="code">
       int i;   // global scope variable<br>
<br>
       void  f() {<br>
       &nbsp;&nbsp;int i;<br>
       &nbsp;&nbsp;i = 0;     // Local i used<br>
<br>
       &nbsp;&nbsp;::i=0      // Global i used, would be impossible in C<br>
<br>
       }<br>
</div>

Замечу, что  сдвоенный символ двоеточия  - это так  называемй оператор
разрешения   области   видимости   (scope   resolution   operator)   и
используется он  не только для  доступа к глобальным переменным.  Но и
такое простое его применение порой оказывается полезным.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="anyplace"></a>Создание переменных</h2>
<p>

Еще одно улучшение - в С++ переменные можно создавать не только на
глобальном уровне либо в начале блока до первого исполняемого
оператора, но и  после исполняемых операторов, и даже в заголовке
цикла for. В приведенном примере

<div class="incode">
      main(int argc, char **argv) {<br>
<br>
      &nbsp;&nbsp;if (argc==0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>
<br>
      &nbsp;&nbsp;char *p;               // Error in C, OK in C++<br>
<br>
      &nbsp;&nbsp;for (int i=0; i&lt;argc; i++) { // Error in C, OK in C++<br>
      &nbsp;&nbsp;&nbsp;&nbsp;p = argv[i];<br>
      &nbsp;&nbsp;}<br>
<br>
      &nbsp;&nbsp;return 0;<br>
      }<br>
</div>

обе  локальные  переменные  создаются  против  правил  С  (эти  строки
отмечены комментариями), однако С++ такое допускает. Во втором случае,
когда переменная i создается прямо  в заголовке цикла for, у вас может
возникнуть вопрос  - а какая у  нее область видимости,  к какому блоку
она относится. При  стандартизации языка на эту тему  долго спорили, в
конце концов сошлись на том, что такая переменная видна только в шапке
и теле цикла, но не видна в блоке, в котором этот цикл стоит.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="inlines"></a>Встроенные (inline) функции</h2>
<p>

Это последнее из нововведений, которое я отнес к "улучшениям".

</p><p>

Сначала напомню, что такое макросы (макроопределения) с параметрами.
В С вы можете директивой препроцессора 

<div class="incode">
  #define  sqr(x)        ((x)*(x))
</div>

подставить выражение <em>((i)*(i))</em>  вместо <em>sqr(i)</em> 
везде в тексте программы
(аргумент при использовании макроопределения может быть любой). Это
очень похоже на вызов функции, но замена происходит именно
текстовая. По этой причине макросы работают быстрее функций (чем и
привлекательны). И по этой же причине служат источником неприятных
ошибок - написав <em>sqr(i++)</em>, вы инкрементируете переменную не один, а
два раза.

</p><p>

С++ предлагает достойную и безопасную замену макросам - встроенные
функции. В нем можно перед определением функции добавить ключевое
слово <em>inline</em>

<div class="incode">
      inline int sqr(int i) { return i*i; }
</div>

и процессор будет  встраивать код функции прямо в  места ее вызовов. И
при этом  позаботится, чтобы вызов <em>sqr(i++)</em> сработал  
правильно, как и
для "полновесной" функции. Так что этот вариант позволяет генерировать
очень  эффективный  код,  и   при  этом  избавляет  от  неприятностей,
характерных для макросов.

</p><p>

Должен,  правда,  заметить,  что   ключевое  слово  <em>inline</em>  
носит  для
транслятора рекомендательный характер -  слишком сложные функции он по
прежнему будет делать  полновесными. Так что inline-функции желательно
делать короткими - в идеале однострочными.

</p><p>

Кстати,  встраиваемые функции  особенно  ценны в  объектном коде,  для
которого характерно изобилие вызовов  коротких функций - там они могут
кардинально повысить эффективность программы.

</p><p>
<br><br><br>

На  этом  сегодняшнее занятие  закончено.  В  следующий  раз мы  будем
говорить о С++  как о "расширенном С", то  есть, о более существенных,
но все еще не слишком сложных нововведениях С++ по сравнению с С.


</p>
    </td>
  </tr>
</table>


</div>
</body>
</html>
