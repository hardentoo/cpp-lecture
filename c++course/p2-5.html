<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 5</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 5</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li><a href="p2-5.html#reffields">Ссылки в качестве полей данных</a> </li>
        <li><a href="p2-5.html#copyctor">Копирующий конструктор</a> </li>
        <li><a href="p2-5.html#this">Неявный указатель this</a> </li>
        <li><a href="p2-5.html#staticmembers">Статические члены класса</a> </li>
        <li><a href="p2-5.html#operators">Перегрузка операторов</a> </li>

      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="reffields"></a>Ссылки в качестве полей данных</h2>

<p>

На  прошлом занятии  я  намекал,  что в  качестве  полей данных  можно
использовать   ссылки  (когда   говорил  об   инициализации   полей  в
конструкторах). Использование  ссылок (и  не только в  качестве полей)
порой приводит  к неочевидным  ошибкам и требует  особой аккуратности.
Сейчас я расскажу о двух связанных с ними "подводных камнях" в надежде
уберечь вас от подобных неприятностей.

</p>
<p>

Итак,   поле-ссылку    можно   инициализировать   только    в   списке
инициализаторов конструктора. Вот пример с прошлого занятия, в котором
поле b (ссылка) инициализируется аргументом конструктора:

</p>
<p>
   <div class="code">

class TRICKY { <br>
  &nbsp;&nbsp;const int a;<br>
  &nbsp;&nbsp;int&  b;<br>
public:<br>
<br>
  &nbsp;&nbsp;// Would like to set a=i and to bind b with j;<br>
  &nbsp;&nbsp;TRICKY(int i, int &j) : a(i), b(j) <br>
  &nbsp;&nbsp;{<br>
  &nbsp;&nbsp;&nbsp;&nbsp;// Now ok, a 
          initialized with i, b bound with j<br>
  &nbsp;&nbsp;};<br>
  &nbsp;&nbsp;...<br>
};<br>

  </div>

Но обратите внимание, аргумент конструктора  - тоже ссылка. Если бы мы
написали

  <div class="incode">
TRICKY(int i, int j) : a(i), b(j) 
  </div>

последствия были бы катастрофическими - поле-ссылка инициализировалось
бы  локальной  копией  параметра  j.  В  случае  ссылки  инициализация
означает, что  всякий раз,  когда мы ее  используем, мы на  самом деле
обращаемся    к   той    переменной,   которая    использовалась   при
инициализации.  Но  локальная копия  параметра  j уничтожается,  когда
конструктор  заканчивает  работу. А  значит,  все время  существования
объекта типа  TRICKY ссылка была  бы связана с переменной,  которой не
существует.

</p>
<p>

Подобная  ошибка  -   инициализировать  ссылку  временным  объектом  -
довольно   популярна.   И,   кстати,    не   только   при   работе   с
полями-ссылками. Примерно такие  же неприятности вы можете заработать,
возвращая ссылку в качестве результата функции.

</p>
<p>

Второй  источник  неприятностей,  связанных  с  полями-ссылками  -  их
поведение  в операциях копирования.  Обращаясь к  ссылке, вы  на самом
деле обращаетесь к связанному с ней объекту. Так что, написав

</p>
<p>
  <div class="code">
          int i,j;<br>
          int &refi(i);<br>
          int &refj(j);<br>
	  <br>
          refi = refj;<br>
  </div>
вы просто зашлете  в переменную i значение переменной  j. Это несложно
понять и запомнить, и даже начинающие к этому быстро привыкают. Однако
почему-то  гораздо труднее  бывает осознать,  что и  ссылки-поля ведут
себя точно так же. Взгляните на такой пример
  <div class="code">
          class INTREF {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;int& ref;<br>
          public:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;INTREF(int& v) : ref(v) {};<br>
            &nbsp;&nbsp;&nbsp;&nbsp;...<br>
          };<br>
	  <br>
          ...<br>
	  <br>
          int i,j;<br>  
	  <br>
          INTREF a(i), b(j);<br>
          a=b;<br>
  </div>
Многим  интуитивно кажется,  что стоящий  в последней  строке оператор
присваивания должен разорвать связь объекта a с переменной i и связать
его с  j. Однако в языке  просто нет средств, чтобы  добиться этого. К
тому  же  путаницы  добавляет автоматически  предоставляемый  оператор
присваивания для классов, который  копирует все поля из одного объекта
в  другой. На  некоторых трансляторах  это приводило  раньше  к весьма
странным результатам, и  приходилось даже делать оператор присваивания
личным (private)  методом класса, чтобы транслятор  давал сообщение об
ошибке  при  попытке  его  использовать.  Когда я  готовился  к  этому
занятию,  я  решил  проверить,   как  обстоят  дела  сейчас.  Ситуация
изменилась к лучшему, по крайней мере, в случае gcc 3.3.3 - транслятор
мне объяснил, что раз уж мне понадобилось поле-ссылка, то я сам должен
озаботиться написанием оператора присваивания.

</p>

   </td>
  <tr>
</table>

<br>
<hr align="center" width="50%">
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="copyctor"></a>Копирующий конструктор</h2>
<p>
Конструкторы,  как   вы  помните,  отвечают   за  инициализацию  вновь
созданного  объекта. Причем  объект можно  инициализировать значениями
разных  типов  -  лишь  бы  в  классе  присутствовали  конструкторы  с
подходящими по типу параметрами.
</p>
<p>
Как  правило,  набор конструкторов  для  разных типов инициализирующих
значений   обеспечивается    разработчиком   класса.   Скажем,   чтобы
инициализировать класс A типом int, программист должен предусмотреть в
классе  конструктор A(int),  и так  далее. Но  есть два  исключения из
этого   правила.   Первое  -   когда   создаваемый   объект  явно   не
инициализируется:
<div class="incode">
          A a;
</div>
Второе - когда объект инициализируется другим объектом того же типа:
<div class="incode">
          A a;<br>
          A b(a);
</div>
В этих случаях, даже  если вы не написали соответствующий конструктор,
транслятор  создаст  его  автоматически.  В первом  случае  это  будет
конструктор   по  умолчанию   (default  constructor),   о   котором  я
рассказывал на прошлом занятии.  Во втором - так называеымй копирующий
конструктор (copy constructor), о котором мы сейчас и будем говорить.
</p>

<h3>Сигнатура копирующего конструктора</h3>
<p>
Копирующим   может   быть   любой   конструктор,   который   позволяет
инициализировать новый объект другим  объектом того же типа. Это может
быть даже конструктор с  несколькими аргументами, если вы зададите для
"лишних"  аргументов  значения по  умолчанию.  Но наиболее  популярная
сигнатура  такого  конструктора  использует  единственный  параметр  -
константную ссылку на свой тип.  Так, например, для класса А это будет
конструктор с сигнатурой

<div class="incode">A::A(const A&);</div>

Именно   такой  конструктор  создается   автоматически,  если   вы  не
определили копирующий конструктор в классе явно.
</p>
<p>
В качестве разумного  приближения автоматически создаваемый копирующий
конструктор  использует обычное  копирование  полей объекта-образца  в
новый  объект.   Это  называется  почленным  копированием  (memberwise
initialisation).   Причем если  какое-то поле  само  является объектом
класса,  то почленное  копирование в  свою очередь  вызовет копирующий
конструктор для  этого поля.  Для встроенных же  типов и  для классов,
поля  которых  не  имеют  таких конструкторов,  почленное  копирование
просто сведется к побитовому копированию содержимого из одного объекта
в другой.
</p>
<p>
К  сожалению,  далеко не  во  всех  случаях  подобное поведение  может
обеспечить правильное создание объекта.  Проблемы, например, возникают
в случае, когда объект, захватывая в конструкторе область динамической
памяти,   затем   хранит  ее   адрес   в   поле-указателе.  При   этом
автоматическая   операция  копирования   приведет  не   к  копированию
содержимого памяти в новый объект, а к копированию значения указателя,
что обычно  не соответсвует желаемому  поведению и к тому  же вызывает
лишние  проблемы при  освобождении  памяти. Скажем,  если  у вас  есть
класс-строка

<div class="code">
             class MyString {<br>
             &nbsp;&nbsp;char *buf;<br>
             public:<br>
             &nbsp;&nbsp;MyString(const char *str) <br>
             &nbsp;&nbsp;&nbsp;&nbsp;: buf( new char[strlen(str)+1] )<br>
             &nbsp;&nbsp;{<br>
             &nbsp;&nbsp;&nbsp;&nbsp;strcpy(buf, str);<br>
             &nbsp;&nbsp;};<br>
	     <br>
             &nbsp;&nbsp;~MyString() { delete []buf; } <br>
             };<br>
</div>
и вы пытаетесь использовать его таким образом
<div class="code">

             MyString str1("Message");<br>
             {<br>
	     &nbsp;&nbsp;MyString str2(str1);     // str2.buf = str1.buf<br>
             }                          // str2.~MyString();<br>
	     <br>
             ... // str1 exists, but buf already deleted<br>
</div>
то  автоматический копирующий  конструктор запишет  в str2.buf  тот же
адрес, что и  в str1.buf. Затем, при выходе  str2 из области видимости
его  деструктор  освободит  область,   на  которую  указывает  buf.  В
результате после локального  блока использование объекта str1 приведет
к ошибке.
</p>
<p>
В подобных  случаях надо отказаться от  автоматического конструктора и
явно задать в классе версию с правильным поведением:
<div class="code">

             class MyString {<br>
             &nbsp;&nbsp;char *buf;<br>
             public:<br>
             &nbsp;&nbsp;MyString(const char *str)<br>
             &nbsp;&nbsp;&nbsp;&nbsp;: buf( new char[strlen(str)+1] )<br>
             &nbsp;&nbsp;{<br>
             &nbsp;&nbsp;&nbsp;&nbsp;strcpy(buf, str); <br>
             &nbsp;&nbsp;};<br>
	     <br>
             &nbsp;&nbsp;MyString(const MyString& src) {<br>
             &nbsp;&nbsp;&nbsp;&nbsp;int size = strlen(src.buf) + 1;<br>
             &nbsp;&nbsp;&nbsp;&nbsp;buf = new char[size];<br>
             &nbsp;&nbsp;&nbsp;&nbsp;strcpy(buf, src.buf);<br>
             &nbsp;&nbsp;}<br>
	     <br>
             &nbsp;&nbsp;~MyString() { delete []buf; }<br>
             };<br>

</div>
Теперь вместо почленной инициализации будет вызываться написанный нами
копирующий конструктор.
</p>
         </td>
    </tr>
   </table>


<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="this"></a>Неявный указатель this</h2>
<p>
Мы уже  несколько занятий говорим о  классах и методах. И  у вас давно
мог  возникнуть вопрос  - а  как методы  разбираются, с  полями какого
именно объекта  им надо работать,  если объектов одного типа  много? В
самом деле, создавая класс
<div class="code">
          class A {<br>
          &nbsp;&nbsp;int i;<br>
          public:<br>
          &nbsp;&nbsp;A(int v) : i(v) {};<br>
          &nbsp;&nbsp;int f() { return i; } <br>
          };<br> 
</div>
и используя его объекты
<div class="code">
          A a(1), b(2);<br>
	  <br>
          int k = a.f();<br>
</div>
мы  полагаем, что  конструктор  и функция  f()  сами разберутся,  поле
какого  именно объекта нужно  использовать. О  том, что  происходит за
кадром, можно было бы вообще не упоминать (работает, и ладно), если бы
не случаи, когда самому  программисту хочется получить доступ ко всему
объекту, а не к отдельным его полям.
</p>
<p>
Разгадка проста.  Функции-члены класса (за  исключением статических, о
которых я скажу чуть позже)  получают в дополнение к списку параметров
еще и неявный указатель this - адрес "своего" объекта, того, с которым
они вызваны и поля которого они должны обрабатывать.
</p><p>
Этот  указатель  при  необходимости   можно  использовать  и  в  явном
виде. Например, в функции f() из только что приведенного примера можно
было бы написать
<div class="incode">
            int f() { return this->i; }<br>
</div>
и она бы делала то же самое, что и раньше.
</p>
<p>
А необходимость такая возникает довольно часто. Например, в классе
<div class="code">
          class B {<br>
          &nbsp;&nbsp;...<br>
          public:<br>
          &nbsp;&nbsp;B getobject() { return *this; }<br>
          };<br>
</div>
указатель  this  позволяет  вернуть   из  функции  сам  объект.  Также
приходится использовать  this при  операции копирования и  в некоторых
других случаях.
</p>
         </td>
    </tr>
   </table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="staticmembers"></a>Статические члены класса</h2>
<p>
До  сих пор мы  работали с  такими полями  данных, свой  набор которых
существует  в каждом  объекте.  Соответственно и  методы, которыми  мы
пользовались,  получая  неявно  указатель this,  пользовались  набором
полей   конкретного   объекта.   Такие   поля  и   методы   называются
нестатическими.
</p>
<p>
Помимо нестатических, существуют  еще и статические члены -  и поля, и
функции.
</p>
<p>
Статическое  поле  данных класса  (static  data  member) существует  в
единственном  экземпляре независимо  от того,  сколько  объектов этого
класса  используется в  программе.  Подобные  поля  позволяют объектам
обмениваться  между собой  информацией  - например,  вы  с их  помощью
подсчитать, сколько всего объектов класса работает в данной программе,
или  хранить в  статическом  поле последний  созданный  объект, и  так
далее.
</p>
<p>
Для того,  чтобы создать статическое поле данных,  нужно проделать две
веши:
</p>
Во-первых, надо объявить поле в теле класса с использованием ключевого
слова static:
<div class="code">

          class COUNT_OBJECTS {<br>
          public:<br>
          &nbsp;&nbsp;static int counter;<br>
          &nbsp;&nbsp;...<br>
          };<br>
</div>
(напомню, тело класса обычно хранится в файле заголовков).
</p>
<p>
Во  вторых, надо  обязательно определить  это поле  в одной  из единиц
трансляции (в файле с расширением  .cc), чтобы отвести под него память
и, если  нужно, инициализировать. Причем в этом  случае ключевое слово
static ставить не только не надо, но и нельзя:
<div class="code">
          int COUNT_OBJECTS::counter = 0;
</div>
статические  поля  существуют  независимо  от того,  сколько  объектов
класса создано (в том числе даже если нет ни одного объекта).  В телах
функций-членов  класса   использование  статических  полей   ничем  не
отличается от использования обычных:
<div class="code">
          class COUNT_OBJECTS {<br>
          public:<br>
          &nbsp;&nbsp;static int counter;<br>
          &nbsp;&nbsp;COUNT_OBJECTS() { counter++; }<br>
          &nbsp;&nbsp;~COUNT_OBJECTS() { --counter; }<br>
          &nbsp;&nbsp;...<br>
          };<br>
</div>
Извне обратиться к ним напрямую (если позволяет уровень доступа) можно
либо  через любой  объект этого  класса, либо  с  использованием имени
самого класса:
<div class="code">
          COUNT_OBJECTS a;<br>
          int n;<br>
	  <br>
          n = a.counter;<br>
          n = COUNT_OBJECTS::counter;<br>
</div>        
Статическая функция-член - это метод класса для работы со статическими
полями.   Ее  главное  отличие   от  нестатических   функций-членов  -
отсутствие  неявного  указателя this.  Так,  более  правильно было  бы
сделать поле  counter личным, и написать  статическую член-функцию для
доступа  к нему  - тогда  мы  исключили бы  возможность испортить  наш
счетчик прямым присваиванием значения полю:
<div class="code">
          class COUNT_OBJECTS {<br>
          private:<br>
          &nbsp;&nbsp;static int counter;<br>
          public:<br>
          &nbsp;&nbsp;COUNT_OBJECTS() { counter++; }<br>
          &nbsp;&nbsp;~COUNT_OBJECTS() { --counter; }<br>
          &nbsp;&nbsp;static int get_counter() { return counter; }<br>
          };<br>
	  <br>
          int COUNT_OBJECTS::counter=0;<br>
</div>
Вызывать статическую  функцию-член также  можно либо с  любым объектом
этого типа, либо используя имя класса:
<div class="code">

       cout &lt;&lt; "Currently " <br>
            &nbsp;&nbsp;&lt;&lt; COUNT_OBJECTS::get_counter() <br>
            &nbsp;&nbsp;&lt;&lt; " objects exist" &lt;&lt; endl;<br>
       <br>
       COUNT_OBJECTS a, b, *c = new COUNT_OBJECTS;<br>
       <br>
       cout &lt;&lt; "Currently " &lt;&lt; a.get_counter() <br>
            &nbsp;&nbsp;&lt;&lt; " objects exist" &lt;&lt; endl;<br>
       <br>
       delete c;<br>
       <br>
       cout &lt;&lt; "Currently " &lt;&lt; a.get_counter() <br>
            &nbsp;&nbsp;&lt;&lt; "objects exist" &lt;&lt; endl;<br>
</div>
Если подобную программу собрать и запустить, она должна напечатать три
строки:
<div class="session">
      Currently 0 objects exist<br>
      Currently 3 objects exist<br>
      Currently 2 objects exist<br>
</div>
Вот  мы  и  написали  класс,  который  сам  считает  количество  своих
объектов.
</p>
         </td>
    </tr>
   </table>



<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="operators"></a>Перегрузка операторов</h2>
<p>
Перегрузка  операторов -  очень важный  раздел. Но,  поскольку времени
мало,  самих  операторов много,  да  и  правила  для них  разнятся,  я
попытаюсь  быть  кратким  -   дам  общую,  необходимую  для  понимания
принципов информацию, а потом мы рассмотрим некоторые особо важные или
особо интересные операторы.
</p>
<p>
Итак,  сначала -  общая  информация, так  сказать,  сводка правил  при
работе с перегружаемыми операторами.
<ol>
<li>
Операторы   перегружаются   только   для   пользовательских   типов
(исключение - глобальные new delete).
<li>
Нельзя изобрести  новые операторы - можно только  дать свою начинку
имеющимся
<li>
Нельзя    поменять   правила    разбора   выражений,    зашитые   в
транслятор. Например, нельзя сделать бинарный оператор унарным, или
поменять приоритеты операций.
<li>
Можно,  но  не  стоит  наполнять  операторы  странным,  неочевидным
содержимым.  Например,  вы  в  состоянии поменять  в  своем  классе
значение операторов  + и  -, но так  делать нехорошо. Еще  пример -
оператор +  в случае  текстовых строк вполне  понятен -  слияние. А
какой смысл для тех же текстовых строк у оператора деления?
<li>
Некоторые операторы вообще нельзя  перегружать и они сразу доступны
для  объектов класса.  Для некоторых  автоматически предоставляется
вариант по  умолчанию (если вы  не написали свой) Но  в большинстве
своем операторы сначала должны  быть созданы (написаны) для класса,
и только после этого их можно использовать.
<li>
Когда речь идет  о встроенных типах данных, вы  в некоторых случаях
можете ожидать  одинаковых результатов от  разных выражений (i=i+j;
i+=j;).  Когда   речь  заходит  о   классах,  обеспечение  подобной
эквивалентности  лежит  на ваших  плечах  (в  примере  - вы  должны
написать одинаковое  поведение для  операторов + и  +=). Из  той же
оперы -  если вы  хотите выразить один  оператор через другой  - вы
должны сделать это явно.
<li>
Операторы  перегружаются  либо  в  виде  функций-членов  (то  есть,
методов  класса),  либо   в  виде  дружественных  функций.   Однако
некоторые по  правилам языка могут  быть реализованы только  в виде
функций-членов  (например,  оператор  присваивания).  Также  бывают
противоположные ситуации - приходится использовать не член-функцию:
а  дружественную.   Правда,  в  последнем   случае  это  требование
накладывается не самими правилами языка, а имеющимся в распоряжении
набором классов (как, например, в случае операторов ввода-вывода >>
и &lt;&lt;).
<li>
Очень  немного операторов  жестко  требуют какого-то  определенного
типа  возвращаемого  значения.  В  большинстве своем  вы  абсолютно
свободня в выборе типа  результата. Однако правила языка и контекст
использования операторов зачастую дают рекомендации на тип значения
(так, например,  желательно, чтобы оператор  присваивания возвращал
тот же тип, что и у своего объекта).
<li>
Вовсе необязательно делать одну функцию на оператор. Можете сделать
на каждый оператор сколько  угодно функций, лишь бы они различались
по сигнатуре. Только  не забывайте, что тип результата  не входит в
сигнатуру.
<li>
Нельзя задавать значения по умолчанию для параметров в операторах. 
</ol> 
Очень важно, чтобы вы понимали, чем оператор - член-функция отличается
от  оператора  -  дружественной   функции,  сколько  у  тех  и  других
аргументов,  и   что  означают  возвращаемые   ими  значения.  Давайте
разберемся с этим на примере оператора +.
</p>
<p>
Посмотрите на такое выражение
<div class="code">           
           int x;<br>
           A y,z;<br>
	   <br>
           x = y + z;<br>
</div>
Ясно,  что для класса  A должен  быть определен  бинарный (то  есть, с
двумя  операндами) оператор  сложения.  Заглянув  в книгу  по  С++, вы
увидите, что  его можно определить либо  как член функцию  с одним (!)
аргументом, либо как дружественную функцию с двумя аргументами.
</p>
<p>
С дружественной  функцией все понятно - оператор  бинарный и аргумента
два:
<div class="code">
          class A {<br>
          &nbsp;&nbsp;friend int operator+(A a, A b);<br>
          &nbsp;&nbsp;int i;<br>
          };<br>
	  <br>
          int operator+(A a, A b) {<br>
          &nbsp;&nbsp;return a.i + b.i;<br>
          }<br>
</div>
Если мы определяем сложение таким образом, то для выражения
<div class="code">
          x=y+z;
</div>
будет использован вызов
<div class="code">
         x = operator+(y,z);
</div>
Трудности у  начинающих вызывают  операторы - член-функции.  у которых
аргументов  на один меньше,  чем у  соответствующих им  операторов. На
самом деле в  них тоже нет ничего сложного -  нужно просто помнить про
то, что  таким функциям  напрямую доступен сам  объект, с  которым они
вызваны - это и есть недостающий операнд:
<div class="code">
        class A {<br>
        &nbsp;&nbsp;int i;<br>
        public:<br>
        &nbsp;&nbsp;A operator +(A obj) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;return i+obj.i;<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;...;<br>
        };<br>
</div> 
А само выражение x=y+z при этом развернется в вызов
<div class="code">
       x = y.operator+(z);
</div>
Отсюда  следует существенный  момент -  для того,  чтобы  была вызвана
член-функция,  первый  операнд  оператора  должен быть  объектом  того
класса,  в  котором  эта   член-функция  определена  (или  хотя  бы  у
транслятора  должна быть  возможность  привести этот  операнд к такому
типу).  Для  дружественных  функций  такого ограничения  нет.  Кстати,
именно  поэтому операторы  ввода-вывода >>  и  &lt;&lt;  для  классов всегда
пишут в виде дружественных функций
<div class="code">
      friend istream& operator>>(istream& in, A& obj);
</div>
- ведь первый  аругмент у  них - не  объект класса, для  которого этот
оператор пишут, а поток, так что в виде член-функции класса A подобный
оператор написать просто невозможно.
</p>
<p>
Итак,  вообще говоря,  унарные операторы  можно задавать  либо  в виде
член-функции без аргументов, либо в виде дружественной функции с одним
аргументом.  Бинарные операторы  задаются либо  в виде  член-функции с
одним  аргументом,   либо  в   виде  дружественной  функции   с  двумя
аргументами.
</p>
<p>
Теперь о том, какие операторы можно, а какие - нельза перегружать.
Запрещено перегружать всего 4 оператора:
<br><br>
<table align="center">
  <tr><td width="20%" align="center">::</td>
      <td>разрешение области видимости</td>
  </tr>
  <tr><td width="20%" align="center">.</td>
      <td>выбор члена</td>
  </tr>
  <tr><td width="20%" align="center">.*</td>
      <td>выбор члена через указатель на член</td>
  </tr>
  <tr><td width="20%" align="center">?:</td>
      <td>троичный оператор</td>
  </tr>
</table>
<br>
Все остальные операторы перегружать можно. Приведу их для справки:
<br><br>
<table width=70% align="center">
  <tr>
     <td>+</td><td>-</td><td>*</td><td>/</td><td>%</td><td>^</td><td>&</td>
  </tr>
  <tr>
     <td>|</td><td>~</td><td>!</td><td>=</td>
     <td>&lt;</td><td>&gt;</td><td>+=</td>
  </tr>
  <tr>
     <td>-=</td><td>*=</td><td>/=</td><td>%=</td>
     <td>^=</td><td>&=</td><td>|=</td>
  </tr>
  <tr>
     <td>&lt;&lt;</td><td>&gt;&gt;</td><td>&gt;&gt;=</td><td>&lt;&lt;=</td>
     <td>==</td><td>!=</td><td>&lt;=</td>
  </tr>
  <tr>
     <td>&gt;=</td><td>&&</td><td>||</td><td>++</td>
     <td>--</td><td>-&gt;*</td><td>,</td>
  </tr>
  <tr>
     <td>-&gt;</td><td>[]</td><td>()</td><td>new</td>
     <td>new[]</td><td>delete</td><td>delete[]</td>
  </tr>
</table>
<br>
Заметьте -  в этом  списке некоторые знаки  операций, например *  и &,
соответствуют как унарным, так и бинарным операторам. Перегружать можно
и те, и другие.
</p><p>
Для перегрузки всех этих операторов используются функции вида
<div class="code">
        Type operator op()
</div>
где Type - тип возвращаемого значения, operator - ключевое слово, а op
- тот   оператор,  который   требуется   перегрузить.  Например,   для
перегрузки оператора - надо написать функцию
<div class="code">
           Type operator-();
</div>
и так далее.
</p>
<p>
В дополнение  к этому можно также  определять операторы преобразования
типа. Их имя  также начинается с ключевого слова  operator, за которым
следует тип, к которому данная функция приводит объект:
</p>
<div class="code">
        operator Type()
</div>
Например, в таком классе
<div class="code">
        class A {<br>
        &nbsp;&nbsp;...<br>
        &nbsp;&nbsp;operator int();<br>
        };<br>
</div>
функция-член   "operator  int"   приводит   обекты  типа   A  к   типу
int. Обратите внимание - у  операторов приведения типа не задается тип
возвращаемого  значения   функции,  поскольку  он   уже  указан  после
ключевого слова operator.
</p>
<p>
Я рассказал общие  принципы
перегрузки  операторов,  на   следующем  занятии  будем
смотреть,  как  перегружаются  те  или  иные операторы и  какие  у  них
особенности.
</p>
         </td>
    </tr>
   </table>


</div>
</body>
</html>
