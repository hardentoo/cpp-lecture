<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 3</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 3</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Основы языка (2)
	<ul>
          <li><a href="p1-3.html#c_io">Ввод-вывод, С-стиль</a>
          <li><a href="p1-3.html#ifgoto">Операторы <em>if</em> и <em>goto</em></a>
          <li><a href="p1-3.html#boolops">Логические операторы. Операторы отношения.</a>
          <li><a href="p1-3.html#commaternary">Оператор запятая. Троичный оператор.</a>
          <li><a href="p1-3.html#types">Типы данных. Приведение типов.</a>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="c_io"></a>Основы языка (2)</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	 <h2>Ввод-вывод, С-стиль</h2>
<p>


На прошлом занятии мы  с вами познакомились с оператором присваивания,
арифметическими операторами, инкрементом ++ и декрементом --, битовыми
операциями, а  также узнали про оператор  sizeof(), позволяющий узнать
размер переменной или типа данных. 

</p><p>

Сейчас,  не  вдаваясь в объяснения, я хочу  буквально  несколько  слов
сказать о вводе-выводе в С.

</p><p>

Я  уже  говорил,  что  ввод-вывод  в С  делается  при  помощи  функций
библиотеки.  Одну  такую функцию  - <em>printf()</em>, 
печатающую  значения, вы
уже видели.  Ее первым аргументом  всегда стоит текстовая строка - она
называется форматной  строкой.  Функция  печатает эту строку,  но если
видит  в ней управляющие  последовательности -  специальные комбинации
символов, начинающиеся  с процента, то  вместо них вставляет  в строку
значения  следующих  своих аргументов.   В  каком  виде  - зависит  от
использованной комбинации.  Так,  например, <em>%d</em> напечатает целое число,
<em>%s</em> - текстовую  строку, </em>%g</em> - вещественное 
число, и  так далее. Вот как это выглядит в программе:

<div class="code">
	#include &lt;stdio.h><br>
	int main() {<br>
	&nbsp;&nbsp;/* Печатаем целое число и строку */<br>
	&nbsp;&nbsp;printf("integer=%d, string=%s \n", 10, "hello");<br>
        }<br>
</div>

Два замечания по поводу приведенной выше программы:

<ol>
  <li> Файл  заголовков  &lt;stdio.h>,  включенный  в  программу,  содержит
объявления функций С-ввода-вывода
  <li> В конце  строки-первого аргумента функции printf()  стоит \n. Это
не  два символа,  а специальное  обозначение для  управляющего символа
"перевод строки" (linefeed).
</ol>

Аналогичная  функция для ввода  значений называется  <em>scanf()</em>. Устроена
она  по тому  же принципу.  Первым аргументом  всегда  стоит форматная
строка (в данном случае она, конечно, не печатается). В зависимости от
того,  какие  в  ней  стоят  управляющие  последовательности,  функция
заносит  вводимые значения  в переменные,  используемые  в последующих
аргументах. Вот так:

<div class="code">
	#include &lt;stdio.h><br>
	int main() {<br>
	&nbsp;&nbsp;int i;<br>
	&nbsp;&nbsp;char c;<br>
	&nbsp;&nbsp;/* Вводим целое число и символ */<br>
	&nbsp;&nbsp;scanf("%d %c", &i, &c);<br>
        }
</div>

Обратите  внимание -  перед переменными  стоит значок  &. Почему  - вы
поймете  позже,  когда  я   буду  говорить  про  особенности  передачи
параметров  функциям  в языке  С.  Пока  можете  воспринимать это  как
заклинание.

</p><p>

Разумеется, возможности  форматных строк  не исчерпываются тем,  что я
вам показал. Да  и функций ввода-вывода в библиотеке  С больше, чем 2.
Краткий  их   обзор  есть  в  девятом  занятии,   и,  разумеется,  они
рассматриваются  в любой книге  по С.  Но пока  мы с  вами ограничимся
малым.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="ifgoto"></a>Операторы <em>if</em> и <em>goto</em></h2>
<p>

На  очереди у  нас  - логические  операторы.  Но поскольку  логические
выражения   чаще   всего   используются  в   конструкциях   управления
выполнением - условных операторах  и циклах (это те операторы, которые
statements),  то начнем  мы занятие  со  знакомства с  одним из  таких
операторов-statements - оператором условного выполнения <em>if</em>.

</p><p>

Выглядит он так

<div class="incode">
	 if (логическое_значение)<br>
	 &nbsp;&nbsp;оператор;<br>
</div>

или так

<div class="incode">
	 if (логическое_значение)<br>
	 &nbsp;&nbsp;оператор;<br>
	 else<br>
	 &nbsp;&nbsp;оператор;<br>
</div>

Разумеется, вы можете использовать в этой конструкции блоки вместо
одиночных операторов:

<div class="incode">
	 if (логическое_значение) {<br>
	 &nbsp;&nbsp;оператор;<br>
	 &nbsp;&nbsp;оператор;<br>
	 }<br>
</div>

или

<div class="incode">
	 if (логическое_значение) {<br>
	 &nbsp;&nbsp;оператор;<br>
	 &nbsp;&nbsp;оператор;<br>
	 }<br>
	 else {<br>
	 &nbsp;&nbsp;оператор;<br>
	 &nbsp;&nbsp;оператор;<br>
         }<br>
</div>
	 
Давайте разбираться, как этот  оператор работает. Начнем со стоящего в
круглых скобках логического  значения. Я как то уже  упоминал, что в С
за <em>FALSE</em>  считается нулевое значение,  а все ненулевое 
-  <em>TRUE</em>. Причем
настоящее значение <em>TRUE</em>  - это единица, хотя и  любое другое ненулевое
значение сработает  так же  хорошо.  "Настоящее" -  в том  смысле, что
логическиая функция или логический оператор в качестве <em>TRUE</em> вернут вам
не 2, не  3, а именно 1. Естественно, в  круглые скобки нечасто ставят
просто  константы 0  или 1,  хотя и  такое случается.  Чаще  всего там
оказывается   какое-то   выражение,    или   переменная,   или   вызов
функции. Например (x-y) даст вам <em>FALSE</em> (0), если x равно y, 
и <em>TRUE</em> при x не равном y.

</p><p>

Теперь  о самом  операторе  <em>if()</em>.  Его  называют оператором  условного
выполнения, и  работает он так:  - если логическое значение  в круглых
скобках равно  <em>TRUE</em>, то выполняется оператор (или  блок), следующий за
круглыми скобками.  Если же значение в  круглых скобках -  0, то есть,
<em>FALSE</em>, то  выполняется оператор  или блок, 
следующий  за <em>else</em>,  а если
<em>else</em>-части в операторе <em>if</em> нет,  
то ничего не выполняется.  Чтобы стало
понятнее, давайте посмотрим на примерах. Конструкция:

<div class="incode">
        if (1)<br>
	&nbsp;&nbsp;printf("условие выполнено\n");<br>
	else<br>
	&nbsp;&nbsp;printf("условие не выполнено\n");<br>
</div>

напечатает нам сообщение

<div class="session">
	"условие выполнено"
</div>

Если же мы напишем

<div class="incode">
        if (0)<br>
	&nbsp;&nbsp;printf("условие выполнено\n");<br>
	else<br>
	&nbsp;&nbsp;printf("условие не выполнено\n");<br>
</div>

то получим

<div class="session">
	"условие не выполнено"
</div>

Если же мы еще и уберем из оператора else-часть, вот так:

<div class="incode">
        if (0)<br>
	&nbsp;&nbsp;printf("условие выполнено\n");<br>
</div>

то просто не увидим никаких сообщений. Не очень сложно, правда?

</p><p>

Попутно я еще  хочу вам рассказать и про оператор <em>goto</em>  - этот тоже из
породы statements.

</p><p>

Прежде,  чем  показать,  как  этот  оператор выглядит  в  программе  и
работает, вылью на него немножко  грязи. Дело в том, что теоретиков от
программирования тошнит при упоминании об операторе <em>goto</em>. 
Он, дескать,
и  структуру программы  ломает, и  программы нечитабельными  делает. А
самые  главные   слова  звучат  примерно  так:  -   "раз  в  программе
понадобился оператор  <em>goto</em>, значит она  неправильно 
спроектирована". И особенно    его    не    любят   
ценители    объектно-ориентированного
подхода. Например, в языке <em>JAVA</em> (у которого, 
кстати, с С++ очень много
общего) такого  оператора нет.  Причем  один из авторов  <em>JAVA</em> 
открытым
текстом пишет, что они специально  не включили в язык этот "кошмарный"
оператор. Так что  этот оператор лучше использовать пореже  - без него
вам легче  будет научиться  писать "красивые" программы.  А "красивые"
программы обычно и работают лучше "некрасивых".

</p><p>

Ну   вот,    грязью   полил,   но   все-таки    собираюсь   про   него
рассказывать. Зачем? Может, его вообще пропустить?

</p><p>

Ну, у  меня целых  две причины  о нем рассказать.  И еще  одна причина
рассказать именно сейчас. Итак:

</p><p>

Во первых, он есть в языке С, есть и в С++. И, несмотря на всю теорию,
встречается в  программах на  С/С++. Надо же  вам хоть  немножко уметь
читать чужие программы.

</p><p>

Во вторых,  теоретики от программирования, разумеется,  правы. Но, как
любит приговаривать один мой знакомый: - "жизнь богаче, чем мы ее себе
представляем".   Я,  например,  не   раз  сталкивался  на  практике  с
ситуацией, когда  исправить ошибку в логике программы  можно было либо
путем изрядных переделок, либо с помощью этого "крамольного" оператора
goto. И должен признаться -  не всегда выбирал первый путь. Думаю, что
и у вас такие ситуации будут возникать.

</p><p>

Теперь скажу, почему о нем  речь зашла именно сейчас. Честно говоря, я
просто не  знал, когда  именно про него  стоит рассказывать.   А потом
подумал, что  сейчас как  раз удобный  для этого случай  - вы  пока не
знаете,  как  писать  циклы на  С,  а  <em>if()</em>  вкупе с  
оператором  <em>goto</em>
позволяют (пусть и не таким элегантным способом, как с помощью циклов)
добиться такой же функциональности.

</p><p>

Все это было "лирическое отступление".  А сам оператор очень простой -
вы  ставите  в нужном  месте программы  метку  - идентификатор,
созданный по  тем же  правилам, что и,  скажем, имя  переменной. После
метки ставите  двоеточие. А  в другом месте  программы ставите  <em>goto</em> 
с именем метки, и  по этому оператору управление передается  на ту точку
программы, где эта метка стоит. Ну, например, так:

<div class="incode">
		&nbsp;&nbsp;...<br>
		&nbsp;&nbsp;/*<br>
		&nbsp;&nbsp;&nbsp;&nbsp;Не хотим выполнять операторы отсюда <br>
		&nbsp;&nbsp;&nbsp;&nbsp;и до метки SKIP<br>
	        &nbsp;&nbsp;*/<br>
<br>
		&nbsp;&nbsp;goto SKIP;<br>
<br>
		&nbsp;&nbsp;x = f(y);<br>
		&nbsp;&nbsp;printf("%d\n",x);<br>
<br>
	SKIP:   /* После goto управление перейдет сюда */<br>
<br>
		&nbsp;&nbsp;x++;<br>
		&nbsp;&nbsp;...<br>
		
</div>

Естественно, с тем же успехом управление можно передавать не "вперед",
а "назад", например, добиваясь повторного выполнения операторов.

<div class="incode">
	LOOP:		/* это у нас метка */<br>
	&nbsp;&nbsp;/* Здесь у нас какие-нибудь операторы */<br>
	&nbsp;&nbsp;i++;<br>
	&nbsp;&nbsp;x -=y<br>
<br>
	&nbsp;&nbsp;/* <br>
	&nbsp;&nbsp;&nbsp;&nbsp;А теперь мы хотим повторить операции,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;которые выполняются после метки LOOP<br>
	&nbsp;&nbsp;*/<br>
<br>
	&nbsp;&nbsp;goto LOOP;<br>
</div>

Если вы поняли,  как работает оператор <em>goto</em>, то  должны были заметить,
что второй пример - реализация бесконечного цикла. Программа, дойдя до
такого  места,  будет  выполнять   операторы  между  <em>LOOP</em>  
и  <em>goto</em>  до
бесконечности, точнее, пока  вы не снимете задачу с  выполнения или не
выключите компьютер.

</p><p>

В комбинации же с <em>if()</em> оператор <em>goto</em> 
позволяет организовывать и циклы
с выходом по какому-то условию. Например

<div class="incode">
	&nbsp;&nbsp;...<br>
	LOOP:<br>
	&nbsp;&nbsp;/* Получаем каким-то образом новое значение x */<br>
	&nbsp;&nbsp;x = get_new_x();<br>
<br>
	&nbsp;&nbsp;/* Хотим добиться, чтобы x был равен y */<br>
<br>
	&nbsp;&nbsp;if (x-y) goto LOOP;<br>
	&nbsp;&nbsp;...<br>
</div>

Здесь  подразумевается,  что  программисту  зачем то  нужно  считывать
значения x до тех пор, пока  очередное не совпадет со значением y. При
этом выражение в круглых скобках  оператора if даст 0, то есть, FALSE,
а  значит, оператор  goto не  выполнится, и  выполенние  этого "цикла"
прервется.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="boolops"></a>Логические операторы. 
	                           Операторы отношения.</h2>
<p>

Ну вот,  а теперь  давайте по традиции  напишем тестовую  программку и
перейдем к  знакомству с логическими  операторами. Кстати, вы  по моим
понятиям   уже   и  сами   в   состоянии   писать  подобные   тестовые
программки. Так  что, пожалуй,  я все  реже буду их  писать, и  уж тем
более дословно  пояснять, что  мы меняем, и  что эти  программки после
этого нам печатают. И все чаще буду просто приводить только те строчки
кода, которые иллюстрируют изучаемую  возможность - в надежде, что при
необходимости  вы сможете  дописать  вокруг них  программу и  испытать
их. К  тому же у  вас появится лишний  стимул не просто слушать  что я
рассказываю, но и  по возможности практиковаться на досуге.  Но если у
вас  из-за  этого  будут  возникать проблемы  -  говорите,  постараюсь
помочь.

<div class="code">
     /* testbool.c - знакомство с логическими операторами */<br>
     #include &lt;stdio.h><br>
<br>
     int op1, op2;<br>
<br>
     int main() <br>
     {<br>
<br>
     &nbsp;&nbsp;/* <br>
     &nbsp;&nbsp;&nbsp;&nbsp;В круглые скобки мы вместо 1 будем подставлять разные<br>
     &nbsp;&nbsp;&nbsp;&nbsp;выражения<br>
     &nbsp;&nbsp;*/<br>
     &nbsp;&nbsp;if (1)<br>
     &nbsp;&nbsp;&nbsp;&nbsp;printf("условие выполнено\n");<br>
     &nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;printf("условие не выполнено\n");<br>
<br>
     &nbsp;&nbsp;return 0;<br>
     }<br>
</div>

И, наконец, мы можем во всеоружии перейти к логическим операторам.

</p><p>

Начну я с единственного унарного оператора этой группы (не забыли еще?
унарный  -  значит,  работающий  с  одним операндом)  -  оператора  !,
восклицательный знак, не путайте со "столбиком" | битового ИЛИ.

</p><p>

Этот оператор выполняет  логическую операцию НЕ. логическое отрицание.
Применительно к понятиям  языка С о FALSE и TRUE  это означает, что он
сделает из  нуля единичку,  а из единички,  да и из  любого ненулевого
значения - ноль. То есть, !1 даст 0, как и, к примеру, !4. А !0 вернет
единичку.  Если заменить в  тестовой программке  if(1) на  if(!1), она
напечатает сообщение

<div class="session">
	условие не выполнено
</div>

то есть, оператор if() расценит !1 как FALSE.

</p><p>

Повторю, чтобы вы  получше запомнили - в С  "правильным" значением для
TRUE считается  единица, хотя  любое ненулевое тоже  расценивается как
TRUE.   "Правильным"  в  том  смысле, что  именно  единицу  возвращают
логические  операторы. Это  относится и  к  оператору !,  и такое  его
свойство  иногда (в  основном в  программах-головоломках) используется
для "нормализации" значения. Я имею в виду примерно такую конструкцию:

<div class="code">
	int i, j;<br>
	...<br>
	j= !!i;   /* Внимание - два восклицательных знака */<br>
</div>

Такой  сдвоенный  восклицательный  знак  из  любого  ненулевого  числа
сделает 1, а нуль так и останется нулем.

</p><p>

Вот, собственно и все, что можно сказать об этом операторе.

</p><p>

Теперь  посмотрим  на   те  логические  операторы,  которые  позволяют
сравнивать переменные и  значения. Эту подгруппу логических операторов
еще  называют  операторами отношения,  поскольку  они показывают,  как
соотносятся между собой значения операндов.

</p><p>

Все  операторы  этой  подгруппы   -  бинарные.  Это,  впрочем,  вполне
естественно - чтобы сравнивать что-то  с чем-то другим, надо иметь два
"изучаемых объекта".  Часть этих операторов выглядит  вполне понятно и
обычно ни у кого не вызывает затруднений. Например, ясно, что строка

<div class="incode">
	if (i&lt;j)
</div>

проверяет, условие "i меньше j".   И действительно, если мы в тестовой
программе напишем, например,

<div class="incode">
	op1 = 2;<br>
<br>
	if ( op1&lt; 100 )<br>
<br>
	... <br>
</div>

увидим сообщение 

<div class="session">
	условие выполнено
</div>

Я просто перечислю такие "понятные" операторы отношения:

<div align="center">
  <table>
    <tr><td></td><td>&nbsp;&nbsp;</td><td></td></tr>
    <tr>
      <td align="center">i &lt; j</td>
      <td></td> 
      <td>1, если первое значение меньше второго</td>
    </tr>
    <tr>
      <td align="center">i &lt;= j</td>
      <td></td>
      <td>1, если первое значение меньше или равно второму</td>
    </tr>
    <tr>
      <td align="center">i > j</td>
      <td></td>
      <td>1, если первое значение больше второго</td>
    </tr>
    <tr>
      <td align="center">i >= j</td>
      <td></td>
      <td>1, если первое значение больше или равно второму</td>
    </tr>
  </table>
<br>
</div>

Оператор, который проверяет условие "не равно", выглядит так

<div class="incode">
	if (i != j)
</div>

и  обычно  тоже не  вызывает  особых  трудностей,  если только  вы  не
привыкли к другой записи, работая, скажем, на Паскале.

</p><p>

Больше всего проблем и неприятных  ошибок выпадает на долю проверки на
равенство. Выглядит эта проверка так

<div class="incode">
	if (i == 100)
</div>

Обратите  внимание -  знак равенства  сдвоенный. А  так  легко сделать
опечатку:

<div class="incode">
	if (i=100)
</div>

При этом  конструкция с точки  зрения С совершенно легальная.  И часто
подобная конструкция  используется с умыслом. Вот  только не проверяет
она,   равно   ли   значение    i   ста,   а   делает   нечто   совсем
другое.  (Попробуйте вспомнить, что  я говорил  раньше и  прямо сейчас
сказать, что именно она делает.)

</p><p>

Подобные  опечатки-ошибки с  оператором  == -  вешь  частая и  нередко
трудноуловимая.   Программа   работает.   Правда,   как   то   странно
работает. Или, что еще хуже, обычно работает правильно, а изредка - не
так,  как вы  ожидаете. Трансляторы  умеют  выдавать предупредительное
сообщение  о  такой  "потенциальной"  ошибке.  Правда,  это  сообщение
частенько по  умолчанию выключено,  и вам нужно  указывать специальный
ключ транслятору, чтобы его увидеть.

</p><p>

Так что  я призываю  вас - крепко-накрепко  запомните - в  проверке на
равенство стоят  два знака равно.  А если вы сознательно  ставите один
знак равно и понимаете, что делаете, то напишите чуть подлиннее:

<div class="incode">
	if ( (i=100) != 0 ) 
</div>

тогда  тем,  кто  станет  программу  читать, будут  вполне  ясны  ваши
намерения.

</p><p>

Итак, у нас уже есть семь логических операторов - унарный !  (операция
НЕ)  и  операторы  отношения.   Но этого  маловато.   Нередко  хочется
выразить в  терминах языка  программирования что-нибудь вроде  "если i
равно j,  или j не равно  k, и при этом  k меньше 100".  Вот тут-то на
помощь и приходят оставшиеся логические операторы. Их всего два 
- && и ||. Думаю, вы уже догадались, что они 
означают, ведь они так похожи на
своих     собратьев    из     битовой     логики,    только     значки
сдвоенные. Действительно, бинарный оператор && означает 
операцию "И" -
но не  с битами, а с  логическими значениями. А  || 
выполняет операцию ИЛИ.

</p><p>

И  теперь  мы  вполне  можем  записать только  что  названное  сложное
выражение, да еще и не одним способом.

<div class="incode">
	if ( i==j || ( j!=k && k&lt;100 ) ) <br>
	if ( i==j || !( j==k || k>=100) )<br>
</div>

Дополнительные круглые  скобки в подобных  выражениях, как и  в случае
арифметических операций, помогают  "бороться" с приоритетами, то есть,
менять  порядок выполнения  операций.  Между прочим,  если  у вас  еть
сомнения  в том,  в какой  последовательности сработают  операторы, не
стоит  тратить  время  и   лезть  в  справочник.  Просто  поставьте  в
подозрительных для вас местах круглые скобки, например, так

<div class="incode">
	if ( (i==j) || ( (j!=k) && (k&lt;100) ) )
</div>

Читается  такое  похуже  -  приходится  скобочки считать,  но  вас  за
подобную перестраховку никто не осудит.

</p><p>

Ну вот, теперь все логические операторы названы. Но есть еще кое-какие
факты, которые вам полезно знать.

<ul>
  <li> Факт первый.
  Все  логические   операторы,  кроме  унарного   !,  выполняются  слева
  направо.    Или,   если   говорить    на   языке    программистов,   !
  правоассоциативен, а все остальные - левоассоциативны. Проще всего
  пояснить это на примерах. Выражение 

<div class="incode">
	 !!i
</div>


будет вычисляться справа налево, так же, как

<div class="incode">
      !(!i)
</div>

то  есть,  сначала выполнится  "ближайший"  к  переменной  !, а  потом
"внешний".

</p><p>

А вот выражения

<div class="incode">
      1 &lt; j &lt; 100<br>
<br>
      i && j && k<br>
</div>

будут обрабатываться слева направо:

<div class="incode">
      (1 &lt; j) &lt; 100<br>
<br>
      ( i && j ) && k<br>
</div>
<br><br>

<li> Факт второй.
Этот факт логически вытекает из  того, что в С нет понятия "логический
тип"  -   для  этой  цели  используются   целочисленные  переменные  и
значения. Но я его все-таки озвучу.

</p><p>

Ничто не  запрещает вам использовать  результаты логических вычислений
как обычные целые числа.  Вы можете вернуть такой логический результат
из целой функции, например, из <em>main()</em>:

<div class="incode">
	  int main() {<br>
	  &nbsp;&nbsp;...<br>
	  &nbsp;&nbsp;return i&lt;100;<br>
	  }<br>
</div>

Можете держать логический результат в целой переменной.

<div class="incode">
       int i, j;<br>
       int a, b;<br>
       ...<br>
<br>
       /* То же, что и if ( (a&lt;100) && (b==2)) */<br>
       i = (a&lt;100)<br>
       j = (b==2)<br>
       if (i && j) <br>
       &nbsp;&nbsp;return 0; <br>
</div>

И  с  таким   же  успехом  вы  можете  смешивать   в  одном  выражении
арифметические и логические операторы (как, впрочем, и многие другие):

<div class="incode">
	       int i,j;<br>
	       ...<br>
	       i = 21 - (j!=1);<br>
</div>

Все  это  абсолютно законно  -  лишь бы  вы  понимали,  что именно  вы
делаете.
<br><br>       	     
 
<li> Факт третий.
Если в выражении есть операторы &&  и ||, часть операторов в нем может
не выполниться.  Точнее, их  выполнится ровно столько,  сколько нужно,
чтобы  узнать  результат всего  выражения.  Наверное,  снова не  очень
понятно?   Объясню  поподробнее.  Давайте   посмотрим  вот   на  такие
логические выражения:

<div class="incode">
	   ( (i!=0)  && (j!=1) )<br>
	   ( (i!=0) || (j!=1) )<br>
</div>

В  первом выражении,  если i  равно нулю,  то есть  первое  условие не
выполняется, то  совершенно не  важно, равно ли  j единице или  нет. В
любом случае результат всего выражения будет равен нулю. Точно так же,
если во втором выражении i не равно нулю, нет смысла считать дальше -
в результате все равно получим единицу.

</p><p>

Этот третий факт, на мой взгляд, очень важно знать по двум причинам.

</p><p>

Во-первых, поглядите на вот такое выражение:

<div class="incode">
	   ( (i!=0) && (--j!=1) ) 
</div>

В зависимости  от того, выполняется ли первое  условие, второе условие
может быть проигнорировано при  работе задачи, а значит, не выполнится
стоящий в нем оператор декремента. И сколько времени вы бы искали
подобную ошибку, не зная этой особенности?

</p><p>

Во-вторых, в языке С, да и в других языках, которые поступают подобным
образом  с логическими операторами,  частенько можно  встретить запись
примерно в таком стиле:

<div class="incode">
	 process_data() || print_error();
</div>

или

<div class="incode">
	return read_data() && process_data() && write_data();
</div>

Теперь мы хоть можем понять, что они означают. 

</p><p>

Первый пример  - вызывается функция  обработки данных, и только  в том
случае, если она вернула 0  (что, видимо, означает какие-то ошибки при
обработке), вызывается функция, печатающая сообщение об ошибке.

</p><p>

Второй  пример  -  функции,  ответственные за  разные  фазы  обработки
данных,  вызываются   по  очереди.  Если   любая  из  них   вернула  0
(сигнализируя таким  образом об  ошибке) последующие функции  не будут
выполняться. При этом оператор  return вернет значение 1 (означающее в
данном случае успех) только в  том случае, когда успешно сработают все
три функции в логическом выражении.
</ul>

Ну вот, пожалуй теперь о логических операторах сказано достаточно.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="commaternary"></a>
	    Оператор запятая. Троичный оператор.</h2>
<p>


Теперь я собираюсь рассказать о
двух  несложных,   но  не  совсем  обычных  операторах   -  запятой  и
троичном. Потом расскажу  вам  о некоторых  типах
данных. Ну, а  коль скоро речь зайдет о разных  типах, то нам придется
познакомиться  и с тем,  как один  тип преобразовывать  в другой  - то
есть, с оператором приведения типа.


</p><p>

Итак, первый из  не совсем обычных операторов -  оператор , (запятая).
Это бинарный оператор, то есть, ему нужны два операнда. Обрабатываются
операнды слева  направо. Результат работы -  второй операнд. Например,
если вы напишете

<div class="incode">
	i = (1,2);
</div>

то в переменной i окажется значение 2. Разумеется, можно поставить  в
выражение и несколько таких операторов. Так, строка

<div class="incode">
	i = ( 1, 3, -4 );
</div>

зашлет в i значение -4. Обратите внимание на круглые скобки - они, как
обычно, помогают  бороться с приоритетами операций, и  в данном случае
они  совершенно необходимы.  Если вы  попытаетесь  написать, например,
так:

<div class="incode">
	i = 1, 3, -4 ;
</div>

то с удивлением обнаружите, что переменная i стала равна единице, а не
-4.  А все дело в том,  что у оператора присваивания приоритет повыше,
так что написать последнюю строку все равно, что написать

<div class="incode">
    result =( (i=1), 3, 4 );
</div>

а потом забыть про result и использовать значение i. 

</p><p>

Зачем  понадобился  такой необычный  оператор?  Прежде  всего, есть  в
программах  на  С  такие  места,  куда  можно  поставить  только  одно
выражение,  а надо  ставить несколько.  Вот  в таких  случаях и  пишут
что-нибудь в таком духе:

<div class="incode">
      f(( (i=1), (j=2), i*j ) ));
</div>

То,  что вы видите  - вызов  функции с  одним аргументом.   В конечном
итоге, в  качестве аргумента функция  получит i*j. И правила  языка не
нарушены,  и несколько выражений  стоит.  Эта  же строка  показывает и
второе полезное применение этого оператора - мы прямо в вызове функции
присвоили  новые значения  переменным  i  и j,  и  только после  этого
сосчитали значение аргумента i*j; То есть, с помощью оператора запятая
можно   гарантировать,   что   обработаются   все   операнды,   причем
обработаются они  последовательно -  слева направо.  Еще  один пример,
чтобы вам этот оператор получше запомнился. В строке программы

<div class="incode">
    f(), g(), h();
</div>

последовательно будут вызваны все три функции f(), g(), h();

</p><p>

Второй   "хитрый"  оператор,   о  котором   я  хочу   рассказать,  это
единственный  в  С троичный  (ternary)  оператор,  то есть,  оператор,
работающий  сразу   с  тремя  операндами.  Его   еще  иногда  называют
"арифметический if",  и вы сейчас  поймете, почему. Посмотрите  вот на
такой фрагмент программы:

<div class="incode">
      int i, j, result;<br>
      ...<br>
      if (i&lt;j)<br>
      &nbsp;&nbsp;result = i;<br>
      else<br>
      &nbsp;&nbsp;result = j;<br>
</div>
 
Здесь условный оператор if() засылает в result минимальное из значений
переменных i, j. Если у  вас есть опыт программирования, то вы знаете,
насколько часто в программах  (на любом языке) возникает потребность в
подобных конструкциях. Если нет - поверьте на слово.

</p><p>

А  что, собственно,  мы тут  имеем?  Две переменных  (i и  j) и  некое
логичесое выражение  (это выражение может  быть и не связано  с нашими
переменными).  То  есть,  всего  три  каких-то величины.  Вот  в  С  и
придумали, чтобы покороче  записывать подобные конструкции, оператор с
тремя операндами.  Выглядит он так (я  записываю то же, что  и выше, с
его помощью):

<div class="incode">
	  result =  i&lt;j ? i : j;
</div>

Не знаю, кому как, но мне он в свое время легко запомнился - мы как бы
задаем вопрос  "i меньше j?" -  это первый операнд.  Если меньше (если
условие выполнено) - берем  в качестве результата второй операнд, тот,
который  стоит сразу  за  вопросительным знаком.  Если  же условие  не
выполнено, берем  третий операнд,  стоящий после двоеточия.  Чтобы это
получше  усвоилось,  попробуйте прямо  сейчас  рассказать, что  делают
следующие операторы:

<div class="incode">
	  result = i&lt;0 ? -i : i;<br>
<br>
	  return  read_data() ? process_data() : 0;<br>
</div>



</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="types"></a>
	   Типы данных. Приведение типов.</h2>
<p>

Теперь  давайте немного  поговорим о  типах данных  - после  этого нам
будет проще и интереснее разбираться с функциями.

</p><p>

Хотя до  сих пор мы  в примерах успешно обходились  одним единственным
типом  int,  ясно,  что   в  жизни  этого  недостаточно.  При  решении
математических задач  вам в большинстве случаев  потребуются не только
целые, но и вещественные  числа. Чтобы напечатать какой-то текст, надо
уметь работать с символами. И так далее.

</p><p>

Поэтому помимо  int в С есть  и другие встроенные типы  данных, и есть
возможность строить на их основе типы, определяемые пользователем.  Вы
удивитесь,  когда  узнаете,  насколько   мало  в  таком  мощном  языке
встроенных типов. Давайте я просто назову вам их все:

<div align="center">
  <table>
    <tr><td></td><td>&nbsp;&nbsp;</td><td></td></tr>
    <tr><td>void</td><td></td><td>означает отсутствие значения</td></tr>
    <tr><td>char</td><td></td><td>символьный</td></tr>
    <tr><td>int</td><td></td><td>целочисленный</td></tr>
    <tr><td>float</td><td></td><td>с плавающей точкой</td></tr>
    <tr><td>double</td><td></td><td>тоже с плавающей точкой</td></tr>
    <tr></tr>
    <tr><td></td><td></td><td>указатели (pointers)</td></tr>
    <tr><td></td><td></td><td>массивы (arrays)</td></tr>
    <tr><td></td><td></td><td>перечисления (enumerations)</td></tr>
    <tr><td></td><td></td><td>объединения, или союзы (unions)</td></tr>
    <tr><td></td><td></td><td>структуры (structures)</td></tr>
    <tr><td></td><td></td><td>битовые поля (bit fields)</td></tr>
  </table>
  <br>
</div>

Сегодня мы будем говорить только  о тех, которые в первых пяти строках
- это  в  каком то  смысле  "самые базовые"  типы  -  их еще  называют
простыми.  Остальные типы  -  те, для  которых  я не  привел имен,  на
простые  в том или  ином смысле  опираются (это  не означает,  что они
менее важны, просто  если речь идет об указателе,  то это указатель на
какой-то  другой  тип,   массив,  соответственно  -  набор  однотипных
переменных, и так далее).

</p><p>

Ну,  зачем  нужен  <em>void</em>  -  тип, который  не  может  хранить  никакого
значения, мы поговорим чуть попозже, уже разбираясь с функциями. А вот
что касается оставшихся четырех типов,  то они очень логично и понятно
делятся всего навсего  на две группы - на  так называемые интегральные
(integral)  типы,  рассчитанные  на  целые  значения,  и  на  числа  с
плавающей  запятой   (floating  point),  работающие   с  вещественными
числами.  И  отличаются они  размером,  который  под  них отводится  в
памяти,  а, значит, тем,  насколько большие  числа или  сколько знаков
после запятой в них можно записать.

</p><p>

Не напрягая вас особо техническими деталями, приведу несколько
примеров создания и инициализации переменных этих типов.

<div class="incode">
	int i=1, j=-10;<br>
<br>
	char null = 0, c = '1' ;<br>
<br>
	float x = 1.55, c=3.0e8; <br>
	double N = 6e23, e=2.718281828459045235;<br>
</div>

Тип  int вы  уже  видели.  Относительно char  -  обратите внимание  на
апострофы      вокруг      инициализирующего      значения      второй
переменной. Переменная null инициализируется целым числом 0, вторая же
благодаря  апострофам  -  таким  числом,  код  которого  соответствует
символу 1 (в кодировке ASCII это десятичное число 49).

</p><p>

С типом char можно вполне работать, как с целочисленным. Например, вот
стандартный  (для  кодировки  ASCII)  способ,  позволяющий  превратить
цифру-символ в цифру-число:


<div class="incode">
      int digit;<br>
      char c='1';<br>
 <br>
      digit = c - '0';  /* Теперь digit содержит 1 */<br>
</div>

Впрочем,  вы,  наверное, уже  привыкли  к  мысли,  что С  вообще  мало
ограничивает программиста  по этой  части, позволяя смешивать  в одном
выражении практически  все, что  угодно. Правда, порой,  результат для
непосвященного оказывается весьма загадочным.

</p><p>

Но,  помимо  самих  типов  данных,  существуют еще  и  так  называемые
модификаторы типа  - ключевые слова, которые будучи  перед именем типа
поставлены, что-то  меняют -  или его размер,  или поведение.  Так, мы
можем из типа int сделать тип, работающий с беззнаковыми числами. Или,
если  не знаем,  какой у  нас  тип char  по умолчанию  - знаковый  или
беззнаковый, можем его явно сделать его знаковым.

<div class="incode">
      unsigned int i;    /* i - беззнаковая */<br>
      unsigned j;        /* то же самое, int позволительно опускать */<br>
      signed char c;     /* знаковый символьный */<br>
      unsigned char c1;  /* беззнаковый символьный */<br>
</div>

Это были модификаторы, изменяющие  "поведение" типа. Но можно изменять
и его размер, а значит, емкость.  И их можно ставить совместно с теми,
которые меняют поведение.

<div class="incode">
      /* <br>
      &nbsp;&nbsp;Короткие целые, знаковые и беззнаковые.<br>
      &nbsp;&nbsp;Не обязательно короче, чем обычный int, <br>
      &nbsp;&nbsp;но уж точно короче длинных целых.<br>
      */<br>
<br>
      short int i;<br>
      unsigned short int j;<br>
<br>
      /* А это длинные целые */<br>
      long int l;<br>
      unsigned long k;<br>
</div>

Типы  с плавающей  запятой различаются  тоже размером  -  double более
"емкий"  (это касается  и порядка,  и числа  значащих цифр).  Есть еще
более  "емкий" тип  -  long double  -  в нем,  как видите  использован
модификатор.

</p><p>

И,  поскольку  с  развитием  компьютеров программистам  хочется  иметь
возможность работать  со все  большими диапазонами чисел,  в последнее
время все чаще  слышно о типе long long int.  Думаю, что и  им дело не
кончится.

</p><p>

Ну,  раз уж  речь, зашла  о разных  типах, то  хотелось бы  знать, как
правильно преобразовывать значения из  одного типа в другой. Для этого
в С есть оператор приведения типа, и пользуются им так:

<div class="incode">
	 int i = 10;<br>
	 double d;<br>
<br>
	 d = (double) i;  /* Из целого в double */<br>
<br>
	 i = (int)d;	  /* Из double в целое */<br>
 <br>
	 i=  (int)'1';    /* из символьного в целое */<br>
<br>
	 i = (int) (d+'1') /* Из выражения в целое */<br>
</div>

Как видите,  надо просто поставить перед величиной,  которую вы хотите
преобразовать (или,  как говорят, привести к другому  типу) нужный вам
тип  в  круглых скобках.   Разумеется,  во  всех  этих строчках  такое
приведение  было  бы сделано  и  неявно, его  и  не  пишут в  подобных
случаях.   Но  бывают  такие  комбинации типов,  когда  без  оператора
приведения не  обойтись. И вот  вам такой пример. Помните,  я говорил,
что  программисты не  любят  сдвигать вправо  знаковые  числа -  из-за
шуточек с расширением знакового бита? Так вот, оператор приведения как
раз и спасает, когда надо сдвинуть вправо знаковую переменную:

<div class="incode">
         int i, j;<br>
<br>
	 ...<br>
<br>
	 j= ((unsigned int)i) >> 2;<br>
</div>

Здесь мы сначала преобразовали значение переменной к беззнаковому типу
(биты от этого  не поменялись), а потом уже без  риска сдвинули его на
два бита вправо.

</p><p>


Вот  пока и  все  о типах.  И,  пожалуй, вполне  достаточно для  этого
занятия.

</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>

 