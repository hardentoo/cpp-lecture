<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 5</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 5</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Управление программой - switch  и циклы.
	  <ul>
	    <li><a href="p1-5.html#switch">switch - выбор варианта.</a>
	    <li><a href="p1-5.html#loops">Цикл - что это такое?</a>
	      <ul>
	        <li><a href="p1-5.html#while">Цикл while</a>
	        <li><a href="p1-5.html#dowhile">Цикл do-while</a>
	        <li><a href="p1-5.html#for">Цикл for</a>
	        <li><a href="p1-5.html#break">Операторы break и continue.</a>
	      </ul>
	  </ul>
        <li>Массивы.
	  <ul>
	    <li><a href="p1-5.html#create">Создание и инициализация массивов.</a>
	    <li><a href="p1-5.html#access">Доступ к элементам.</a>
	    <li><a href="p1-5.html#paramarray">Передача массивов в параметрах.</a>
	    <li><a href="p1-5.html#strings">Строки, С-стиль.</a>
	  </ul>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="switch"></a>
          Управление программой - switch  и циклы.</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	 <h2>switch - выбор варианта.</h2>
<p>

На  прошлом  занятии  я  рассказывал о  функциях.   Попутно,  обсуждая
передачу   параметров,  мы   впервые  столкнулись   с   группой  типов
"указатели" и с операторами взятия  адреса &amp; и доступа 
по указателю *.
После знакомства c указателями  я познакомил вас с "собратом" 
<em>printf()</em>
- функцией стандартной  библиотеки <em>scanf()</em>, предназначенной  для ввода
значений. В конце занятия вы  услышали, чем определения (функций, и не
только) отличаются от объявлений, и зачем те и другие нужны.

</p><p>

Это занятие мы начнем  со знакомства с новыми операторами-statements -
оператором <em>switch</em>  и с  циклами. После этого  мы займемся  
массивами и указателями.

</p><p>

Итак, оператор  <em>switch</em>. Как  я уже говорил,  о нем было  бы логичнее
рассказать вместе  с оператором <em>if</em>.  Но раз этого не  сделано, будем
наверстывать упущенное.

</p><p>

Этот  оператор несколько  похож  по  логике работы  на  <em>if</em>. Он  тоже
анализирует  выражение и,  в  зависимости от  его значения,  выполняет
разные  свои части.

</p><p>

Немного   напомню:  -  оператор   <em>if</em>  рассматривает   выражение  как
логическое  условие,  и имеет  максимум  две  ветви  выполнения -  при
выполненном и при невыполненном условии:

<div class="incode">
	    if (expression) {<br>
	    &nbsp;&nbsp;/* Выполняется, если expression не равно 0 */<br>
	    }<br>
	    else {<br>
	    &nbsp;&nbsp;/* Выполняется, если expression равно 0 */<br>
	    }<br>
</div>

Оператор <em>switch</em>  рассматривает значение выражения  не как логический
результат  TRUE  или FALSE,  а  как  "шаблон"  для выбора  подходящего
варианта  из  заданного  вами  списка.  Давайте  посмотрим,  как  этот
оператор выглядит в коде, а  затем я расскажу вам, что означают разные
его части.

<div class="incode">
	int x;<br>
	...<br>
<br>
	switch (x) {<br>
<br>
	case 4:<br>
	&nbsp;&nbsp;printf("x равно 4\n");<br>
	&nbsp;&nbsp;break;<br>
<br>
	  case 2:<br>
	  case 10:<br>
	  &nbsp;&nbsp;printf("x равно или 2, или 10");<br>
	  &nbsp;&nbsp;break;<br>
<br>
	  default:<br>
	  &nbsp;&nbsp;printf("x не равно 4, 2, 10\n");<br>
	  &nbsp;&nbsp;break;<br>
<br>
	}<br>
</div>

Итак, конструкция  начинается с ключевого  слова <em>switch</em>, 
за  которым в
круглых скобках стоит либо переменная (как в этом примере), либо вызов
функции,  либо какое-то  выражение. Затем  в фигурных  скобках следует
блок с  "телом" оператора.  В этом блоке  может стоять  сколько угодно
вариантов  выполнения.  Каждый вариант  начинается  с ключевого  слова
case, за которым после  пробела следует константа и двоеточие (немного
похоже на метку для оператора goto, да это по смыслу и есть метка).

</p><p>

После  каждого   такого  варианта  могут  (но   не  обязательно)  идти
операторы,  которые будут выполняться,  если константа  этого варианта
совпадет  с  выражением  оператора  <em>switch</em>. Например,  в  показанном
фрагменте кода  при <em>x==4</em> выполнение  начнется 
с первого  <em>printf()</em>, при
<em>х==2</em> и при <em>x==10</em> - со второго <em>printf()</em>, и так далее.

</p><p>

Специальный  вариант  выбора  <em>default</em>   
(у  нас  в  примере  он  стоит
последним, но  его можно поставить  и первым, или, скажем  в середину)
"вбирает  в  себя"  все  варианты,  не  прописанные  в  теле  <em>switch</em>
явно. Так, если в  нашем примере, при любом x, не равном  2. 4 или 10,
управление передастся  на операторы варианта <em>default</em>.  Если же вариант
<em>default</em> отсутствует,  и для  значение условия не  подходит ни  один из
вариантов, то никакие операторы  в теле <em>switch</em> выполняться не будут,
программа просто пропустит его.

</p><p>

Вы, наверное, заметили, что у  всех вариантов выбора, 
кроме <em>case&nbsp;2:</em>,
наборы  операторов заканчиваются  ключевым словом  <em>break</em> 
(у  <em>case&nbsp;2:</em>
вообще нет "своих" операторов). Дело  в том, что <em>switch</em>, выбрав один
из своих вариантов, не  заканчивает автоматически выполнение, дойдя до
следующего  варианта  - он  исполняет  все  операторы, идущие  дальше,
вплоть до конца своего блока. А ключевое слово break как раз и говорит
ему  - "хватит,  больше не  надо".  Если мы  уберем, например,  первый
<em>break</em>, то при <em>х==4</em> увидим сначала 
сообщение от первого <em>printf()</em>, затем от второго.

</p><p>

Чтобы  вы  получше осознали,  как  работает  <em>switch</em>,  я предлагаю  в
качестве  упражнения написать то  же самое,  что и  в примере  выше, с
помощью  уже известных  вам операторов  <em>if</em> и  <em>goto</em>.  
Если  вы будете
делать это за компьютером,  то можете проверять себя, сравнивая выводы
<em>switch</em> и набора операторов <em>if</em> при разных значениях x.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="loops"></a>Цикл - что это такое?</h2>
<p>

Теперь давайте  перейдем к циклам.  И сначала разберемся  с терминами.

</p><p>

Термин  цикл  (loop)  применяют  в  двух  смыслах  -  в  "общем"  и  в
"техническом".

</p><p>

Что такое цикл?  При программировании (даже если речь идет о несложных
задачах), часто  возникает потребность выполнить несколько  раз одни и
те  же действия,  но с  разными исходными  данными.  Конечно,  если вы
знаете заранее,  сколько раз  надо повторить те  или иные  операции, и
таких  повторов немного (например,  программа всегда  обрабатывает два
набора  данных),  можно   просто  написать  два  раза  соответствующие
операторы. Но  чаще оказывается,  что повторов может  быть много,  и к
тому  же нельзя  сказать заранее,  сколько именно.   Чтобы  решить эту
проблему,  программист  организует   цикл  -  многократное  повторение
какого-то участка  кода (каждый такой повтор  называют итерацией). При
этом  обычно также задается  в той  или иной  форме условие  выхода из
цикла.  Достигнуть такой  цели  можно разными  способами -  рекурсией,
операторами <em>goto</em>,  и так  далее.  Для обозначения  подобного поведения
программы и говорят о цикле в первом, "общем" смысле.

</p><p>

Но, чтобы подобное поведение в  коде было легче организовать, в языках
программирования  предусмотрены  специальные  конструкции -  циклы  во
втором, "техническом" смысле.

</p><p>

В языках С/С++ таких циклов во  втором смысле 3 - это операторы <em>while</em>,
<em>do-while</em> и  <em>for</em>.  Кроме  того, 
специально для  расширения возможностей
этих трех операторов,  в языке предусмотрены еще 2  - <em>continue</em> 
и <em>break</em>
(<em>break</em> также  применяется в  операторе <em>switch</em>, 
но  по сути он  в обоих случаях делает одно и то же). 
Итак, давайте знакомиться.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="while"></a>Цикл while</h3>
<p>

Этот цикл выглядит следующим образом:

<div class="incode">
	  while (условие)<br>
	  &nbsp;&nbsp;оператор;<br>
</div>

или

<div class="incode">
	  while (условие) {<br>
	  &nbsp;&nbsp;оператор;<br>
	  &nbsp;&nbsp;оператор;<br>
	  &nbsp;&nbsp;...;<br>
	  }<br>
</div>

Когда программа доходит до  <em>while</em>, проверяется стоящее 
в круглых скобках логическое условие и,
если  это  условие истинно,  то  есть,  значение  выражения в  круглых
скобках не равно 0, программа выполняет оператор или блок операторов в
фигурных  скобках.  Затем  управление  снова передается  на <em>while</em>  и
история  повторяется. Таким  образом оператор  или блок,  следующий за
<em>while</em> будет исполняться до тех пор,  пока условие не даст 0 (либо мы
не  прервем этот  цикл  каким-то другим  способом). Разумеется,  после
выхода  по  условию  выполнение  программы  продолжится  с  оператора,
следующего  за  циклом,  Чтобы  стало понятнее,  посмотрите  на  такой
пример:

<div class="incode">
	   int x=0;<br>
<br>
	   while (x&lt;10) {<br>
	   &nbsp;&nbsp;printf("%d\n",x);<br>
	   &nbsp;&nbsp;x++;<br>
	   }<br>
	   printf("All done");<br>
</div>

Такой цикл  выполнится 10 раз, напечатав нам  значения х от 0  до 9, и
только после  этого управление перейдет  на второй, стоящий  за циклом
<em>printf()</em>.

</p><p>

Что еще  интересного можно сказать  про этот цикл? Если  условие цикла
выполняется всегда, например

<div class="incode">
	  while (1) {<br>
	  &nbsp;&nbsp;...;<br>
	  }<br>
</div>

то мы получаем бесконечный цикл.  Это не обязательно означает ошибку в
программе,  подобное делают  и  специально, организуя  выход из  цикла
другими  способами, либо  рассчитывая,  что программа  будет  работать
"вечно".

</p><p>

Если же условие дает 0 при первом входе в цикл, например

<div class="incode">
          int x=0;<br>
	  while (x != 0) {<br>
	  &nbsp;&nbsp;...;<br>
          }<br>
</div>

то операторы в теле цикла не выполняются ни разу.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="dowhile"></a>Цикл do-while</h3>
<p>

Этот цикл записывается следующим образом:

<div class="incode">
          do<br>
	  &nbsp;&nbsp;оператор;<br>
          while (условие);<br>
</div>

или

<div class="incode">
	  do {<br>
	  &nbsp;&nbsp;оператор;<br>
	  &nbsp;&nbsp;оператор;<br>
	  &nbsp;&nbsp;...;<br>
	  } while (условие);<br>
</div>

Он очень похож по поведению  на предыдущий, но только при первом входе
в цикл сначала  выполнятся операторы в теле цикла,  и лишь потом будет
проверено условие.  Если условие окажется ложным,  выполнение цикла на
этом закончится, если истинным - операторы в теле выполнятся повторно.
Так что цикл

<div class="incode">
	   int x=0;<br>
<br>
	   do {<br>
	   &nbsp;&nbsp;printf("%d\n",x);<br>
	   &nbsp;&nbsp;x++;<br>
	   } while (x&lt;10);<br>
<br>
	   printf("All done");<br>
</div>

напечатает нам значения только от 0 до 9, а цикл

<div class="incode">
          int x=0;<br>
	  do {<br>
	  &nbsp;&nbsp;...;<br>
          } while (x!=0);<br>
</div>

выполнится один раз, прежде чем "заметит", что х равно нулю.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="for"></a>Цикл for</h3>
<p>

Это  -   наиболее  мощная  и  чаще   всего  употребляемая  циклическая
конструкция.    Но   зато   и   самая  сложная,   по   крайней   мере,
поначалу. Поэтому я начну объяснения  с реальных фрагментов кода, а уж
потом мы запишем его в общей  форме. А чтобы было еще понятнее, я буду
одновременно приводить  фрагмент с циклом <em>while</em>, 
который  делает ту же
работу. Давайте посмотрим на такой пример:

<div class="incode">
	  int x;<br>
	  for (x=0; x&lt;10; x++)<br>
	  &nbsp;&nbsp;printf("%d\n",x);<br>
<br>
	  int x;<br>
	  x=0;<br>
	  while (x&lt;10) {<br>
	  &nbsp;&nbsp;printf("%d\n",x);<br>
	  &nbsp;&nbsp;x++;<br>
	  }<br>
</div>

Итак, что мы имеем в заголовке  цикла <em>for</em> - в круглых скобках, стоящих
после ключевого  слова? Там у  нас стоят три выражения,  разделенные ;
(точками с запятой). Сначала идет <em>x=0</em>. Это - часть инициализации. Этот
оператор  выполнится  единственный раз  при  входе  в  цикл, заслав  в
переменную  x   значение  0.   За  инициализацией,   во  второй  части
заголовка,  стоит некое условие  <em>x&lt;10</em>. 
После  выполнения инициализации
это  условие будет  проверено, и,  если оно  окажется  истинным, будет
выполнен  оператор тела  цикла -  <em>printf()</em>. Разумеется,  вместо одного
<em>printf()</em> мы могли  поставить в качестве тела блок  в фигурных скобках.
После того  как отработает  тело цикла, дело  дойдет до  третьей части
заголовка (эту  часть принято называть итерацией). И  эта третья часть
выполнится,  как будто  это последний  исполняемый оператор  цикла.  В
нашем примере в качестве итерации в заголовке стоит <em>x++</em>, так что после
<em>printf()</em>  переменная x увеличится  на единицу.  На этом  первый проход
цикла закончится.

</p><p>

Перед вторым (и  последующими проходами) инициализация выполняться уже
не  будет  - программа  проверит  условие <em>x&lt;10</em>  
и,  если  оно все  еще
истинно, повторит <em>printf()</em>  и за ним часть заголовка  
с итерацией <em>x++</em>.
И так будет продолжаться до  тех пор, пока условие не окажется ложным,
в нашем  случае, пока х  не дорастет до  10. На этом  выполнение цикла
закончится. И, обращаю  ваше внимание, последнее напечатанное значение
у нас будет 9, но переменная x после цикла окажется равной 10.

</p><p>

Если же  условие в  заголовке цикла не  выполняется сразу при  входе в
цикл, например

<div class="incode">
	  int x;<br>
	  for (x=10; x&lt;10; x++)<br>
	  &nbsp;&nbsp;printf("%d\n",x);<br>
<br>
	  int x;<br>
	  x=10;<br>
	  while (x&lt;10) {<br>
	  &nbsp;&nbsp;printf("%d\n",x);<br>
	  &nbsp;&nbsp;x++;<br>
	  }<br>
</div>

то ни тело - <em>printf()</em>, ни  итерация - <em>x++</em> 
не выполнятся ни разу.

</p><p>

Вовсе необязательно писать  все три части заголовка цикла  - вы можете
опустить любую из них, или даже все, не забудьте только оставить точки
с запятыми. Вот как мог бы  выглядеть тот же цикл for с остутствующими
частями инициализации и итерации:

<div class="incode">
	  int x;<br>
<br>
	  x=0;<br>
	  for (  ; x&lt;10 ; ) {<br>
	  &nbsp;&nbsp;printf("%d\n",x);<br>
          &nbsp;&nbsp;x++;<br>
          }<br>
</div>

Как видите, <em>x=0</em>  теперь стоит перед циклом, 
а  <em>x++</em> оказалось последним
оператором его тела.

</p><p>

Если  же вы  опустите  условие выхода,  программа  будет считать,  что
условие всегда истинно, так что

<div class="incode">
	  for (;;)<br>
	  &nbsp;&nbsp;printf("hello\n");<br>
</div>

как и

<div class="incode">
          while (1)<br>
	  &nbsp;&nbsp;printf("hello\n");<br>
</div>

будет печатать строку <em>"hello"</em> до бесконечности.

</p><p>

Само собой разумеется, что условие выхода в цикле <em>for</em>, 
как, впрочем, и
в двух других, может быть и посложнее. Например, цикл

<div class="incode">
          for ( ; x&lt;10 && y!=0; )<br>
	      ...;<br>
</div>

будет выполняться до тех  пор, пока x меньше 10 и y  не равно нулю. Мы
долго говорили  про подобные условия, когда  знакомились с логическими
операторами.

</p><p>

По правилам  языка в заголовок for в качестве инициализации и итерации
можно поставить  только по  одному выражению.  А  что делать,  если мы
хотим несколько?  Например, в начале цикла заслать значения не в одну,
а  в две  переменных, а  в  итерации изменить  значения обеих?  Можно,
разумеется, сделать всю или часть этой работы и не в заголовке:

<div class="incode">
          x=0;<br>
          for (y=10; x&lt;y; x+=2 ) {<br>
          &nbsp;&nbsp;...;<br>
	  &nbsp;&nbsp;y--;<br>
          }<br>
</div>

но благодаря замечательному оператору , (запятая) мы можем поступить
проще:

<div class="incode">
          for ( x=0, y=10; x&lt;y; x+=2, y-- ) {<br>
          &nbsp;&nbsp;...;<br>
          }<br>
</div>

Теперь и  правила игры соблюдены, поскольку  каждая часть представляет
собой одно выражение, и цель достигнута.

</p><p>

Давайте  теперь запишем  цикл  <em>for</em> в  общей  форме, 
как  это делают  в
книгах. А заодно и повторим, как он работает.

<div class="incode">
	 for ( инициализация; условие; итерация )<br>
	 &nbsp;&nbsp;тело;<br>
</div>

Итак, перед входом в цикл выполняется часть заголовка <em>инициализация</em>.
Затем  проверяется <em>условие</em>,  и  если  оно ложно,  тело  цикла и  часть
заголовка <em>итерация<em> не выполняются ни разу.  
Если <em>условие</em> истинно, то
выполняется  тело цикла,  и за  ним код,  стоящий в  части <em>итерация</em>.
После  этого  снова  проверяется  <em>условие</em>,  и,  если  оно  по-прежнему
истинно, снова выполняется тело  и <em>итерация</em>. Так продолжается до тех
пор, пока условие не станет ложным.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="break"></a>Операторы break и continue.</h3>
<p>

Теперь давайте посмотрим, зачем придуманы операторы <em>break</em> 
и <em>continue</em>.

Первый  из них,  <em>break</em>,  
предназначен для  преждевременного выхода  из
цикла. Этот оператор может стоять  только в телах <em>switch</em> и циклов. И
если  программа   доходит  до  него,  то   она  немедленно  прекращает
выполнение  "тела" и  переходит  на оператор,  стоящий  за циклом  или
за <em>switch</em>. Все равно,  как если бы вы 
использовали  <em>goto</em> для перехода на
метку, чтоящую  сразу  после цикла.  Следующие примеры с  
<em>break</em> и с  <em>goto</em> делают
одну и ту же работу:

<div class="incode">
	while (1) {<br>
	&nbsp;&nbsp;break;<br>
	&nbsp;&nbsp;printf("inside\n");<br>
	}<br>
	printf("hello\n")<br>
<br>
	&nbsp;&nbsp;while (1) {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;goto afterloop;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;printf("inside\n");<br>
	&nbsp;&nbsp;}<br>
      afterloop:<br>
	&nbsp;&nbsp;printf("hello\n")<br>
</div>


В  обоих случаях  мы не  увидим сообщения  "inside" -  программа сразу
после <em>break</em> или <em>goto</em> выйдет из цикла и напечатает "hello".

</p><p>

Разумеется, ставить <em>break</em> так, как в этом примере, нет никакого смысла
- проще было бы  не писать цикл вообще. Поэтому  его обычно используют
вместе с оператором <em>if</em>. Например, цикл

<div class="incode">
          while (1) {<br>
	  &nbsp;&nbsp;...;<br>
	  &nbsp;&nbsp;if (error_flag!=0)<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;break;<br>
	  }<br>
</div>

будет выполняться до тех пор, пока переменная <em>error_flag</em> равна нулю.

</p><p>

По  поводу  вложенных циклов  -  оператор  <em>break</em> завершает  выполнение
только  самого внутреннего  цикла  (или оператора  <em>switch</em>)  - того,  в
котором стоит. Например, такой код

<div class="incode">
	while (1) {<br>
<br>
	&nbsp;&nbsp;while (1) {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;printf("inner loop 1\n");<br>
	&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
        &nbsp;&nbsp;}<br>
        <br>
	&nbsp;&nbsp;while (1)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;printf("inner loop 2\n");<br>
<br>
        }<br>
<br>
	printf("out of loops\n");<br>
</div>

напечатав сообщение  "inner loop 1" один раз,  дальше до бесконечности
будет печатать "inner loop 2", а  до сообщения "out of loops" дело так
и не дойдет.

</p><p>

Что же касается оператора <em>continue</em>, то стоять он может только в циклах
и "досрочно"  завершает текущую итерацию, а операторы,  стоящие в теле
цикла после него, игнорируются. При  этом циклы <em>while</em> 
и <em>do-while</em> сразу
переходят  к  очередной  проверке   условия,  а  цикл  <em>for</em>,  пропустив
оставшиеся  операторы  тела  цикла,  перед проверкой  условия  все  же
выполняет  третью, итерационную  часть заголовка.   Вот три  примера с
пояснениями в комментариях

<div class="incode">
	/*<br>
	&nbsp;&nbsp;При x==2 выполнится continue, printf() будет пропущен,<br>
	&nbsp;&nbsp;программа перейдет к проверке условия и следующей итерации.<br>
<br>
	&nbsp;&nbsp;В результате будет напечатаны числа 1, 3<br>
	*/ <br>
<br>
	int x=0;<br>
<br>
	while (x&lt;3) {<br>
	&nbsp;&nbsp;x++;<br>
	&nbsp;&nbsp;if (x==2)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
	printf("%d\n",x);<br>
        }  <br>
<br>
	/*<br>
	&nbsp;&nbsp;Похожая ситуация, при x==2 выполнится continue, printf()<br>
	&nbsp;&nbsp;будет пропущен, программа перейдет к проверке условия и <br>
	&nbsp;&nbsp;следующей итерации.<br>
<br>
	&nbsp;&nbsp;В результате будет напечатаны числа 1, 3<br>
	*/ <br>
<br>
	int x=0;<br>
<br>
	do {<br>
	&nbsp;&nbsp;x++;<br>
	&nbsp;&nbsp;if (x==2)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
	&nbsp;&nbsp;printf("%d\n",x);<br>
        } while (x&lt;3);	  <br>
<br>
	/*<br>
	&nbsp;&nbsp;Более сложный пример. Переменная x инкрементируется не в<br>
	&nbsp;&nbsp;теле цикла, а в заголовке. По continue (при x==2) printf()<br>
	&nbsp;&nbsp;также будет пропущен, но перед очередной проверкой условия<br>
	&nbsp;&nbsp;инкремент  x++, стоящий в заголовке,  будет выполнен.<br>
<br>
	&nbsp;&nbsp;В результате будет напечатаны числа 0, 1<br>
	*/ <br>
<br>
	int x;<br>
<br>
	for ( x=0 ; x&lt;3; x++) {<br>
	&nbsp;&nbsp;if (x==2)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>
	&nbsp;&nbsp;printf("%d\n",x);<br>
        }<br>
</div>


И последнее (возможно, очевидное), что  я хотел бы сказать вам сегодня
о циклах. Цикл вовсе не обязательно должен содержать операторы в своем
теле.   Точнее, все  его тело  может состоять  из пустого  оператора ;
(точка с запятой). Так что строки вроде

<div class="incode">
	 while (x--);
</div>

или

<div class="incode">
	for (sum=0; sum&lt;100; sum+=next_value());
</div>

вполне  законны и  встречаются  в программах.  Чаще  всего в  подобных
строках стоит цикл <em>for</em>, поскольку в его 
заголовок можно уместить много разной работы.

</p><p>

На этом давайте закончим с циклами и уделим оставшееся время массивам.
Правда, сегодня мы будем говорить только про одномерные массивы.

</p>
    </td>
  </tr>
</table>

<br><br><br>

<hr align="center" width="50%">
<h1 align="center"><a name="create"></a>Массивы</h1>
<br>
<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2>Создание и инициализация массивов</h2>
<p>


Про  массив  можно  сказать,   что  это  набор  однотипных  безымянных
переменных, для  доступа к которым используются  их номера, называемые
индексами.   Впрочем, физикам  должны  быть ближе  такие понятия,  как
вектор (одномерный массив) или матрица (двумерный массив).

</p><p>

В С/С++  создание одномерного  массива похоже на  создание переменной,
только  после идентификатора  в квадратных  скобках  указывается число
элементов, то  есть, число  безымянных переменных, содержащихся в этом
массиве.  Это  число называется  размерностью.   Так,  если нам  нужен
массив для хранения координат точки, мы можем написать

<div class="incode">
	/* Одномерный массив из трех элементов типа double */<br>
	double ad[3];<br>
</div>

Что  будет содержать  подобный массив  сразу после  создания? Как  и в
случае обычных переменных, если вы  заведете массив в блоке или в теле
функции, то есть сделаете его автоматическим локальным, то он не будет
инициализироваться при создании - в нем окажется мусор:

<div class="incode">
	{<br>
	&nbsp;&nbsp;/* <br>
	&nbsp;&nbsp;&nbsp;&nbsp;автоматический локальный массив.<br>
	&nbsp;&nbsp;&nbsp;&nbsp;содержит непредсказуемые значения<br>
        &nbsp;&nbsp;*/<br>
<br>
	&nbsp;&nbsp;double ad[3];<br>
	&nbsp;&nbsp;...;<br>
        }<br>
</div>

Если же вы добавите ключевое  слово <em>static</em>, то массив будет 
вести себя точно    так   же,    как   статическая    
локальная    переменная   -
проинициализируется при  первом входе в блок, а  затем будет сохранять
свои значения:

<div class="incode">
	{<br>
	&nbsp;&nbsp;/* <br>
	&nbsp;&nbsp;&nbsp;&nbsp;статический локальный массив.<br>
	&nbsp;&nbsp;&nbsp;&nbsp;Инициализируется нулями при первом входе в блок,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;после этого сохраняет значения элементов<br>
           */<br>
<br>
	&nbsp;&nbsp;static double ad[3];<br>
	&nbsp;&nbsp;...;<br>
        }<br>
</div>

Точно  так же  - нулями  -  инициализируются и  массивы, созданные  на
файловом уровне.

</p><p>

При необходимости мы можем  сразу при создании одномерного массива его
инициализировать -  заслать в элементы нужные нам  значения. Для этого
после знака  = нужно перечислить  в фигурных скобках  список значений,
разделенный запятыми:

<div class="incode">
	/* Одномерный массив из трех элементов типа double */<br>
	/* инициализируется тремя вещественными числами    */<br>
<br>
	double ad[3] = { 0.0, 10.0, -1.0 };<br>
</div>

Список значений для инициализации  может быть короче массива, при этом
вашими значениями будут инициализированы только первые элементы:

<div class="incode">
       /*<br>
       &nbsp;&nbsp;Инициализируем только два первых элемента.<br>
        */<br>
       double ad[3] = { 1.5, 2.0 };<br>
</div>

Что  еще   более  забавно  и   удобно  -  если  мы   пользуемся  явной
инициалиазцией, то можем не указывать размерность массива, а поставить
просто пустые  квадратные скобки. Например,  запись, приведенная ниже,
создаст массив из 5 элементов - по количеству чисел для инициализации:

<div class="incode">
       /* Массив, размерность которого задана списком инициализации */<br>
<br>
       int x[] = { 1,2,3,4,5 };<br>
</div>

</p>
    </td>
  </tr>
</table>

<br>
<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="access"></a>Доступ к элементам.</h2>
<p>

Ну, создавать  одномерные массивы мы  худо-бедно научились. А  как нам
добывать  из массивов  значения  элементов? Здесь  помогут  все те  же
квадратные  скобки, но  на этот  раз в  качестве оператора  доступа по
индексу. Так, например

<div class="incode">
       int a[3]; <br>
       printf("%d\n", a[1] );<br>
</div>

напечатает нам  первый элемент массива  <em>a</em>. Но тут есть  одна тонкость,
которая  у многих  начинающих программировать  на C  поначалу вызывает
недоумение  и приводит  к ошибкам.   Если нормальные  люди, а  равно и
программисты  на многих других  языках, привыкли  считать с  единицы -
один, два,  три, то  программисты на  С считают с  нуля -  ноль, один,
два.  Так  что  перед  первым  элементом нашего  массива  есть  еще  и
нулевой. А  вот третьего элемента  нет. Поначалу такой  "способ счета"
непривычен,  но  со  временем  вы  заметите, что  у  него  есть  масса
преимуществ.

</p><p>

А  что делать,  если  мы  хотим обработать  не  один какой-то  элемент
массива, а все? Допустим, хотим добавить к каждому элементу число, или
сложить два  массива? Хотя такое, насколько мне  помнится, в некоторых
языках  и возможно,  очень  трудно придумать  однозначные правила  для
подобных   операций,   и  при   этом   еще   сделать  такие   операции
эффективными. Так  что ни  в С, ни  в С++ не  предусмотрены встроенные
операции  для работы  сразу со  всеми элементами  массива,  и написать
что-нибудь вроде

<div class="incode">
	   /* <br>
	   &nbsp;&nbsp;Неправильно - встроенных операций для всех <br>
	   &nbsp;&nbsp;элементов массива нет <br>
	   */<br>
<br>
	   int a[3], b[3], c[3];<br>
	   ...;<br>
	   c=a-b;<br>
</div>


не  удастся (а  если и  удастся, результат  окажется совсем  не таким,
какого вы ждали).

</p><p>

Так что для подобных целей вам придется воспользоваться циклом:

<div class="incode">
	   /* Правильно - перебираем все элементы в цикле */<br>
<br>
	   int a[3], b[3], c[3];<br>
	   int i;<br>
	   ...;<br>
	   for (i=0; i&lt;3; i++)<br>
	   &nbsp;&nbsp;c[i] = a[i] - b[i];<br>
</div>

Между прочим, обратите внимание на условие выхода в заголовке цикла. И
вспомните, что я только что говорил про счет элементов с нуля.

</p><p>

Как вы  уже поняли, с  отдельным элементом массива можно  работать так
же, как с  обычной переменной такого типа -  использовать в выражении,
передавать  функции его  значение  или (если  функция должна  изменить
элемент) его адрес, и так далее:

<div class="incode">
	 int x, y;<br>
	 int a[3];<br>
<br>
	 ...;<br>
	 y = x + a[2];     /* элемент массива в выражении */<br>
<br>
	 y=f(a[1]);	   /* элемент передается функции  */<br>
<br>
	 g(&x);<br>
<br>
	 g( &a[0] );       /* адрес элемента передается функции */<br>
</div>

</p>
    </td>
  </tr>
</table>

<br>
<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="paramarray"></a>Передача массивов в параметрах.</h2>
<p>

А можно ли передавать  массивы целиком функциям в качестве параметров?
Разумеется можно.  При этом в формальном параметре при определении или
объявлении функции  можно даже не указывать  размерность массива.  Так
что одна и  та же функция будет с успехом  работать с массивами разной
длины.  Правда, при этом вам  придется позаботиться о том, как функция
узнает о размерности  именно того массива, который ей  отдают в каждом
конкретном случае.  Например, передать  ей эту размерность в еше одном
параметре.  Для  наглядности, вот  вам функция, которая  считает сумму
всех элементов массива:

<div class="incode">
	 int total( int dim, int arr[] ) {<br>
	 &nbsp;&nbsp;int i, sum;<br>
	 &nbsp;&nbsp;for ( sum=0, i=0; i&lt;dim; i++)<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;sum += arr[i];<br>
	 &nbsp;&nbsp;return sum;<br>
         }<br>
<br>
	 int main() {<br>
	 &nbsp;&nbsp;int a[10], total_a;<br>
	 &nbsp;&nbsp;int b[3], total_b;<br>
<br>
	 &nbsp;&nbsp;...;<br>
<br>
	 &nbsp;&nbsp;total_a = total(10, a);<br>
	 &nbsp;&nbsp;total_b = total(3, b);<br>
	 &nbsp;&nbsp;...;<br>
	 }<br>
</div>

Но,  как и  в  случае с  нумерацией  элементов, у  передачи массива  в
функцию есть  один нюанс. Я говорил  на прошлом занятии, что  в С есть
только  передача параметров  по значению.  И для  того,  чтобы функция
могла  изменить переменную в  вызывающем коде,  передавать ей  надо не
саму  переменную,  а адрес  переменной.  А  внутри функции  приходится
работать с этим адресом, как с указателем.

</p><p>

Так вот, если  в функцию передается массив, то  она без дополнительных
ухищрений   может  изменять  значения   его  элементов   в  вызывающем
коде.  Так,  в приведенном  ниже  примере  в  main() переменная  i  не
изменится после вызова f(), а вот y[0] после вызова fa() увеличится на
единицу:

<div class="incode">
	  void f(int x) {<br>
	  &nbsp;&nbsp;x++;<br>
	  }<br>
<br>
	  void fa(int a[]) {<br>
	  &nbsp;&nbsp;a[0]++;<br>
          }<br>
<br>
	  int main() {<br>
	  &nbsp;&nbsp;int i=0;<br>
	  &nbsp;&nbsp;int y[2] = { 0, 0 };<br>
<br>
	  &nbsp;&nbsp;f(i);<br>
	  &nbsp;&nbsp;/* i по прежнему равно 0 */<br>
<br>
	  &nbsp;&nbsp;fa(y);<br>
	  &nbsp;&nbsp;/* y[0] теперь равно 1 */<br>
<br>
	  }<br>
</div>

Это так похоже  на передачу массива по ссылке,  что в некоторых книгах
так  и пишут  "массивы  в С  передаются  по ссылке".   На самом  деле,
передается в функцию вовсе не  массив, а адрес его первого элемента, а
дальше  в игру  вступают  указатели и  то  их родство  с массивами,  о
котором  я уже упоминал.  Но об  этом мы  будем говорить  на следующем
занятии.

</p>
    </td>
  </tr>
</table>

<br>
<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="strings"></a>Строки, С-стиль.</h2>
<p>

А в завершение этого занятия я хотел бы рассказать вам о специальном
типе массива - о текстовых строках.

</p><p>

На самом  деле строка в С -  это просто массив типа  <em>char</em>, в последнем
элементе  которого  записан  0  (не  код символа,  который  на  экране
выглядит, как 0, а байт с нулевым значением). Но, поскольку строки в С
очень популярны, для такого  типа массивов предусмотрена более удобная
форма инициализации.  Вы ее уже  видели, форматная строка  <em>printf()</em> 
на
самом  деле не что  иное, как  инициализатор для  безымянного массива,
передаваемого этой функции в качестве первого параметра.

</p><p>

Так  что массивы типа  <em>char</em> можно  инициализировать двумя  способами -
обычным,  пригодным для  любых массивов,  и  "специальным", работающим
только для  них. Следующий фрагмент кода инициализирует массивы
одним и  тем же содержимым - строкой  <em>hello\n</em>, заканчивающейся нулевым
байтом:

<div class="incode">
      char s1[] = { 'h', 'e', 'l', 'l', 'o', '\n', 0 };<br>
      char s2[] = "hello\n";<br>
</div>

Передав эти  массивы в качестве  форматных строк функции  <em>printf()</em>, вы
можете убедиться, что оба вызова напечатают одно и то же.

<div class="incode">
      /* В обоих случаях будет напечатано слово "hello" */<br>
      printf(s1);<br>
      printf(s2);<br>
</div>

Обратите внимание  - при  втором способе нам  не пришлось  добавлять в
конец нулевой байт - он при такой записи добавляется автоматически.

</p><p>

Зачем в строках понадобился нулевой байт в конце? Какое-то специальное
значение в последнем элементе - это просто один из способов определить
прямо  при  обработке массива  его  размерность.   Так  поступают и  с
массивами других типов, но при работе со строками это особенно удобно,
поскольку  код 0  не  соответствует ни  одному  "печатному" символу,  а
заодно при  использовании в логических условиях  означает FALSE.  Так,
например, достаточно написать

<div class="incode">
	 int len;<br>
	 char str[] = "Some text";<br>
<br>
	 len=0;<br>
	 while (str[len])<br>
	 &nbsp;&nbsp;len++;<br>
</div>

и на выходе из цикла вы получите в <em>len</em> длину строки (последний нулевой
байт не считается - не принято).

</p><p>
<br><br><br>	 
На этом мы нынешнее занятие закончим.

</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>
