<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 10</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h1 align="center">
	  часть 1, занятие 10
	</h1>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции<br><h1>
    Обзор стандартной библиотеки С.<br>(продолжение)</h1>
  </caption>
  <tr>
    <td>
        <ul>
          <li><a href="p1-10.html#comments">Необходимое пояснение</a>
          <li><a href="p1-10.html#stdio">Ввод-вывод - &lt;stdio.h></a>
          <li><a href="p1-10.html#ctype">Анализ символов - &lt;ctype.h></a>
          <li><a href="p1-10.html#string">Работа со строками - &lt;string.h></a>
          <li><a href="p1-10.html#math">Математические функции - &lt;math.h></a>
          <li><a href="p1-10.html#common">Функции общего назначения - &lt;stdlib.h></a>
          <li><a href="p1-10.html#assert">
	    Диагностика с завершением программы - &lt;assert.h></a>
          <li><a href="p1-10.html#signal">Работа с сигналами - &lt;signal.h></a>
          <li><a href="p1-10.html#stdarg">
	    Списки аргументов переменной длины - &lt;stdarg.h></a>
          <li><a href="p1-10.html#longjmp">Дальние переходы - &lt;setjmp.h></a>
          <li><a href="p1-10.html#time">Работа с датой и временем - &lt;time.h></a>
          <li><a href="p1-10.html#unistd">Интерфейс с системой UNIX - &lt;unistd.h></a>
          <li><a href="p1-10.html#limits">
	    Пределы, зависящие от реализации - &lt;limits.h>, &lt;float.h></a>
       </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">

<br><br><br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h1><a name="comments"></a>
               Обзор стандартной библиотеки С.<br>(продолжение)</h1>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Необходимое пояснение.</h2>
<p>
Прошлое  занятие  я  посвятил  тому,  что  более  или  менее  подробно
рассказал о некоторых, ключевых для нашего курса, функциях стандартной
библиотеки,  а  также объяснил  некоторые  понятия.   В детали  работы
остальных функций я вдаваться  не собираюсь. Наверняка подбор функций,
о  которых я  рассказывал на  прошлом занятии,  не самый  удачный. Но,
пытаясь уложиться с этим  обзором в разумное время, я руководствовался
двумя  критериями:  -  во-первых,  пытался дать  вам  тот  необходимый
минимум, без которого просто невозможно успешно писать программы на С;
во  вторых -  рассказывал о  том,  что потребуется  нам на  дальнейших
занятиях.   А  говорю я  к  тому, что  вторая  часть  обзора -  просто
перечисление (да  и то не  полное) других функций библиотеки,  с очень
скупыми  - строка-две -  пояснениями. В общем,  я призываю
вас относиться  к этой части  обзора, как к оглавлению  - просмотрите,
какие  функции бывают,  и, если  вас что-то  заинтересует,  прочтите ее
страницу документации, или поищите описание ее работы в книге.

</p><p>

Прежде, чем мы перейдем к списку, сделаю несколько замечаний.

<ol>
<li> Подборка функций  у разных трансляторов  и в разных  системах может
различаться.   Тот список,  что  здесь приводится  -  более или  менее
стандартный для unix-подобных систем.

<li> Похожий  список, только  более полный  и с  пояснениями,  вы можете
найти в книге Кернигана и  Ритчи "Язык программирования С, 3е издание"
(либо  во  втором  английском  издании).  Фактически,  то,  что  здесь
приводится - выдержки из этой замечательной книги.

<li> Не  забывайте  - библиотечные  функции  при  обнаружении ошибки  не
только возвращают флаг ошибки, но и  заносят ее номер в <em>errno</em>. Так что
если вы  видите "при  ошибке функция возвращает  <em>NULL</em>", про  себя надо
добавлять "... и заносит номер ошибки в <em>errno</em>".

<li> Вам часто  будет встречаться <em>size_t</em> 
в качестве  типа аргументов или
результата функции.  Это - синоним какого-либо  подходящего по размеру
(в конкретной  реализации) беззнакового  целого. Так что  для простоты
можете думать о нем, как об <em>unsigned</em>.
</ol>

Теперь можно переходить собственно к списку функций.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="stdio"></a>Ввод-вывод - &lt;stdio.h></h2>
<p>

Стандартные  потоки  <em>stdin</em>   (входной),  
<em>stdout</em>  и  <em>stderr</em>  (выходные)
открываются автоматически,  могут быть перенаправлены  в файл/из файла
средствами  командной  строки.  Также  автоматически  закрываются  при
нормальном  завершении программы.  При  необходимости программа  может
открыть дополнительный  поток с помощью  <em>fopen()</em>. В этом  случае после
использования  поток должен  быть  закрыт самой  программой с  помощью
<em>fclose()</em>. Перечислю функции, работающие с потоками:

<ul>

<li> FILE&nbsp;*fopen(char *filename,&nbsp;char *mode)<br>

     открывает  поток,  связанынй  с  файлом  <em>filename</em>.  Режим  работы
     определяется строкой <em>mode</em>. 
     Например  "r" - открыть на чтение, "w"
     - на  запись.  При  успешном завершении  возвращает  указатель на
     открытый поток, при ошибке - <em>NULL</em>.

<br><br>

<li> int&nbsp;fflush(FILE&nbsp;*f)<br>

    записывает все  накопленные в буфере  выходного потока <em>f</em>  данные в
    файл.   <em>fflush(NULL)</em>  выполняет эту  операцию  со всеми  открытыми
    выходными  потоками.  При  успешном завершении  возвращает  0, при
    ошибке - <em>EOF</em>.

<br><br>

<li> int&nbsp;fclose(FILE&nbsp;*f)<br>

    закрывает  поток  f. При  успешном  завершении  возвращает 0,  при
    ошибке - <em>EOF</em>.

<br><br>

<li> FILE&nbsp;*tmpfile()<br>

    создает временный файл для записи. Файл будет автоматически удален
    по <em>fclose()</em> либо при  
    завершении программы.  При успешном завершении
    возвращает указатель на открытый поток, при ошибке - <em>NULL</em>.

<br><br>

<li> char&nbsp;*tmpnam(NULL);<br>
     char&nbsp;*tmpnam(char&nbsp;result[]);<br>
<br>
       возвращает  уникальное  имя   временного  файла  (сам  файл  не
       создается). Без  аргумента возвращает указатель  на статическую
       строку.  С аргументом  -  копирует имя  в  указанный массив,  и
       возвращает указатель на этот массив.

<br><br>

<li> int&nbsp;printf(char&nbsp;*fmt,&nbsp;...)<br>
     int&nbsp;fprintf(FILE&nbsp;*f,&nbsp;char&nbsp;*fmt,&nbsp;...)<br>
     int&nbsp;sprintf(char&nbsp;*buf,&nbsp;char&nbsp;*fmt,&nbsp;...)<br>
<br>
       Функции форматного вывода соответственно  в <em>stdout</em>, 
       в поток <em>f</em> и
       в  символьный массив <em>buf</em>.   При успешном  завершении возвращают
       число   выведенных  символов  (возможно,   0).  При   ошибке  -
       отрицательное значение.

<br><br>

<li> int&nbsp;scanf(char&nbsp;*fmt,&nbsp;...)<br>
     int&nbsp;fscanf(FILE&nbsp;*f,&nbsp;char&nbsp;*fmt,&nbsp;...)<br>
     int&nbsp;sscanf(char&nbsp;*buf,&nbsp;char&nbsp;*fmt,&nbsp;...)<br>
<br>
       Функции форматного ввода соответственно из <em>stdin</em>, 
       из потока <em>f</em> и
       из символьного массива <em>buf</em>.  При успешном завершении возвращают
       число  успешно введенных элементов  (не символов,  а элементов,
       введенных по спецификациям,  заданным в форматной строке).  При
       ошибке возвращают <em>EOF</em>.

<br><br>      

<li> int&nbsp;getchar()<br>
     int&nbsp;fgetc(FILE&nbsp;*f)<br>
<br>
      Считывают одиночный символ из  <em>stdin</em> (<em>getchar()</em>) 
      или из входного
      потока <em>f</em> (<em>fgetc()</em>).  
      Возвращают либо символ в виде <em>unsigned&nbsp;char</em>
      (неотрицательный резльтат), либо <em>EOF</em>,  если поток исчерпан и при
      ошибке.

<br><br>

<li> int&nbsp;putchar(int&nbsp;c)<br>
     int&nbsp;fputc(int&nbsp;c,&nbsp;FILE&nbsp;*f)<br>
<br>
     Записывают одиночный символ в  <em>stdout</em> (<em>putchar()</em>) 
     или в выходной поток <em>f</em> (<em>fputc()</em>).  Возвращают 
     переданный в поток символ  либо, при ошибке,
     <em>EOF</em>.

<br><br>

<li> int&nbsp;ungetc(int&nbsp;c,&nbsp;FILE&nbsp;*f)<br>
<br>
     "Посмотрели на символ - не понравился". Функция отправляет символ
     c обратно  во <b>входной</b>  поток <em>f</em>. 
     Стандарт  гарантирует возвращение
     только одного символа  (некоторые реализации позволяют и больше).
     Функция возвращает  переданный обратно  в поток символ  либо, при
     ошибке, <em>EOF</em>.

<br><br>

<li> char&nbsp;*gets(char&nbsp;*buf) <br>
<br>
     Считывает строку  (от начала строки  до символа '\n') из  <em>stdin</em> в
     символьный  массив <em>buf</em>.  Символ \n  из строки  удаляется, точнее,
     заменяется  нулевым  байтом.  Функция  потенциально  опасна -  не
     позволяет  защититься  от ввода  строк,  длина которых  превышает
     размер  массива  <em>buf</em>.   При  успешном вводе  
     возвращает  <em>buf</em>.  По
     исчерпанию ввода и при ошибке - <em>NULL</em>.

<br><br>     

<li> char&nbsp;*fgets(char&nbsp;*buf,&nbsp;int&nbsp;size,&nbsp;FILE&nbsp;*f)<br>
<br>
     Ввод строки  из потока <em>f</em>.  
     Работает аналогично <em>gets</em>.  Отличия: -
     во-первых, вводит  из потока не более <em>size-1</em>  
     символов (защита от
     переполнения строки <em>buf</em>); во вторых - не удаляет из строки символ
     '\n' (но нулевой байт в конец строки добавляет)

<br><br>

<li> int&nbsp;puts(char&nbsp;*s)<br>
     int&nbsp;fputs(char&nbsp;*s,&nbsp;FILE&nbsp;*f)<br>
<br>
    Выводят  C-строку в  <em>stdout</em> (<em>puts()</em>),  
    либо в  поток  <em>f</em> (<em>fputs()</em>).
    Возвращают неотрицательное значение при успешном завершении , либо
    <em>EOF</em> при ошибке.

<br><br>

<li> int&nbsp;fseek(FILE&nbsp;*f,&nbsp;long&nbsp;offset,&nbsp;int&nbsp;fromwhere)<br>
<br>
    Позиционирование в файле  (функция смещает указатель записи-чтения
    для данного  файла).  Второй  аргумент указывает, на  сколько надо
    сместиться.   Третий  аргумент  позволяет выполенять  смещение  от
    начала или конца файла, либо от текущей позиции.  Возвращает 0 при
    успешном завершении, -1 при ошибке.

<br><br>

<li> long&nbsp;ftell(FILE&nbsp;*f)<br>
<br>
    Позволяет  получить  текущую  позицию  указателя  записи-чтения  в
    открытом файле <em>f</em>.  При ошибке возвращает -1.

<br><br>

<li> void&nbsp;rewind(FILE&nbsp;*f)<br>
<br>
    Устанавливает указатель  записи-чтения файла на  начало. Ничего не
    возвращает.

<br><br>

<li>
size_t&nbsp;fread(void&nbsp;*ptr,&nbsp;size_t&nbsp;size,&nbsp;size_t&nbsp;nobj,&nbsp;FILE *f)<br>
size_t&nbsp;fwrite(void&nbsp;*ptr,&nbsp;size_t&nbsp;size,&nbsp;size_t&nbsp;nobj,&nbsp;FILE&nbsp;*f)<br>
<br>
    Эти две функции позволяют читать  из потока либо записывать в него
    произвольные  данные.  При этом  первый  аргумент  - указатель  на
    массив, куда  данные надо передавать  из потока либо  откуда брать
    для записи в поток. Второй  аргумент - <em>size</em> - задает размер одного
    элемента,  третий  - максимальное  число  объектов, которое  можно
    считать либо записать.

</p><p>
    
    Функция  <em>fread()</em> возвращает  количество считанных  объектов. Чтобы
    понять, была ли  при вводе ошибка и был ли  исчерпан поток <em>f</em>, надо
    использовать функции <em>ferror()</em> и <em>feof()</em>.

</p><p>

    Функция <em>fwrite()</em>  также возвращает количество  объектов (только не
    считанных, а  записанных). Но об  ошибке вы можете  догадаться без
    <em>ferror()</em>,  поскольку  функция  вернет  меньшее  значение,  чем  вы
    указали в <em>nobj</em>.

<br><br>

<li> int&nbsp;feof(FILE&nbsp;*f)<br>
<br>
    возвращает ненулевое значение,  если у потока установлен индикатор
    конца файла  (например, если при последнем вводе  из потока данные
    были исчерпаны).

<br><br>

<li> int&nbsp;ferror(FILE&nbsp;*f)<br>
<br>
    возвращает ненулевое значение,  если у потока установлен индикатор
    ошибки (при последней операции с потоком возникла ошибка).

<br><br>

<li> void&nbsp;clearerr(FILE&nbsp;*f)<br>
<br>
    Очищает в потоке <em>f</em> индикаторы конца файла и ошибки.

<br><br>

<li> void&nbsp;perror(char&nbsp;*header)<br>
<br>
    Выводит внятное сообщение в поток <em>stderr</em>.

<br><br>
</ul>

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="ctype"></a>Анализ символов - &lt;ctype.h></h2>
<p>

В  файле  &lt;ctype.h>  собраны  объявления  функций,  которые  позволяют
определить, к  какому классу относится тот или  иной символ. Например,
на прошлом  занятии я  говорил  что пробел  в форматной  строке
<em>scanf()</em> подходит  для разных  символов - пробела,  табуляции, перевода
строки и  т.п. А общее  у них то,  что для всех них  функция <em>isspace()</em>
вернет <em>true</em> (ненулевое значение), отнеся из к классу пробелов.

</p><p>

Имена всех  функции проверки принадлежности начинаются с  <em>is</em>.  Все эти
функции ожидают  один аргумент  типа <em>int</em> (анализируемый  символ должен
быть неотрицательным, то есть,  перед проверкой должен быть приведен к
типу unsigned  char). Возвращают все  эти функции тоже  <em>int</em>, ненулевое
значение означает принадлежность к соответсвующему классу.

<div>
  <table width="70%" align="center" cellspacing="5%">
   <tr><td>isalpha(c)</td><td>&nbsp;&nbsp;</td><td>c - буква</td></tr>
   <tr><td>islower(c)</td><td></td><td>c - буква нижнего регистра</td></tr>
   <tr><td>islower(c)</td><td></td><td>c - буква верхнего регистра</td></tr>
   <tr><td>isdigit(c)</td><td></td><td>c - цифра</td></tr>
   <tr><td>isxdigit(c)</td><td></td><td>c - шестнадцатиричная цифра</td></tr>
   <tr><td>isalnum(c)</td><td></td><td>c - буква или цифра</td></tr>
   <tr><td>iscntrl(c)</td><td></td><td>c - управляющий символ (например, \n)</td></tr>
   <tr><td>isprint(c)</td><td></td><td>c - печатаемый символ</td></tr>
   <tr valign="top"><td>isgraph(c)</td><td></td><td>c - печатаемый и видимый символ. 
                                         Отличается от 
                            <em>isprint()</em> тем, что не включает в себя
                            символ пробела.</td></tr>
   <tr><td>ispunct(c)</td><td></td><td>c - символ пунктуации</td></tr>
   <tr><td>isspace(c)</td><td></td><td>c относится к классу пробелов</td></tr>
  </table>
</div>

<br>

Еще  в &lt;ctype.h> есть  две очень  полезные функции,  которые позволяют
переводить буквы из верхнего регистра в нижний и наоборот

<br>
<div>
  <table width="70%" align="center" cellspacing="5%">
      <tr><td>int tolower(int c)</td></tr>
      <tr><td>int toupper(int c)</td></tr>
  </table>
</div>

Обе  они  возвращают  в  качестве  результата хранящуюся  в  <em>c</em>  букву,
переведенную в другой регистр.

</p>

<br>

    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="string"></a>Работа со строками - &lt;string.h></h2>
<p>

                   

Здесь мы будем иметь дело с двумя группами функций. Функции с именами,
начинающимися  с <em>str</em>, работают  с С-строками,  в которых  нулевой байт
означает  конец строки.  Функции  же, начинающиеся  с <em>mem</em>,  работают с
массивами  символов, следовательно,  позволяют работать  и  с нулевыми
байтами.

</p><p>

<b>Обратите внимание</b>  -  функции   вроде  копирования  и  слияния  строк
(модифицирующие  один из  аргументов) изменяют  первый аргумент,  а не
второй.

<ul>

<li> char *strcpy(char *s1, char *s2) <br>
  копирует строку s2 в s1. Возвращает s1.<br>
<br>

<li> char *strncpy(char *s1, char *s2, size_t n)<br>
  копирует строку s2
  в s1, но копируется не более n символов. Возвращает s1.<br>
<br>

<li> char *strcat(char *s1, char *s2)<br>
  объединяет строки s1 и s2
       (дописывает s2 в s1). Возвращает s1.<br>
<br>

<li> char *strncat(char *s1, char *s2, size_t n)<br>
  объединяет строки
       s1 и s2, но дописывает не более n символов. Возвращает s1.<br>
<br>
     
<li> int strcmp(char *s1, char *s2)<br>
     сравнивает строки (содержимое,
       не указатели), расставляя их в лексикографическом
       порядке. Возвращает 0 для совпадающих строк, отрицательное
       значение при s1&lt;s2 и положительное при s1>s2.<br>
<br>

<li> int strncmp(char *s1, char *s2, size_t n)<br>
 тоже сравнивает
       строки, но берет из них для сравнения не более n первых
       символов. <br>
<br>

<li> char *strchr(char *s, int c)<br>
   возвращает указатель на первый
       встреченный в строке символ c. Если такого символа в строке не
       оказалось, возвращает NULL.<br>
<br>

<li> char *strrchr(char *s, int c)<br>
   похожа на strchr(), но возвращает
       указатель на последний символ c в строке.<br>
<br>
    
<li> char *strstr(char *s1, char *s2)<br>
   возвращает указатель на первую
       встреченную в строке s1 подстроку s2. Если подстроки не нашлось, 
       возвращает NULL.<br>
<br>
    
<li> size_t strlen(char *str)<br>
   возвращает длину строки.<br>
<br>
    
<li> char *strerror(size_t n)<br>
   возвращает строку сообщения,
       соответсвующего ошибке с номером n.<br>
<br>

<li> void *memcpy(void *dst, void *src, size_t len)<br>
   копирует len
       байтов (включая нулевые) из src в dst. Возвращает dst.  <br>
<br>
    
<li> void *memove(void *dst, void *src, size_t len)<br>
   делает то же,
       что и memcpy. Это - единственная функция, которая по стандарту
       обязана правильно копировать перекрывающиеся объекты.<br>
<br>

<li> int memcmp(void *s1, void *s2, size_t len)<br>
   аналог strcmp, но с
       учетом нулевых байтов.<br>
<br>

<li> void *memchr(void *s, int c, size_t len)<br>
   аналог strchr, но с
       учетом нулевых байтов.<br>
<br>
    
<li> void *memset(void *s, int c, size_t len)<br>
   заполняет первые len
       байтов массива s символом c.<br>
<br>

</ul>

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="math"></a>Математические функции - &lt;math.h></h2>
<p>


                  

Для того, чтобы пользоваться этими функциями, вы должны подключить при
сборке задачи библиотечный файл libm (указав ключ -lm транслятору).
Например

<div class="session">
        cc myprog.c -o myprog -lm
</div>

Те  функции,   которые  я  приведу,  рассчитаны  на   работу  с  типом
<em>double</em>. Однако представленный  вам список, хотя и богат,  но далеко не
полон - как-нибудь наберите 'man&nbsp;3&nbsp;math' и сами убедитесь. 

</p><p>

К счастью, большинство функций вам знакомо из математики, так что для
них даже пояснений не требуется. Итак, вот он - хотя и не полный, но
внушительный список:

<ul>
<li> double sin(double x) - синус
<li> double cos(double x) - косинус
<li> double tan(double x) - тангенс
<li> double asin(double x) - арксинус
<li> double acos(double x) - арккосинус
<li> double atan(double x) - арктангенс
<li> double atan2(double y, double x) - Арктангенс y/x. В отличие от
         обычного, определяет по знакам y и х квадрант и возвращает 
	 значение в
         диапазоне от -pi до pi (обычный - от -pi/2 до pi/2)  

<li> double sinh(double x) - гиперболический синус
<li> double cosh(double x) - гиперболический косинус
<li> double tanh(double x) - гиперболический тангенс
<li> double exp(double x)  - e в степени x
<li> double log(double x)  - натуральный логарифм
<li> double log10(double x)  - десятичный логарифм
<li> double pow(double x,double y) - x в степени y
<li> double sqrt(double x)  - квадратный корень     
<li> double fabs(x)        - абсолютное значение x (модуль х)

<li> double ceil(double x) - наименьшее целое, которое не меньше х,
         преведенное к типу double 

<li> double floor(double x) - наибольшее целое, которое не больше х,
         преведенное к типу double 

<li> double hypot(double x, double y) - длина гипотенузы. Разумеется,
         ничего не стоит самому написать sqrt(x*x+y*y), но hypot()
         избавит вас от забот о том, как избежать потери точности и
         переполнения.

<li> double modf(double x, double *ip) - разбивает число на целую и
         дробную части. Дробная часть возвращается в качестве
         результата, целая записывается в ip.
</ul>

Можно было  бы назвать еще немало функций  математической библиотеки -
функции  Бесселя, функцию  ошибок, и  многое другое.  Но думаю,  что и
приведенного списка вам надолго хватит.
</p>
<br>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="common"></a>
	       Функции общего назначения - &lt;stdlib.h></h2>
<p>

Этот заголовок вам уже знаком - именно в нем объявляются функции
для работа с динамической памятью в С-стиле, о которых мы говорили
несколько занятий назад:

<div class="incode">
    void *malloc(size_t size);<br>
    void *calloc((size_t number, size_t size);<br>
    void *realloc(void *ptr, size_t size);<br>
    void *free(void *ptr);<br>
</div>

Помимо этих, в том же файле объявлено еще много других полезных
функций. Вот некоторые из них:

<ul>

<li>    double atof(char *s)<br>
    int atoi(char *s)<br>
    int atol(char *s)<br>
    double strtod(char *s, char **endp)<br>
    long strtol(char *s, char **endp, int base)<br>
    unsigned long strtoul(char *s, char **endp, int base)<br>
<br>
       Эти  функции  позволяют  преобразовывать  символьноу  выражение
       числа, хранящееся  в строке, в  число. Это одна  из альтернатив
       <em>scanf()</em> - вы можете сначала  считать из 
       входного потока строку, а
       потом  уже из  этой строки  с помощью  таких  функций извлекать
       значения переменных.

</p><p>

       Наиболее широкие возможности у  последних трех - <em>strto...()</em>. 
       Во
       первых,  они  позволяют   работать  с  системами  счисления  от
       двоичной аж  до 36-ричной (разумеется, это  не касается функции
       <em>strtod()</em>),  система  задается   аргументом  
       <em>base</em>;  а  во  вторых,
       прочитав из  строки число, эти функции возвращают  в <em>endp</em> адрес
       следующего  символа, чтобы  вы могли  с этого  места продолжить
       разбор строки.

<br>

<li> int rand()<br>
    void srand(unsigned int seed)<br>
    long random(unsigned long seed)<br>
    void srandom(unsigned long seed)<br>
<br>
       Работа с  псевдослучайными числами.  
       Функции  <em>rand()</em> и <em>random()</em>
       генерируют случайные числа,  равномерно распределенные по всему
       диапазону  типа <em>int</em>  и <em>long</em>,  
       соответственно.  Функции  <em>srand()</em> и
       <em>srandom()</em>  позволяют, задавая  разные  
       значения <em>seed</em>,  получать
       различные  последовательности чисел  (очередное псевдослучайное
       числа на  самом деле рассчитываются  по рекурсивным алгоритмам,
       так что, стартуя генератор с  одного и того же места, вы будете
       получать  одинаковую  последовательность).  Пользоваться  лучше
       парой  функцией random()  - у  нее по  сравнению с  <em>rand()</em> шире
       диапазон, и гораздо больше период последовательности.<br>

<br>

    
<li> int abs(int n)<br>
    long labs(long n)<br>
<br>
       Эти две функции возвращают абсолютное значение числа типа int и
       long соответственно.<br>

<br>

<li> div_t div(int num, int denom)<br>
    ldiv_t ldiv(long num, long denom)<br>
<br>
       Функции вычисляют частное и остаток  от деления для чисел int и
       long, возвращая оба результата в полях структуры типа div_t или
       ldiv_t соответсвенно.<br>

<br>

<li> void abort()<br>
<br>
       Аварийное  завершение  задачи  с  созданием образа  памяти  для
       последующей отладки.<br>
<br>
<li> void exit(int status)<br>
<br>
       Нормальное   завершение  задачи.   Значение   аргумента  <em>status</em>
       передается  операционной системе. В  unix-подобных операционных
       системах успешным завершением  принято считать возврат нулевого
       статуса.  Возврат значения из <em>main()</em> с помощью оператора return
       полностью эквивалентен вызову <em>exit()</em> с этим значением.<br>
<br>
<li> int atexit(void (*func)())<br>
  <br>
      Позволяет  назначать  функции,  которые  будут вызваны  при  при
      нормальном завершении задачи.<br>
<br>
<li> int system(const char *s)<br>
<br>
      По этому вызову программа запустит команду операционной системы,
      заданную в  строке s, дождется ее завершения,  а затем продолжит
      работу.<br>
<br>
<li> char *getenv(char *name);<br>
    int  setenv(const char *name, const char *value, int overwrite);<br>
    int putenv(const char *string);<br>
    void unsetenv(const char *name);<br>
<br>
       Эта группа  функций позовляет работать  с переменными окружения
       (например, с переменной PATH)  - получать и менять их значения,
       создавать и  уничтожать переменные. Переменные  окружения - это
       те строки, в которых сама операционная система хранит различные
       параметры,  нужные для  нормального запуска  и функционирования
       программ. Не путайте их с переменными самой программы.<br>
<br>
       
<li> 
 <table align="left">
  <tr><td>void *bsearch(</td><td>void *key, void *base, size_t nelm,</td></tr>
  <tr><td></td><td>size_t size,</td></tr>
  <tr><td></td><td>int (*compare)(void *keyval, void *data));</td></tr>
 </table>
<br>
<br><br><br>
       Эта функция осуществляет поиск заданного элемента key в массиве
       любого типа base.  nelm и  size задают число элементов и размер
       элемента. Если найдет -  возвращает указатель на него. Функцию,
       сравнивающую  два элемента,  вы должны  написать сами  - именно
       поэтому у последнего аргумента bsearch такой затейливый тип.<br>
<br>
<li> 
 <table align="left">
  <tr><td>void (</td><td>void *base, size_t nelm,</td></tr>
  <tr><td></td><td>size_t size, </td></tr>
  <tr><td></td><td>int (*compare)(void *keyval, void *data));</td></tr>
 </table>
<br>
<br><br><br>
        Эта   функция   сортирует   массив   элементов   произвольного
        типа. Смысл аргументов такой же, как и у функции bsearch().<br>
<br>
</ul>
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="assert"></a>
	    Диагностика с завершением программы - &lt;assert.h>
	    </h2>
<p>

В  файле  заголовков   &lt;assert.h>  задано  
макроопределение  <em>assert()</em>,
предназначенное для  отладки программ, с которым  вы уже сталкивались.
Если в программе встречается <em>assert(expression)</em>, и 
значение <em>expression</em>
оказывается  ненулевым,   ничего  не  происходит.   Если  же  значение
<em>expression</em>  нулевое,  то  в  <em>stderr<em> выводится  сообщение,  
в  котором
присутсвует  и <em>expression</em>,  и имя  файла, и  номер строки,  после чего
вызывается  функция <em>abort()</em>. Например,  
<em>assert(0==1)</em> сообщит вам  что-нибудь в
таком духе:

<div class="session">
  assertion "0==1" failed: file "test.c", line 4<br>
  Abort (core dumped)<br>
</div>

Кстати, могу дать  совет. Если для вас и  такое сообщение недостаточно
информативно,  вы можете с  помощью оператора  , (запятая)  включить в
него текстовую строку, например

<div class="incode">
          assert(("Main", 1==0));
</div>

добавив ее таким образом в диагностику.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="signal"></a>
	      Работа с сигналами - &lt;signal.h>
	    </h2>
<p>

Про это мы говорили на прошлом занятии. 

<ul>
<li> void (*signal(int sig, void (*handler)(int)))(int)<br>
<br>
      Позволяет задать обработчик <em>handler</em> 
      для сигнала <em>sig</em>. Прототип
      функции выглыдит жутковато, но на самом деле вам надо передать в
      нее номер сигнала в первом аргументе и функцию-обработчик  во
      втором. Попутно <em>signal()</em> 
      возвращает в качестве  результата старую
      функцию-обработчик, чтобы вы могли при необходимости
      восстановить прежнее поведение для сигнала.<br>
<br>
<li> int raise(int sig)<br>
<br>
      Посылает сигнал <em>sig</em> текущему процессу (той задаче, которая
      вызвала эту функцию).<br>
<br>
</ul>
Функций для работы  с сигналами довольно много, но  я бы советовал вам
поначалу ограничиться этими двумя.<br>
<br>
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="stdarg"></a>
	      Списки аргументов переменной длины - &lt;stdarg.h>
	    </h2>
<p>

Про начинку этого  файла я даже говорить не буду.  Просто скажу, что в
нем  есть средства,  позволяющие  писать функции,  умеющие работать  с
разным количеством аргументов, как это умеет делать, 
например, <em>printf()</em>.<br>
<br>
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="longjmp"></a>
	      Дальние переходы - &lt;setjmp.h>
	    </h2>
<p>

Об этом мы тоже говорили на прошлом занятии.

<ul>
<li> int setjmp(jmp_buf jmpb)<br>
      <br>
      Функция запоминает в переменной <em>jmpb</em> точку, в которой программа
      ее вызвала, возвращая 0 в качестве   результата. <br>
<br>
<li> void longjmp(jmp_buf jmpb, int retval)<br>
<br>
      Функция передает управление на ту точку, которая была сохранена
      в <em>jmpb</em>. Для программы это выглядит так, словно соответсвующий
      вызов <em>setjmp()</em> вернул не 0, а <em>retval</em>.<br>
<br>

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="time"></a>
	      Работа с датой и временем - &lt;time.h>
	    </h2>
<p>

<ul>

<li> clock_t clock()<br>
<br>
        Возвращает время процессора, использованное программой с
        момента запуска. Время измеряется в долях секунды, равных
        1/CLOCKS_PER_SEC.   <br>
<br>
<li> t time(time_t *t)<br>
<br>
       Возвращает время в секундах, прошедшее с начала эпохи UNIX (с 0
       часов 0 минут по Гринвичу 1 января 1970 года).
       Если t - ненулевой указатель, то время записывается и в t тоже.<br>
    <br>
<li> difftime(time_t t1, time_t t2)<br>
<br>
       Вычисляет разницу t1-t2.<br>
<br>
<li> ctime(time_t *t)<br>
<br>
       Возвращает строку, в которой записана дата, соответсвующая
       заданному аргументом времени. Учитывает часовой пояс. Иными
       словами, написав в программе<br>
  
<div class="incode">
           time_t t;<br>
           time(&t);<br>
           printf("%s\n", ctime(&t);<br>
</div>
        вы выведете в <em>stdout</em> строку с местным временем.<br>
<br>
</ul>

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="unistd"></a>
	      Интерфейс с системой UNIX - &lt;unistd.h>
	    </h2>
<p>

Даже по названию видно, что этот файл только для unix-подобных систем,
и к  изучению С  отношения не имеет.  Упоминаю только затем,  чтобы вы
вспомнили о нем, если придется трудиться под UNIX.

<br><br>

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="limits"></a>
	      Пределы, зависящие от реализации - &lt;limits.h>, &lt;float.h>
	    </h2>
<p>

Об этих заголовках не упомянуть нельзя, но и толку в обозримом будущем
вам от  них не  будет. В них  хранятся различные константы  и пределы,
зависящие от конкретной  реализации транслятора и операционной системы
- число   битов  в  символе,   размеры  различных   типов  переменных,
максимальные  и минимальные  значения и  тому подобное.  При известном
трудолюбии,  опираясь на  эти файлы,  можно писать  хорошо переносимые
программы, которые будут работать на любом компьютере.

</p><p>

<br><br><br><br>
Вот, собственно, и все, о чем я хотел рассказать (вернее, упомянуть)
в сегодняшней лекции. На этом обзор возможностей стандартной библиотеки 
С закончен, а с ним подошла к концу и первая часть курса, посвященная С-подмножеству языка С++.

</p><p>
На очереди у нас - вторая часть, посвященная тому новому, 
чем тличается С++ от С.

</p>
    </td>
  </tr>
</table>

</div>

</body>
</html>
