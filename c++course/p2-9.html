<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 9</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h1 align="center">
	  часть 2, занятие 9<br>
	  Стандартная библиотека С++
	</h1>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
        <ul>
`         <li>Введение
	  <ul>
	    <li><a href="p2-9.html#stl-what">Что, почему и зачем?</a>
	    <li><a href="p2-9.html#stl-about">О чем пойдет разговор сегодня?</a>
	  </ul>

	  <li>Как всем этим пользоваться?
	  <ul>
	    <li><a href="p2-9.html#stl-usage">Несколько примеров с контейнерами</a>
	    <li><a href="p2-9.html#stl-cont-seq">Контейнеры-последовательности</a>
	    <li><a href="p2-9.html#stl-cont-assoc">Ассоциативные контейнеры и пары</a>
	    <li><a href="p2-9.html#stl-iter">Итераторы</a>
	    <li><a href="p2-9.html#stl-algo">Алгоритмы</a>
	    <li><a href="p2-9.html#stl-outofscope">Что осталось за кадром?</a>
	  </ul>
       </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h1><a name="stl-what"></a>Введение</h1>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Что, почему и зачем?</h2>
<p>
Стандартная  библиотека  С остается  за  кадром,  поскольку  о ней  мы
относительно подробно  говорили, когда заканчивали  первую часть курса. 
Напомню только, что файлы заголовков этой библиотеки
при переходе из С в С++ изменили имена - в новом варианте перед именем
файла  добавлена буква c,  и удален  суффикс .h,  например, &lt;stdlib.h&gt;
превратился в &lt;cstdlib&gt;.
</p><p>
Что включено в стандартную библиотеку?  Почему именно это?  И зачем ей
пользоваться?   Ответ (хотя  бы  приблизительный) на  эти три  вопроса
может сэкономить в работе много времени.
</p>
<ol>
  <li>Что включено в библиотеку?<br>
</p><p>
В стандартной библиотеке,  хотя она довольно объемна, не  так уж много
возможностей. Перечислю их:
</p><p>
Потоки. О них мы говорили на прошлом занятии
</p><p>
Численные методы.   Численные -  громко сказано.  Комплексные  числа и
что-нибудь вроде умножения  массива на константу вы в  них найдете, но
не более  того. Никаких численных  методов в понимании  математика или
физика там нет.
</p><p>
Строки. Очень удобные классы для работы с текстовой информацией.
</p><p>
Контейнеры. Здесь  представлены различные варианты  часто используемых
структур данных - вектора, списки,  стеки, очереди и т.п. Точнее, даже
не  сами структуры,  а  заготовки для  них.  Конкретную структуру  для
своего типа  данных программист делает сам -  впрочем, со стандартными
контейнерами это тривиальная задача.
</p><p>
Алгоритмы и  объекты-функции. Как и в случае  с "численными методами",
не рассчитывайте отыскать здесь что-нибудь сложнее сортировки. 
</p><p>
Итераторы.  Крайне полезны для работы с контейнерами и алгоритмами, но
самостоятельной ценности  не имеют. Нужны в  качестве связующего звена
между структурами  данных (не обязательно  контейнерами) и алгоритмами
или другим кодом, эти структуры использующим.
</p><p>
То, что принято называть поддержкой языка и что не относится ни к чему
из вышеперечисленного - динамическая память, исключения, typeinfo.
</p><p>
Еще кое-какие мелочи.
<br><br>

<li>Почему именно это?<br>
</p><p>
Стандартная библиотека содержит лишь самые общие вещи - без которых не
обойдется ни одна программа. Главные ее задачи - обеспечить "привязку"
к  конкретной платформе,  а также  эффективность и  переносимость всех
программ  и   библиотек,  написанных  с  ее   использованием.   Ну  и,
разумеется,  облегчить  стыковку  между  собой различных  библиотек  и
программ. Таким  образом, стандартная  библиотека - это  тот тщательно
отобранный  минимум, на который  любой разработчик  может рассчитывать
независимо от того, какую задачу он решает и в какой среде работает.
</p><p>

<li>Зачем (и когда) библиотекой пользоваться?<br>
</p><p>
Казалось  бы  самый  легкий  вопрос.   По  крайней  мере,  многие,  не
задумываясь, назовут  массу причин, почему это хорошо  и правильно. Но
это всего лишь слова. Когда  доходит до дела, нередко оказывается, что
человек  пишет свой  класс (алгоритм,  функцию) с  нуля,  всесто того,
чтобы воспользоваться уже имеющимися  средствами. Для этого может быть
масса причин,  и некоторые  я вполне могу  понять (сам  порой грешен),
особено,  если делать поправку  на то,  что мы  все-таки физики,  а не
профессиональные программисты.
</p><p>
Вот  в  чем,  на мой  взгляд,  основная  проблема  - для  того,  чтобы
научиться  успешно  пользоваться стандартной  (как,  впрочем, и  любой
другой)  библиотекой,  нужно потрудиться  и  потратить довольно  много
времени   (почитать   книги   и  описания,   поэкспериментировать,   и
т.п.). Причем, если задача простая,  вам на этом начальном этапе будет
казаться, что дело движется слишком медленно (так оно и будет на самом
деле). 
</p><p>
В   такой  ситуации   у   физиков  (точнее,   не  у   профессиональных
программистов),  по  моим понятиям,  особенно  часто должен  возникать
соблазн написать программу с нуля.
</p><p>
Такой подход  (писать с  нуля) имеет право  на существование,  если вы
пишете программы редко. для себя, и  на один раз. Если же хоть одно из
этих  условий  не  выполняется,  стоит  все-таки  потратить  время  на
освоение библиотеки.
</p><p>
А основные  аргументы (с поправкой на  то, что вы  не на программистов
учитесь) просты  - это экономия времени на  разработку и сопровождение
программ,  эффективность  и более  высокая  надежность этих  программ,
более легкая стыковка кода, написанного разными людьми. Как следствие,
у  вас появится  время  и возможность  подступиться  к более  сложным,
объемным и интересным задачам.
</ol>
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="stl-about"></a>О чем пойдет разговор сегодня?</h2>
<p>
О потоках мы говорили, со  строками, хоть и немного, работали. Так что
повторяться  не  буду.   Детального  перечисления классов,  функций  и
прочей  начинки тоже  не  ждите. Сегодня  я  постараюсь объяснить  вам
взаимосвязь  и  общие   приципы  использования  трех  ключевых  частей
библиотеки - контейнеров, алгоритмов и итераторов.
</p><p>
Контейнер    -  это хранилище
элементов,  ну  и,  разумеется,   какие-то  средства,  чтобы  с  этими
элементами работать (здесь  и   далее,  если   не  утверждается   обратное,  к
контейнерам,   итераторам   и   прочему   неявно   добавляется   слово
"стандартный",  то есть,  из стандартной  библиотеки).
</p><p>
Слишком  общее  определение?   Но   все  контейнеры  и  в  самом  деле
разработаны таким образом, чтобы при необходимости вы могли работать с
элементами независимо от того, в какой именно разновидности контейнера
- векторе, списке,  или очереди - эти  элементы хранятся. Естественно,
разновидности  различаются  между собой  и  внутренним устройством,  и
эффективностью   различных   операций,   и   набором   дополнительных,
характерных только  для них способов доступа к  элементам. Например, у
вектора  есть  оператор  [],  которого  нет  у  списков,  зато  список
позволяет эффективно выполнять  операции вставки и удаления элементов.
Но  при  этом  любой  из  контейнеров  поддерживает  набор  однотипных
операций -  небольшой, но  достаточный для того,  чтобы на  его основе
можно было писать обобщенные алгоритмы для работы с элементами.
</p><p>
Вполне естественно,  что в С++ контейнеры реализованы  в виде классов,
точнее,  в  виде шаблонов  классов,  при  этом  тип элемента  задается
параметром шаблона.
</p><p>
Итераторы - это нечто, аналогичное указателю на элемент массива - и по
смыслу и по стилю использования. По сути, указаетль на элемент массива
- тоже  итератор.  Как  пишет  Страуструп, все,  что  ведет себя,  как
итератор,   таковым  и  является.    Имея  итератор   p  какого-нибудь
контейнера, вы  можете перейти  к следующему или  предыдущему элементу
(++p, --p),  получить элемент (*p), сравнить с  другим итератором того
же  контейнера  (p==p1).  Но  итераторы  "уже"  обычных указателей  по
возможностям.
</p><p>
Итак, итераторы  нужны, чтобы давать удобный и  единообразный доступ к
элементам  любого  контейнера.    Их  главное  назначение  -  задавать
последовательности  элементов, те границы  (по элементам),  в пределах
которых мы  хотим работать.  Понятно,  что для обычного  массива можно
обойтись не итераторами, а индексами. Но что делать, если надо выбрать
из ассоциативного  массива с  ключом-строкой все элементы  с индексом,
начинающимся  на A?   Напомню, ассоциативный  массив -  это  массив, у
которого в  качестве индекса (ключа) может  использоваться значение не
целочисленного типа, например, строка.
</p><p>
Итераторы контейнеров  также реализованы  в виде шаблонов,  причем они
являются  частью определения  класса самого  контейнера.  Так  что для
работы с контейнером не нужно знать точный тип его итератора.
</p><p>
Алгоритмы  (и   объекты-функции)  нужны  для  того,   чтобы  мы  могли
эффективно работать с набором элементов контейнера. Впрочем, не только
контейнера. Благодаря итераторам  алгоритмы удалось сделать достаточно
независимыми, "отцепить"  их от понятия  "контейнер". Алгоритмы просто
обрабатывают        элементы        последовательности,       заданной
итераторами. Например, строка
<div class="code">
p = find(p1, p2, 'c');
</div>
с равным успехом найдет первое  вхождение символа 'c' что в контейнере
(если p, p1,  p2 - итераторы этого контейнера),  что в обычном массиве
символов (тогда p, p1, p2 должны быть типа char*).
</p><p>
Что  именно надо  проделать с  последовательностью, задается  в первую
очередь самим алгоритмом. Но  поведением многих алгоритмов также можно
управлять, передавая им в  качестве аргументов функции (это могут быть
обычные функции или  функции-объекты).  Хорошая иллюстрация - алгоритм
for_each для прохода (перебора  всех элементов) с выполнением какой-то
операции. Например,
<div class="code">
	 for_each(pbegin, pend, print);
</div>
переберет все  элементы последовательности, вызвав для  каждого из них
функцию print(elm)  (разумеется, вы  должны позаботиться о  том, чтобы
функция   print()  с   аргументом  соответсвующего   типа   нашлась  в
программе). Все равно, как если бы вы написали
<div class="code">
	for (p=pbegin; p!=pend; p++)<br>
	&nbsp;&nbsp;print(*p);<br>
</div>
для обычного массива.
</p><p>
Тесно   смыкаются  с   алгоритмами  так   называемые  объекты-функции.
Алгоритму все равно, что именно  ему передают - функцию или же объект,
похожий  на функцию.   Но  некоторые вещи  удобнее  делать при  помощи
объектов, и зачастую подобные функциональные объекты работают быстрее,
чем обычные функции. В  стандартной библиотеке есть несколько подобных
объектов, и при необходимости вы всегда можете дописать свои.
</p><p>
Естественно,  алгоритмы и  функциональные объекты  тоже  реализованы в
виде шаблонов.
</p><p>
Надеюсь,  мне удалось более  или менее  логично обрисовать  связь этих
трех    частей     библиотеки    -    контейнеров,     итераторов    и
алгоритмов. Разумеется,  в жизни картина  не так идеальна  - некоторые
алгоритмы  работают  только  с  частью  контейнеров,  набор  операций,
применимых  к итератору  (имеются в  виду операции  типа ++,  --, []),
зависит от того, к какому  контейнеру итератор относится, и так далее.
И  для освоения  всех этих  премудростей надо  немало  потрудиться.  В
утешение могу  сказать, что одной из  целей проектировщиков библиотеки
была  относительная  простота  ее  использования.  Точнее,  библиотеку
создавали  с таким расчетом,  чтобы на  первых порах  программисты без
особых усилий могли  решать с ее помощью простые  задачи, чтобы затем,
по мере освоения, постепенно переходить к более сложным.
</p>
    </td>
  </tr>
</table>

<br><br><br>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h1><a name="stl-usage"></a>Как всем этим пользоваться?</h1>
    </td>
  </tr>
</table>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Несколько примеров с контейнерами</h2>
<p>
Теперь  попытаюсь  продемонстрировать  самые  простые и  общие  приемы
использования  всего этого  хозяйства. Для  более  близкого знакомства
обзаведитесь  хорошей  книжкой  (кстати,  я  готовил  обзор  по  книге
Страуструпа,  но это  отнюдь не  легкое чтиво,  так что  начинающим не
советую).
</p>
<p>
Разумеется,  у всякого  контейнера  есть конструкторы  - как  минимум,
копирующий и конструктор по  умолчанию. Есть и классовое присваивание,
следовательно, вы можете копировать  содержимое из одного контейнера в
другой (такого же типа) простым присваиванием.
<div class="code">
       void f(vector&lt;int>& arg1, vector&lt;int>& arg2) {<br>
       &nbsp;&nbsp;// копирующий конструктор<br>
       &nbsp;&nbsp;vector&lt;int> v=arg1;<br>
       <br>
       &nbsp;&nbsp;// классовое присваивание<br>
       &nbsp;&nbsp;v = arg2;<br>
       }<br>
</div>
Кроме  того, у  любого контейнера  есть полезная  функция-член <em>size()</em>,
позволяющая узнать количество элементов в нем:
<div class="code">
	    list&lt;int> l;<br>
	    ...<br>
	    cout &lt;&lt; "В списке " &lt;&lt; l.size()<br>
	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; " элементов\n";<br>
</div>
Всякий  стандартный  контейнер   изначально  содержит  два  итератора,
доступных  через функции-члены  контейнера <em>begin()</em>  и  
<em>end()</em>. Функция  <em>begin()</em>
указывает на первый элемент, а <em>end()</em> означает "несуществующий элемент,
следующий за последним".  Смысл <em>begin()</em> и <em>end()</em> 
примерно такой же, как
у 0 и  n (размерности) при работе с обычным  массивом, когда в массиве
из  n элементов  индексы  идут от  0  до n-1.   Разумеется, вы  можете
создавать дополнительные итераторы по мере надобности, например, чтобы
обработать все  элементы массива в  цикле.  Тип итератора  определен в
самом  классе  контейнера,  так  что  если  вы  используете  контейнер
<em>vector&lt;int></em>,  то  у  итератора  будет тип  
<em>vector&lt;int>::iterator</em>,  для
<em>list&lt;int></em> - <em>list&lt;int>::iterator</em>, и так далее. 
Вот пример, использующий
итераторы для перебора всех элементов вектора (вектор - это контейнер,
напоминающий массив):
<div class="code">
       #include &lt;vector><br>
       #include &lt;iostream><br>
       using namespace std;<br>
       <br>
       main() {<br>
       &nbsp;&nbsp;// создаем вектор из 10 элементов, исходный<br>
       &nbsp;&nbsp;vector&lt;int> v(10);<br>
       &nbsp;&nbsp;// Здесь нет итераторов,  мы пользуемся для<br>
       &nbsp;&nbsp;// записи значений оператором [], присутствующим<br>
       &nbsp;&nbsp;// не во всех контейнерах<br>
       &nbsp;&nbsp;for (int i=0; i&lt;10; i++)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;v[i] = i;<br>
       <br>
       &nbsp;&nbsp;// Создаем контейнер - копию первого<br>
       &nbsp;&nbsp;// Такой код пригоден для любого контейнера<br>
       &nbsp;&nbsp;vector&lt;int> res = v;<br>
       <br>
       &nbsp;&nbsp;// А здесь мы пользуемся итератором для<br>
       &nbsp;&nbsp;// умножения всех элементов res на 2. Такой код<br>
       &nbsp;&nbsp;// будет работать с любым контейнером<br>
       &nbsp;&nbsp;vector&lt;int>::iterator p;<br>
       &nbsp;&nbsp;for (p=res.begin(); p!=res.end(); p++)<br>
       &nbsp;&nbsp;*p *= 2;<br>
       <br>
       &nbsp;&nbsp;// Теперь похожим способом<br>
       &nbsp;&nbsp;// выводим результат на печать<br>
       &nbsp;&nbsp;for (p=res.begin(); p!=res.end(); p++)<br>
       &nbsp;&nbsp;cout &lt;&lt; *p &lt;&lt; endl;<br>
       }<br>
</div>
Как видите, конструкция цикла  очень похожа на цикл обработки обычного
массива.   Впрочем, сам  цикл я  написал  только для  для того,  чтобы
пояснить  смысл  <em>begin()</em>  и   <em>end()</em>.  С  точки  зрения  
стиля  гораздо
правильнее  воспользоваться стандартным  алгоритмом  <em>for_each</em>. передав
ему соответствующие функции для умножения на 2 и вывода в cout.
<div class="code">
    #include &lt;vector><br>
    #include &lt;iostream><br>
    using namespace std;<br>
    <br>
    void mul2(int& i) { i *= 2; }<br>
    void print(int i) { cout &lt;&lt; i &lt;&lt; endl; }<br>
    <br>
    main() {<br>
    &nbsp;&nbsp;vector&lt;int> v(10);<br>
    &nbsp;&nbsp;for (int i=0; i&lt;10; i++)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;v[i] = i;<br>
    <br>
    &nbsp;&nbsp;vector&lt;int> res = v;<br>
    <br>
    &nbsp;&nbsp;for_each(res.begin(), res.end(), mul2);<br>
    &nbsp;&nbsp;for_each(res.begin(), res.end(), print);<br>
    }<br>
</div>
Еще одна  прелесть контейнеров - они при  необходимости умеют изменять
количество  элементов. Так, у  вектора (и  не только)  есть достаточно
общие  функции <em>front()</em>  и <em>back()</em>  для доступа  к первому  
и последнему элементам   контейнера,  и  функции   <em>push_back()</em>  и   
<em>pop_back()</em>  для
добавления    в    конец    и    уничтожения    последнего    элемента
соответственно. При желании, элементы можно добавить (или удалить) и в
середине при помощи функций-членов <em>erase</em> и <em>insert</em>.
</p><p>
И, разумеется, каждый контейнер  имеет и свою специфику, отражающую его внутреннюю организацию и помогающую там, где это необходимо, воспользоваться преимуществами 
его внутренней организации. Так, например,  у вектора есть <em>operator[]</em>, 
но нет функции  <em>pop_front()</em>, удаляющей первый элемент, а у списка - 
наоборот.
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="stl-cont-seq"></a>Контейнеры-последовательности</h2>
<p>
Контейнеры  в библиотеке  бывают двух  типов -  последовательности (то
есть, наборы однотипных элементов),  и ассоциативные - содержащие пары
ключ-значение (точнее,  обеспечивающее доступ по  ключу, само значение
при этом может отсутствовать).
</p><p>
Основные представители последовательностей - <em>vector</em>, <em>list</em>, 
<em>deque</em>.
</p><p>
<em>vector&lt;T></em> -  массив (одномерный) элементов типа T.   Определен в 
файле заголовков  &lt;vector>.   Отличительная   особенность  от  других  типов
контейнеров  -   наличие  эффективной  операции   доступа  по  индексу
(<em>operator[]</em>). Слабое место - вставка и удаление элементов.
</p><p>
<em>list&lt;T></em>  - список элементов  типа Т.  Определяется в  файле заголовков
<em>&lt;list></em>. Хорош при частых вставках и удалениях элементов.
</p><p>
<em>deque&lt;T></em>  -  очередь  с  двумя  концами.   В  смысле  эффективности  -
своеобразный  гибрид вектора и  списка. Работа  с элементами  на обоих
концах (но  не в середине)  почти так же  эффективна, как в  списке, а
доступ  по индексу  []  - как  в  векторе. Слабое  место  - вставка  и
удаление в середине.
</p><p>
На  базе этих  трех  последовательностей строятся  и  другие -  <em>stack</em>,
<em>queue</em>, <em>priority_queue</em>, также представленные в стандартной 
библиотеке.
</p>
    </td>
  </tr>
</table>


<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="stl-cont-assoc"></a>Ассоциативные контейнеры и пары</h2>
<p>
Ассоциативные    контейнеры    во    многом    похожи    на    обычные
последовательности, но позволяют  вам работать с парами ключ-значение.
Впрочем, в некоторых  ассоциативных контейнерах значений, как таковых,
нет - есть только ключи.  Можно сказать, что ассоциативный контейнер -
это последовательность таких пар.
Б/зЮБзЮ
Для  работы  с  ассоциативными  контейнерами  применяется  специальный
шаблон  типа   <em>pair&lt;Type1,Type2></em>  -  пара.  Работать   
с  парой  очень
просто. Сначала мы создаем переменную нужного нам типа:
<div class="code">
        pair&lt;string,int> Entry;<br>
	<br>
	pair&lt;double, double> c;<br>
</div>
А  затем -  вне  зависимости от  фактических  типов, использованных  в
шаблоне - обращаемся к компонентам пары, как к полям <em>first</em> и 
<em>second</em>:
<div class="code">
	Entry.first = "Emergency";<br>
	Entry.second = 74444;<br>
	<br>
	c.first = 1.0;<br>
	c.second = 2.5;<br>
</div>
При  работе с  ассоциативными контейнерами  подразумевается,  что поле
<em>first</em> содержит ключ, а поле <em>second</em> - значение. Впрочем, 
тип <em>pair</em> ценен
и  сам  по  себе  -  например, он  находит  применение  в  комплексной
арифметике.
</p><p>
Теперь давайте  посмотрим, что  же из себя  представляют ассоциативные
контейнеры.   В  качестве  примера  поработаем  с  контейнером  <em>map</em>  -
ассоциативным массивом с уникальными ключами.
<div class="code">
       #include &lt;map><br>
       #include &lt;string><br>
       #include &lt;algorithm><br>
       #include &lt;iostream><br>
       <br>
       using namespace std;<br>
       <br>
       void print(const pair&lt;string,string>& entry) {<br>
       &nbsp;&nbsp;cout &lt;&lt; entry.first &lt;&lt; " " &lt;&lt; 
          entry.second &lt;&lt; endl;<br>
       }<br>
       <br>
       main() {<br>
       <br>
       &nbsp;&nbsp;// Создаем пустой ассоциативный массив<br>
       &nbsp;&nbsp;map&lt;string, string> book;<br>
       <br>
       &nbsp;&nbsp;// Добавляем элементы с помощью []<br>
       &nbsp;&nbsp;book["Urgency"] = "03";<br>
       &nbsp;&nbsp;book["Firemen"] = "01";<br>
       <br>
       &nbsp;&nbsp;// Теперь печатаем все элементы <br>
       <br>
       &nbsp;&nbsp;// Сначала явно в цикле, использую итераторы<br>
       &nbsp;&nbsp;map&lt;string,string>::iterator p;<br>
       &nbsp;&nbsp;for (p=book.begin(); p!=book.end(); p++) {<br>
       &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; p->first &lt;&lt; "  " &lt;&lt; p->second &lt;&lt; endl;<br>
       &nbsp;&nbsp;}<br>
       <br>
       &nbsp;&nbsp;// То же самое, но с использованием алгоритма<br>
       &nbsp;&nbsp;for_each(book.begin(), book.end(), print);<br>
       } <br>
</div>
Как  видите, главное отличие  ассоциативного контейнера  - возможность
работать с ключом и значением - нисколько не мешают использовать его в
алгоритме, как обычную последовательность.
</p><p>
Помимо <em>map</em>, в стандартной библиотеке есть еше ассоциативные контейнеры
<em>multimap</em>, <em>set</em> и <em>multiset</em>. <em>multimap</em> похож  на 
<em>мар</em> - он так же составлен
из пар &lt;ключ,значение>, но в нем  один и тот же ключ может встретиться
несколько раз. <em>set</em> и <em>multiset</em>  - множества, то есть, 
наборы ключей без значений (если угодно, можете считать значением сам факт 
наличия ключа в множестве).
</p>
    </td>
  </tr>
</table>


<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="stl-iter"></a>Итераторы</h2>
<p>
То, что уже было сказано  про итераторы, даже основами назвать нельзя.
Существует  много разновидностей итераторов  - константные  и обычные,
прямые, обратные, двунаправленные, с произвольным доступом. Но об этом
я говорить не собирался и не буду. А вернулся я к ним потому, что хочу
продемонстрировать интересный пример их использования. Дело в том, что
итератор   вовсе   необязательно   использовать   с   полной   версией
стандартного контейнера. Зачастую  можно пользоваться итераторами  для
того,  чтобы  применить   алгоритм  к  чему-нибудь,  весьма  отдаленно
напоминающему  контейнер.  Тривиальный  пример -  некоторые  алгоритмы
прекрасно  работают   с  обычными  массивами,  при   этом  в  качестве
итераторов им передаются указатели  на элементы массива. Гораздо более
неожиданный, но  специально предусмотренный разработчиками,  способ их
использования  - применение  итераторов и  стандартных  алгоритмов для
работы с потоками ввода-вывода.
</p><p>
Стандартная  библиотека для  этой цели  определяет входные  и выходные
итераторы потоков -  <em>istream_iterator</em> и <em>оstream_iterator</em>, 
причем ведут они себя подобно  обычным - то есть для ввода  или вывода надо 
сначала прочитать или записать значение, а затем инкрементировать итератор:
<div class="code">
	  // Итератор для вывода целых чисел в cout<br>
	  ostream_iterator&lt;int> os(cout)<br>
	  <br>
	  // Печатаем 1<br>
	  *os = 1;<br>
	  ++os;<br>
	  <br>
	  // Печатаем 100<br>
	  *os=100;<br>
	  ++os;<br>
</div>
Похожим  способом работают и  с входными  итераторами. В  дополнение к
этому,  конструктор по  умолчанию  для входного  итератора потока  (то
есть,  когда вы  при создании  не указываете  поток, с  которым должен
работать итератор)  означает конец ввода - это  аналог итератора <em>end()</em>
для  контейнеров.  Благодаря  этому  конструктору по  умолчанию  можно
задавать  последовательность  для  алгоритмов  библиотеки.   Например,
такая  программа  при  помощи  стандартного  алгоритма  копирования  и
итераторов  потока  прочтет все  слова  из <em>cin</em>  и  запишет  
их в  <em>cout</em>
(правда, попутно она уберет и все пробелы)
<div class="code">
	#include &lt;iterator><br>
	#include &lt;iostream><br>
	using namespace std;<br>
	<br>
	main() {<br>
	&nbsp;&nbsp;copy(istream_iterator&lt;string>(cin), <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	  istream_iterator&lt;string>(), <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	  ostream_iterator&lt;string>(cout)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
        }<br>
</div>
Не знаю, как вас, а меня такой уровень общности умиляет - хочешь, пиши
в список, хочешь - в поток.  Алгоритм один и тот же, нашлись бы только
подходящие итераторы.
</p>
    </td>
  </tr>
</table>


<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="stl-algo"></a>Алгоритмы</h2>
<p>
Пару-тройку иллюстраций использования алгоритмов вы уже встречали, так
что,  надеюсь,  уже  поняли  общий  принцип.   Приведу  еще  несколько
алгоритмов - не  то, чтобы самых полезных, а  просто иллюстрирующих те
варианты использования, которых вы  еще не видели.  Но сначала замечу,
что  сами  по себе  алгоритмы  в  качестве  управляющих функций  (если
таковые  вообще  предусмотрены  в параметрах  алгоритма)  воспринимают
функции с  единственным аргументом -  тем элементом, который  в данный
момент  алгоритмом обрабатывается.   Это  поначалу вызывает  некоторые
трудности,  если  вы хотите  передать  в  функцию  что-нибудь еще,  но
проектировщики   предлагают  способы   решения   подобных  проблем   -
достаточно эффективные, и, если к ним привыкнуть, вовсе несложные.
</p><p>
Шаблоны некоторых алгоритмов присутсвуют  в двух вариантах - обычном и
с суффиксом <em>_if</em>, например <em>find</em> и <em>find_if</em>. 
Второй вариант подразумевает
выполнение  операции  над элементом  последовательности  только в  том
случае, если он удовлетворяет  какому-то условию. Условие задается так
называемым   предикатом  -   функцией  или   функциональным  объектом,
возвращающим логическое значение. Например,
<div class="code">
     #include &lt;vector><br>
     #include &lt;iostream><br>
     using namespace std;<br>
     <br>
     bool negative(int x) { return x&lt;0; }<br>
     <br>
     main() {<br>
     <br>
     &nbsp;&nbsp;// Создаем и заполняем вектор из 10 элементов<br>
     &nbsp;&nbsp;vector&lt;int> v(10);<br>
     &nbsp;&nbsp;for (int i=0; i&lt;10; i++)<br>
     &nbsp;&nbsp;&nbsp;&nbsp;v[i] = i;<br>
     <br>
     &nbsp;&nbsp;// В пятом элементе отрицательное число<br>
     &nbsp;&nbsp;v[5] = -5;<br>
     <br>
     &nbsp;&nbsp;vector&lt;int>::iterator p;<br>
     <br>
     &nbsp;&nbsp;// Пытаемся найти первый элемент со значением 3 <br>
     &nbsp;&nbsp;p = find(v.begin(), v.end(), 3);<br>
     &nbsp;&nbsp;if (p != v.end())<br>
     &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "First elm with value " 
          &lt;&lt; *p <br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; 
        " found" &lt;&lt; endl;<br>
     <br>
     &nbsp;&nbsp;// Пытаемся найти первый отрицательный элемент <br>
     &nbsp;&nbsp;p = find_if(v.begin(), v.end(), negative);<br>
     &nbsp;&nbsp;if (p != v.end())<br>
     &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "First negative is " 
           &lt;&lt; *p &lt;&lt; endl;<br>
     <br>
     }<br>
</div>
В стандартной  библиотеке есть несколько  (немного) часто используемых
предикатов, в дополнение к этому вы всегда можете написать свои.
</p><p>
Помимо    предикатов,   некоторые    алгоритмы    умеют   использовать
арифметические функции. Вот пример,  который перемножает два вектора с
помощью    алгоритма   <em>transform</em>   и    стандартного   арифметического
объекта-функции <em>multiplies</em>.  Для  записи результата в вектор-результат
используется  стандартная функция  <em>back_inserter()</em>,  которая добавляет
элементы в конец контейнера:
<div class="code">
      // Создаем два вектора и как-нибудь заполняем их<br>
      vector&lt;int> v1, v2;<br>
      ... <br>
      <br>
      // Создаем вектор для результата<br>
      vector&lt;int> res;<br>
      <br>
      // Поэлементно перемножаем, помещая результат в res<br>
      transform(v1.begin(), v1.end(), v2.begin(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              back_inserter(res), multiplies&lt;int>);<br><br>

</div>
А  что,  если из  алгоритма  нужно  вызвать  функцию-член для  каждого
элемента последовательности?  Это не  так просто, как может показаться
на первый взгляд - ведь для вызова требуется сам объект (не в качестве
аргумента), да  и тип  "указатель на функцию-член"  довольно затейлив.
Для   этого  в  библиотеке   предусмотрены  так   называемые  адаптеры
функций-членов -  <em>mem_fun</em> для вызова функции члена  через указатель, и
<em>mem_fun_ref</em> - через ссылку  на объект. Вот пример вызова функции-члена
<em>Shape::draw</em> для каждого элемента контейнера с указателями 
на <em>Shape</em>:
<div class="code">
        void draw_all(list&lt;Shape*> l) {<br>
	&nbsp;&nbsp;for_each( l.begin(), l.end(),<br> 
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_fun(&Shape::draw) );<br>
	}<br>
</div>
Такой способ  годится, если надо вызвать функцию  без аргументов. Если
же вам надо  еще и передать в функцию  аргумент, нужно воспользоваться
связывателем   -    спецмальным   функциональным   объектом,   который
"связывает" один из своих аргументов с функцией. Скажем, если нам надо
вызывать функцию  <em>Shape::rotate</em> с  одним аргументом 
-  углом поворота, пригодится  стандартный связыватель  <em>bind2nd</em>,  
связывающий с  функцией свой второй аргумент:
<div class="code">
      void rotate_all(list&lt;Shape*> l, int angle) {<br>
      &nbsp;&nbsp;for_each( l.begin(), l.end(), <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bind2nd( 
         mem_fun(&Shape::rotate), angle )  );<br>
      }<br>
</div>
Кстати,  связыватели годятся  не только  для вызова  функций-членов. В
примере,  в котором мы  искали первое  отрицательное число  в векторе,
можно  было не  изобретать велосипед,  а написать  в  качестве функции
комбинацию       связывателя       и      стандартного       предиката
<em>bind2nd(less&lt;int>(),0)</em>, построив  таким образом из  стандартных 
нужный предикат "меньше нуля".
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="stl-outofscope"></a>Что осталось за кадром?</h2>
<p>
Кое  о каких частях  библиотеки мы  сегодня вообще  не говорили,  да и
раньше они если упоминались, то вскользь.  Я это сделал намеренно - не
потому, что эти части менее  полезны, а потому, что с ними разобраться
не в пример проще, чем с контейнерами и алгоритмами. 
</p><p>
За кадром  остался полезный  и удобный класс  для строк  со множеством
различных функций.
</p><p>
Не  говорили  мы  и  о  комплексной арифметике.  К  счастью  работа  с
комплексными числами  во многом напоминает работу  с обычными (спасибо
возможностям  С++). Упомяну  только, что  комплексные числа  -  это не
одиночный класс, а тоже  шаблон, позволяющий использовать для мнимой и
вещественной частей любой из вещественных типов.
</p><p>
Кроме того,  в библиотеке есть  классы, хранящие информацию о  типах -
такую, как число  битов в символе, число значащих  цифр в вещественном
типе, максимальные и  минимальные значения для типов, и  так далее. Но
этим, думаю, вы  нескоро начнете пользоваться - такие  вещи хороши для
тех, кто должен писать переносимый  код, а физики, к сожалению, такими
мелочами, как переносимость, нечасто себя утруждают.
</p><p>
Также остался  за кадром "почти  контейнер" valarray. Вот на  него при
случае  советую   обратить  внимание  -  он   гораздо  больше  вектора
напоминает нормальный  массив, и к  тому же разработан  специально для
эффективного выполнения численных расчетов и для стыковки с численными
методами из других языков.
</p><p>
Ну, а если вам  понадобится исчерпывающее перечисление всего того, что
предоставляется стандартной  библиотекой, вы  без труда найдете  его в
книгах или в сети.
</p>
    </td>
  </tr>
</table>

</div>

</body>
</html>
