<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 7</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 7</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
        <ul>
`         <li>Наследование и полимофизм
	  <ul>
	    <li><a href="p2-7.html#poly-main">Вспоминаем главное</a>
	    <li><a href="p2-7.html#poly-virtctor">Виртуальные конструкторы</a>
	    <li><a href="p2-7.html#poly-rtti">dynamic_cast и RTTI</a>
	    <li><a href="p2-7.html#poly-exceptions">Исключения и полиморфизм</a>
	  </ul>
       </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="poly-main"></a>Вспоминаем главное</h2>

<p>
На  прошлом занятии  я рассказывал  вам про  наследование  - механизм,
позволяющий расширять функциональность уже имеющихся классов, создавая
на  их основе  новые.   Вы  узнали,  что такое  виртуальные  функции  и
абстрактные классы, и познакомились с полиморфным поведением объектов.
</p><p>
Сегодня  я собираюсь  продолжить  наше  знакомство   с  полиморфными  классами,
рассказать  о  виртуальных  конструкторах,   о  том,  что  такое  RTTI
(информация времени  выполнения о типе), и как  ею пользоваться. Затем
  мы  немного  поговорим  об
исключениях  и  о  том,  как  полиморфизм может  помочь  в  разработке
логичной и удобной схемы обработки исключений.
</p><p>
Но сначала я напомню основные факты, касающиеся наследования.
</p><p>
Итак, если у вас есть некий класс
<div class="code">
      class Point {<br>
      protected:<br>
      &nbsp;&nbsp;int x,y;<br>
      public:<br>
      &nbsp;&nbsp;virtual void show() { ... };<br>
      &nbsp;&nbsp;virtual void hide() { ... };<br>
      &nbsp;&nbsp;void move(int new_x, new_y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;hide();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x = new_x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y = new_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;show();<br>
      &nbsp;&nbsp;}<br>
      };<br>
</div>
и вы хотите расширить его  функциональность, добавив к нему новые поля
данных  или   функции,  вам   вовсе  не  нужно   изменять  определение
существующего  класса.  Вместо  этого   надо  создать  на  его  основе
производный класс
<div class="code">
      class Circle: public Point {<br>
      protected:<br>
      &nbsp;&nbsp;int radius;<br>
      public:<br>
      &nbsp;&nbsp;void show() { ... };<br>
      &nbsp;&nbsp;void hide() { ... };<br>
      &nbsp;&nbsp;int get_radius() { return radius; }<br>
      };<br>
</div>
включив в его определение только то, что нужно добавить или изменить -
все остальные поля и методы будут унаследованы из базового.
</p><p>
Обратите внимание  на ключевые слова  virtual у двух функций  в классе
Point  - благодаря им  унаследованная функция  move будет  вызывать не
Point::show() и Point::hide(), а соответсвующие функции того класса, с
объектом которого она вызвана.
</p><p>
Классы,  подобные Circle,  называют полиморфными,  поскольку  в разных
условиях они  ведут себя по  разному. Так, объект класса  Circle может
вести себя  и как Point  - для этого  достаточно работать с  ним через
указатель или ссылку на Point:
<div class="code">
          Circle c;<br>
          Point  *p = &c;<br>
          int r;<br>
	  <br>
	  // OK, "native" Circle interface<br>
          r = c.get_radius();<br>
	  <br>
	  // Error - Point interface, no get_radius()<br>
          r = p->get_radius();<br>
</div>
Как  видите,  полиморфизм  позволяет  работать  с  различными  типами,
имеющими общий базовый класс, по интерфейсу этого базового класса.
</p><p>
В С++ у производного класса может быть несколько базовых классов. Если
бы мы написали, например
<div class="code">
   class Circle <br>
   &nbsp;&nbsp;: public Point, public ListItem <br>
   { ...; }<br>
</div>
то  смогли  бы работать  с  указателями/ссылками  на  Circle и  как  с
точками, и как с элементами списка.
</p><p>
Полиморфизм    -    мощное     средство,    широко    применяемое    в
объектно-ориентированном   программировании.    Однако   вам   следует
запомнить - чтобы  получить полиморфное поведение, необходимо работать
не с самим объектом, а с указателем или ссылкой на него.
</p><p>
Для  справки  замечу, что  многие  из  перегруженных операторов  могут
наследоваться.  Не наследуются (а, значит, и не могут быть виртуальными) 
оператор  присваивания и,  разумеется,
конструкторы, которые обязаны знать точный тип создаваемого объекта.
</p>
    </td>
  </tr>
</table>

<br><br><br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="poly-virtctor"></a>
	    Если нельзя, но очень хочется - виртуальные конструкторы
	    </h2>

<p>
Сначала, чтобы не возникло путаницы, хочу сделать оговорку - 
виртуальных конструкторов не существует,  они запрещены правилами языка.
То, о чем пойдет речь сейчас - как с помощью обычных функций добиваться 
того же результата, какой можно было бы ожидать  от виртуальных конструкторов.
Но прежде всего попробуем разобраться, для чего  нужны виртуальные конструкторы.
</p><p>
В  чистом виде  виртуальный конструктор  -  вещь нелепая.   Раз уж  мы
создаем объект, то не абы какой, а какого-то конкретного типа. Другое дело,
что мы можем не знать, какого именно - просто у нас есть (какой-то) объект,
и мы хотим сделать точно такой же. Или даже не просто сделать, но и скопировать
в него начинку старого. Первая операция похожа на конструктор по умолчанию,
вторая - на копирующий конструктор. Но, поскольку точный тип образца нам 
неизвестен, приходится проделывать это с помощью обычных виртуальных функций.
</p><p>
Так что, когда  говорят  о  виртуальных  конструкторах,  всегда имеют  в  
виду  задачу создания  объектов  по  существующему  образцу.  Ведь  у  
каждого образцового объекта  есть какой-то вполне определенный тип,  даже если 
мы и не знаем, какой именно.
</p><p>
Подобного  рода  задачи  возникают  при  необходимости  продублировать
большой набор  объектов, хранящийся, например, в виде  дерева. Одно из
применений - в каком-нибудь  графическом редакторе мы создавали чертеж
из отрезков, фигур, строк и так далее. Все это - объекты разного типа,
но они вполне могут  быть наследниками одного базового класса, скажем,
TElement, и все изображение хранится в виде связного списка указателей
на  этот базовый  тип. Затем  в какой-то  момент мы  хотим скопировать
чертеж (например, для вывода на  печать). Но про каждый из объектов мы
знаем только то, что он является наследником TElement.
</p><p>
Таким образом, у нас возникает необходимость скопировать весь список с
сохранением типов объектов, но самих типов мы не знаем.
</p><p>
Функции, которые  помогают решить эту задачу,  и называют виртуальными
конструкторами.
</p><p>
Различают  два  вида  виртуальных   конструкторов  -  по  умолчанию  и
копирующий.  Означают  эти термины  то  же,  что  и в  случае  обычных
конструкторов.  Конструктор  по   умолчанию  создает  "пустой"  объект
(такого  же, как  и  у  образца, типа).  Копирующий  конструктор еще  и
копирует во вновь созданный объект содержимое образца.
</p><p>
Делается это следующим образом: - в базовом классе определяются
две виртуальные (в примере ниже это makeobject и copyobject), которые
создают объект (copyobject еще и копирует в новый объект содержимое
образца) и возвращают указатель на него: 
<div class="code">
         #include &lt;string&gt;<br>
         #include &lt;iostream&gt;<br>
         using namespace std;<br>
	 <br>
         class A {<br>
         protected:<br>
         &nbsp;&nbsp;int val;<br>
         public:<br>
         &nbsp;&nbsp;A(int v=0) : val(v) {};<br>
         &nbsp;&nbsp;A(const A& src) : val(src.val) {};<br>
	 <br>  
         &nbsp;&nbsp;// makeobject() is a virtual default ctor<br>
         &nbsp;&nbsp;virtual A* makeobject() {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;A* ptr=new A;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;return ptr;<br>
         &nbsp;&nbsp;}<br>
	 <br>
         &nbsp;&nbsp;// copyobject() is a virtual copy ctor<br>
         &nbsp;&nbsp;virtual A* copyobject() {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;A* ptr=new A(*this);<br.
         &nbsp;&nbsp;&nbsp;&nbsp;return ptr;<br>
         &nbsp;&nbsp;}<br>
	 <br>
         &nbsp;&nbsp;virtual void show() {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; 
	   "Object of type A, val=" &lt;&lt; val &lt;&lt; endl;<br>
         &nbsp;&nbsp;}<br>
	 <br>
	 };&nbsp;&nbsp;// End of class A definition<br>
</div>
Затем, при разработке производного класса вы замещаете эти две функции
другими -  создающими и копирующими  объект вашего нового типа,  но по
прежнему возвращающими указатель на базовый класс:
<div class="code">
         <br>
         class B : public A {<br>
         &nbsp;&nbsp;string s;<br>
         public:<br>
         &nbsp;&nbsp;B(const char *str) : s(str) {};<br>
	 <br>
         &nbsp;&nbsp;// Copy ctor<br>
         &nbsp;&nbsp;B(const B& src) : A(src), s(src.s) {};<br>
	 <br>
         &nbsp;&nbsp;// Default ctor<br>
         &nbsp;&nbsp;B() : s("") {};<br>
	 <br>
         &nbsp;&nbsp;// virtual default ctor for class B<br>
         &nbsp;&nbsp;A* makeobject() {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;B* ptr=new B;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;return ptr;<br>
         &nbsp;&nbsp;}<br>
	 <br>
         &nbsp;&nbsp;// virtual copy ctor for class B.<br>
         &nbsp;&nbsp;A* copyobject() {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;A* ptr=new B(*this);<br>
         &nbsp;&nbsp;&nbsp;&nbsp;return ptr;<br>
         &nbsp;&nbsp;}<br>
	 <br>
         &nbsp;&nbsp;virtual void show() {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; 
	        "Object of type B, s=" &lt;&lt; s &lt;&lt; endl;<br>
         &nbsp;&nbsp;}<br>
	 <br>
         };&nbsp;&nbsp;// end of class B definition<br>
</div>
Проверить, как это работает, поможет небольшая программа, приведенная ниже:
<div class="code">
         <br>
         main() {<br>
	 <br>
         &nbsp;&nbsp;A a(1);<br>
         &nbsp;&nbsp;B b("Hello");<br>
	 <br>
         &nbsp;&nbsp;A* psrc[2];<br>
         &nbsp;&nbsp;A* psame[2];<br>
         &nbsp;&nbsp;A* pcopied[2];<br>
	 <br>
         &nbsp;&nbsp;psrc[0] = &a;<br>
         &nbsp;&nbsp;psrc[1] = &b;<br>
	 <br>
         &nbsp;&nbsp;for (int i=0; i&lt;2; i++) {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;psame[i] = psrc[i]->makeobject();<br>
         &nbsp;&nbsp;&nbsp;&nbsp;pcopied[i] = psrc[i]->copyobject();<br>
         &nbsp;&nbsp;&nbsp;&nbsp;psrc[i] ->show();<br>
         &nbsp;&nbsp;&nbsp;&nbsp;psame[i]->show();<br>
         &nbsp;&nbsp;&nbsp;&nbsp;pcopied[i]->show();<br>
         &nbsp;&nbsp;}<br>
	 <br>
         &nbsp;&nbsp;return 0;<br>
         }<br>
</div>
Если вы потрудитесь и соберете эти три кусочка в один файл, оттранслируете 
и запустите, то увидите следующее:
<div class="session">
Object of type A, val=1<br>
Object of type A, val=0<br>
Object of type A, val=1<br>
Object of type B, s=Hello<br>
Object of type B, s=<br>
Object of type B, s=Hello<br>
</div>
Как видите, благодаря полиморфизму, вызвав функции makeobject или copyobject
через указатель на базовый класс вы,  даже не  зная  типа объекта-образца,  
создаете объекты точно такого же типа.
</p>
    </td>
  </tr>
</table>

<br><br><br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="poly-rtti"></a>
	    dynamic_cast и RTTI
	    </h2>

<p>
Даже  при  правильном  проектировании  и с  учетом  всех  возможностей
полиморфизма  иногда  возникает   потребность  узнать  конкретный  тип
какого-то  объекта.  Для этой  цели  предназначены информация  времени
исполнения о  типах (<em>RTTI</em>, Run Time Type  Information) и 
<em>dynamic_cast</em>,
который  позволяет  безопасно   преобразовывать (во время выполнения программы) 
совместимые  по  сети наследования типы.
</p><p>
Поясню на примере. Немного раньше я приводил в качестве примера
чертеж, все элементы которого - наследники базового класса TElement.
</p><p>
Если они к тому же насленики класса Point, то мы можем убрать чертеж с
экрана в одном цикле. Правда, для этого нам придется явно
использовать приведение типа:
<div class="code">
       <br>
       TElement *drawing[100];<br>
       ...<br>
       for (int i=0; i&lt;100; i++) {<br>
       &nbsp;&nbsp;Point *p = (Point*)drawing[i];<br>
       &nbsp;&nbsp;p->hide();<br>
       }<br>
</div>
Беда этого кода в том,  что подобное приведение типа сработает в любом
случае  -  даже  если  реальный  объект  не  имеет  к  Point  никакого
отношения. А ведь в  чертеже могут храниться не только объекты-фигуры,
но и  какая-нибудь служебная информация  - например, объекты  string с
датой создания  или фамилией автора.  А поскольку у string  нет метода
hide(),  показанный   выше  код  приведет  к   ошибке  при  выполнении
программы.
</p><p>
Решить эту проблему позволяет специальный оператор <em>dynamic_cast</em>,
который позволяет безопасно приводить один тип к другому. Выглядит он
следующим образом:
<div class="code">
          Type1* p1;<br>
          Type2* p2 = dynamic_cast&lt;Type2*&gt;(p1);<br>
</div>
или
<div class="code">          
          Type1& ref1;<br>
          Type2& ref2 = dynamic_cast&lt;Type2&amp;&gt;(ref1);<br>
</div>
Первый вариант приводит указатель типа Type1* к типу Type2*, второй
проделывает то же самое со ссылками.
</p><p>
Почему же этот вариант безопасен? Дело в том, что если вы с его
помощью попытаетесь преобразовать один тип в другой, несовместимый с
первым, dynamic_cast вернет вам 0 (нулевой указатель). Так что теперь
мы могли бы убрать с экрана чертеж без риска "сломать" программу:
<div class="code">
       TElement *drawing[100];<br>
       ...<br>
       for (int i=0; i&lt;100; i++) {<br>
       &nbsp;&nbsp;Point *p = dynamic_cast&lt;Point*&gt;drawing[i];<br>
       &nbsp;&nbsp;if (p != 0)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;p->hide();<br>
       }<br>
</div>
Естественно, проверить на 0 можно только указатель, так что при работе
со ссылками проверка выполняется другим способом - при попытке
приведения между несовместимыми типами dynamic_cast возбуждает
исключение <em>bad_cast</em>. Соответсвенно, код нашего цикла выглядел бы
примерно так:
<div class="code">
       TElement *drawing[100];<br>
       ...<br>
       for (int i=0; i&lt;100; i++) {<br>
       <br>
       &nbsp;&nbsp;try {<br>
       &nbsp;&nbsp;&nbsp;&nbsp;Point& p = 
               dynamic_cast&lt;Point&amp;&gt; *drawing[i];<br>
       &nbsp;&nbsp;&nbsp;&nbsp;p->hide();<br>
       &nbsp;&nbsp;}<br>
       &nbsp;&nbsp;catch (bad_cast) {};<br>
       <br>
       }<br>
</div>
Хочу подчеркнуть  - dynamic_cast  не в состоянии  помочь вам,  если вы
хотите узнать  точный тип объекта. Он  лишь сообщает о  том, можно ли,
преобразовав   указатель  или   ссылку  к   другому   типу,  безопасно
использовать  ваш  объект  в  новом качестве.  Например,  он  позволит
привести Circle* к Point*. Позволит и обратное преобразование, если вы
имеете дело с объектом типа  Circle. Однако даже в последнем случае вы
так и  не узнаете, действительно  ли у вас  объект Circle, или  у него
другой, производный уже от Circle тип.
</p><p>
А как же  быть, если вам нужно точно узнать  тип своего объекта? Такая
потребность   все-таки   иногда    возникает   даже   при   правильном
проектировании  программ.  Для этого  в  С++  есть  другое средство  -
typeid. Вот как выглядит программа, использующая этот оператор для
вывода на печать имени используемого типа:
<div class="code">
       #include &lt;typeinfo&gt;<br>
       #include &lt;iostream&gt;<br>
       using namespace std;<br>
       <br>
       class A { public: virtual void l() {};} a;<br>
       class B : public A {} b;<br>
       class C : public B {} c;<br>
       <br>
       void f(A& ref) {<br>
       &nbsp;&nbsp;cout &lt;&lt; typeid(ref).name() &lt;&lt; endl;<br>
       }<br>
       <br>
       main() {<br>
       &nbsp;&nbsp;f(a);<br>
       &nbsp;&nbsp;f(b);<br>
       &nbsp;&nbsp;f(c);<br>
       }<br>
</div>
Когда я ее собрал и запустил, она напечатала следующее:
<div class="session">
      1A<br>
      1B<br>
      1C<br>
</div>
Обратите внимание  - в  базовом классе добавлена  "пустая" виртуальная
функция. Дело  в том, что typeid "предпочитает"  полиморфные классы, а
самый  простой способ  сделать  класс полиморфным  -  добавить в  него
виртуальную функцию.  (В качестве упражнения предлагаю вам  убрать ее и
посмотреть, что из этого выйдет.)
</p><p>
Возможно,  вы обратили  внимание на  то, что  использование результата
typeid напоминает  использование объекта класса.  Так и есть  на самом
деле - typeid возвращает  объект типа type_info, содержащийся в каждом
полиморфном классе и хранящий информацию  о его типе. А name() - метод
класса type_info, который  возвращает текстовую строку, уникальную для
класса  (как  видно из  вывода  программы,  она  включает в  себя  имя
класса).
</p><p>
Метод name() - не единственный в классе type_info. Два других полезных
метода -  это операторы !=  и ==, позволяющие проверять,  совпадает ли
тип нашего объекта  с ожидаемым. Интересуй нас объекты  именно типа A,
мы могли бы изменить код функции f в примере выше следующим образом:
<div class="code">
        void f(A& ref) {<br>
        &nbsp;&nbsp;cout &lt;&lt; typeid(ref).name() &lt;&lt; endl;<br>
        &nbsp;&nbsp;if (typeid(ref)==typeid(A))<br>
        &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "match" &lt;&lt; endl;<br>
        &nbsp;&nbsp;else<br>
        &nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "mismatch" &lt;&lt; endl;<br>
        }<br>
</div>
и при этом программа напечатала бы нам
<div class="session">
        1A<br>
        match<br>
        1B<br>
        mismatch<br> 
        1C<br>
        mismatch<br> 
</div>
Есть в type_info  и другие методы, но наиболее  полезны именно те три,
которые я назвал - name, == и !=.
</p><p>
На ошибки  (например, при попытке определить  тип нулевого указателя),
оператор typeid реагирует, возбуждая исключение bad_typeid.
</p>
    </td>
  </tr>
</table>

<br><br><br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="poly-exceptions"></a>
	    Исключения и полиморфизм
	    </h2>

<p>
Исключения, как вы помните, служат механизмом обработки ошибок в С++.
Напомню, как выглядит их использование:
<div class="code">
   double divide(double x, double y) {<br>
   &nbsp;&nbsp;if (y==0.0)<br>
   &nbsp;&nbsp;&nbsp;&nbsp;throw "Division by zero";<br>
   &nbsp;&nbsp;else<br>
   &nbsp;&nbsp;&nbsp;&nbsp;return x/y;<br>
   }<br>
   ...<br>
   try {<br>
   &nbsp;&nbsp;divide (10,0);<br>
   }<br>
   catch (const char *msg) {<br>
   &nbsp;&nbsp;cerr &lt;&lt; msg &lt;&lt; endl;<br>
   }<br>
</div>
Такой код,  вызвав функцию divide с  недопустимым значением аргумента,
приведет к  возбуждению исключения  типа const char*.  Благодаря тому,
что вызов функции  стоит в try-блоке, и у  этого блока есть обработчик
catch  с  совместимым  типом  аргумента,  при  возбуждении  исключения
выполнится оператор, выводящий сообщение об ошибке в поток cerr.
</p><p>
Если бы вызов  функции не был заключен в  try-блок, исключение привело
бы к завершению программы.
</p><p>
Передавать  в качестве  исключения не  обязательно строку  - с  тем же
успехом вы можете передать объект или ссылку любого типа.
</p><p>
Иногда достаточно просто определять в обработчике тип исключения - в
этом случае тот класс, объект которого вы передаете в качестве
исключения, вообще может быть пустым, не содержать никаких полей
данных и функций:
<div class="code">
            class FileError {};<br>
            class MathError {};<br>
	    ...<br>
            try {<br>
            &nbsp;&nbsp;...<br>
            }<br>
            catch (FileError) {<br>
            &nbsp;&nbsp;cerr &lt;&lt; "FileError occured" &lt;&lt; endl;<br>
            }<br>
            catch (MathError) {<br>
            &nbsp;&nbsp;cerr &lt;&lt; "MathError occured" &lt;&lt; endl;<br>
            }<br>
</div>
Как видите, в этом примере в качестве исключений используются "пустые"
независимые (никак  не связанные наследованием)  классы.  Однако такой
"линейный" подход  хорош только  для небольших задач.   При разработке
механизма  обработки ошибок,  если вы  хотите, чтобы  им  хоть изредка
пользовались  те,  кому  понадобятся  ваши  библиотеки,  крайне  важно
максимально облегчить задачу пользователей.  Можно, конечно, на каждый
новый вид ошибки заводить новый независимый класс исключения, но это -
верная гарантия  того, что  такими исключениями пользоваться  никто не
будет.
</p><p>
Как я уже сказал, в качестве исключения можно передавать не только сам
объект,  но и  ссылку на  него. После  всего того,  что  я рассказывал
сегодня, при слове  "ссылка" вы должны были подумать  о наследовании и
полиморфизме.
</p><p>
В самом деле, более  разумно было бы построить иерархическую структуру
возможных ошибок (и соответсвующих им классов исключений). Например:
<div class="code">
          class Error {}; // Generic error<br>
	  <br>
          class MathError : public Error {}; // Math error<br>
	  <br>
          class FileError : public Error {}; // File error<br>
	  <br>
          class FileOpenError: public FileError {};<br>
</div>
При этом пользователь ваших классов сможет перехватить любую из ошибок
с  помощью  единственного   обработчика  со  ссылкой  Error&amp;:
<div class="code">
        try {<br>
        &nbsp;&nbsp;f();<br>
        }<br>
        catch (Error& err) {<br>
        &nbsp;&nbsp;cerr &lt;&lt; "Exception (Error or descendant) caught"<br> 
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; endl;<br>
        }<br>
</div>
В  то  же   время,  если  в  каком-то  участке   программы  его  будут
интересовать  именно файловые  ошибки, ничто  не мешает  обработать их
отдельно:
<div class="code">
        try {<br>
        &nbsp;&nbsp;f();<br>
        }<br>
        catch (FileError& err) {<br>
        &nbsp;&nbsp;cerr &lt;&lt; "Exception (FileError or descendant) caught"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; endl;<br>
        }<br>
	catch (Error& err) {<br>
        &nbsp;&nbsp;cerr &lt;&lt; "Exception (Error or descendant) caught"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; endl;<br>
        }<br>
</div>
Разумеется, ничему не противоречит добавить в класс Error какую-нибудь
начинку, чтобы передавать, например, строку с описанием ошибки.
</p><p>
Кстати, именно таким образом -  в виде производных классов - построены
стандартные исключения  С++. Например, оба  упоминавшихся сегодня типа
исключений  bad_cast  и  bad_typeid,  равно  как  и  многие  другие  -
производные типы от класса exception.
</p><p>
И, наконец, пара слов о порядке вызова обработчиков.
</p><p>
Обработчики  catch  проверяются   при  возбуждении  исключения  в  том
порядке,  в котором они  записаны в  программе. Отсюда  следует важный
вывод  -  более "детализированные"  обработчики  должны стоять  раньше
общих.
</p><p>
Так, если у нас есть определения классов-исключений 
<div class="code">
          class Error {}; // Generic error<br>
          class MathError : public Error {}; // Math error<br>
          class FileError : public Error {}; // File error<br>
          class FileOpenError: public FileError {};<br>
</div>
и мы хотим обрабатывать исключение FileOpenError в одном обработчике,
а все остальные в другом, то надо написать:
<div class="code">
          try {<br>
          &nbsp;&nbsp;...<br>
          }<br>
          catch (FileOpenError&) {<br>
          &nbsp;&nbsp;... // обработчик для FileOpenError<br>
          }<br>
          catch (Error& ) {<br>
          &nbsp;&nbsp;... // обработчики для Error и его производных<br>
          }<br>
</div>
Если же  мы поменяем в примере  выше блоки catch местами,  то блок для
FileOpenError  никогда не вызовется,  поскольку исключение  этого типа
наравне  с другими  будет  обрабатываться стоящим  раньше более  общим
обработчиком для Error.
</p>
    </td>
  </tr>
</table>



</div>
</body>
</html>
