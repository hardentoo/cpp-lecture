<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 6</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 6</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Массивы и указатели.
	  <ul>
	    <li><a href="p1-6.html#volatile">
	      Небольшое отступление - volatile и const.</a>
	    <li><a href="p1-6.html#similar">
	      Что общего между массивами и указателями?</a>
	    <li><a href="p1-6.html#differ">
	      В чем разница между массивами и указателями?</a>
	    <li><a href="p1-6.html#arithm">Арифметика указателей.</a>
	    <li><a href="p1-6.html#multidim">
	      Многомерные массивы, массивы указателей и т.п.</a>
	    <li><a href="p1-6.html#main">"Настоящая" функция main()</a>
          </ul>
      </ul>
    </td>
  </tr>
</table>

<br><br><br>
<hr align="center" width="50%">
<h1 align="center"><a name="volatile"></a>
          Массивы и указатели.</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	 <h2>Небольшое отступление - volatile и const.</h2>
<p>


Прежде,  чем  продолжить разговор  о  массивах  и  указателях, я  хочу
показать вам два весьма полезных модификатора типа - <em>volatile</em> 
и <em>const</em>.
Оба  они не  сказываются на  размере переменной  (в отличие  от <em>short</em>,
например),  но   зато  меняют   ее  поведение,  а   точнее,  отношение
транслятора к этой переменной.  Давайте посмотрим вот на такие строчки
кода:

<div class="incode">
	    int i;<br>
	    ...<br>
	    i=1;<br>
	    while (i);<br>
</div>

На первый  взгляд кажется, что  это опечатка. Ведь прямо  перед циклом
переменной,  используемой в качестве  условия, присвоена  единица. Так
что цикл получается бесконечным. А  если так и задумано, то проще было
написать

<div class="incode">
	    int i;<br>
	    ...<br>
	    while (1);<br>
</div>

и получить тот же бесконечный цикл.

</p><p>

Дело здесь  в другом -  подобные приемы часто применяют  в программах,
когда  хотят дождаться какого-то  "внешнего" события.   Так, например,
переменную  <em>i</em> мог  бы  обнулять обработчик  сигналов  или даже  другая
программа для того,  чтобы известить нашу о том,  что сделана какая-то
работа,  и мы  можем двигаться  дальше.  А  мы просто  стоим  в цикле,
ожидая такого  сообщения. Однако, мало  объяснить эту идею  вам, надо,
чтобы и транслятор С/С++ ее понял.

</p><p>

Для того, чтобы программы работали быстрее, или, как принято говорить,
генерируемый код был эффективным, транслятор делает оптимизацию - либо
выбрасывает ненужные по его мнению  куски кода, либо заменяет их более
эффективными  эквивалентами. В  результате  скорость работы  программы
может  вырасти  в разы  и  даже  в десятки  раз.  Но  в данном  случае
оптимизация привела бы к плачевному результату - транслятор заменил бы
наш хитроумный цикл ожидания на обычный бесконечный.

</p><p>

Для  решения  подобных проблем  с  оптимизацией  в С/С++  предусмотрен
модификатор  типа  <em>volatile</em>.   Он  говорит транслятору,  что  тот  при
оптимизации  не  должен  делать  никаких  предположений  о  содержимом
переменной. В  нашем случае, если переписать  первый фрагмент, добавив
это ключевое слово к типу

<div class="incode">
	    volatile int i;<br>
	    ...<br>
	    i=1;<br>
	    while (i);<br>
 </div>

то  транслятор, независимо  от заказанного  уровня  оптимизации, будет
честно проверять значение <em>i</em> перед каждой итерацией.

</p><p>

Часто встречается  и прямо  противоположная ситуация -  человек знает,
что какая-то переменная не  поменяет своего значения, но транслятор об
этом  не догадывается,  и  поэтому создает  код, выполняющий  какую-то
лишнюю  работу. Это, правда,  не так  страшно, как  в первом  случае -
программа   будет  работать   правильно.  Но   медленнее,   чем  могла
бы. Например

<div class="incode">
       main() {<br>
       &nbsp;&nbsp;int i;<br>
       &nbsp;&nbsp;char s[]="Hello\n";<br>
       &nbsp;&nbsp;i=strlen(s);<br>
       &nbsp;&nbsp;if (s[0]!='H')<br>
       &nbsp;&nbsp;&nbsp;&nbsp;...;<br>
       &nbsp;&nbsp;...<br>
       }<br>
</div>

В  этом  фрагменте  строка  <em>s</em>  передается  функции  <em>strlen</em>,  
чтобы  та
определила  ее длину. Функция  не меняет  содержимого строки,  так что
условный оператор  после ее вызова можно просто  выбросить. Однако эта
функция лежит в стандартной библиотеке, у транслятора нет ее текста, и
догадаться  об этом  он не  в состоянии.  Подсказать ему  это  можно с
помощью модификатора <em>const</em> - в данном случае, в объявлении функции:

<div class="incode">
       int strlen(const char *str);<br>
       main() {<br>
       &nbsp;&nbsp;int i;<br>
       &nbsp;&nbsp;char s[]="Hello\n";<br>
       &nbsp;&nbsp;i=strlen(s);<br>
       &nbsp;&nbsp;if (s[0]!='H')<br>
       &nbsp;&nbsp;&nbsp;&nbsp;...;<br>
       ...<br>
       }<br>
</div>

Именно  такое  объявление   стоит  в  соостветсвующем  файле-заголовке
стандартной библиотеки С.

</p><p>

Ну вот, а теперь давайте займемся массивами и указателями.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="similar"></a>Что общего между массивами и указателями?</h2>
<p>

Я   уже   не  один   раз   говорил,   что   массивы  и   указатели   -
братья-близнецы. Вот и  только что, объясняя про <em>const</em>,  я в программе
написал массив, а в объявлении функции  
- <em>char*</em> (указатель на <em>char</em>). В чем тут
дело?  И, если они так похожи, то почему в языке есть, и те и другие -
чем же они все-таки отличаются?

</p><p>

Мы  с  вами  говорили на  прошлом  занятии,  что  массив -  это  набор
однотипных   безымянных   переменных   -   элементов,   доступных   по
индексам. Однако  не обсуждали вопрос  о том, как именно  эти элементы
хранятся в  памяти. В С (а для  встроенных типов - и  в С++), элементы
лежат  в   памяти  через  равные  промеужтки   в  порядке  возрастания
индексов. Так, например, если у нас массив типа <em>char</em>, то сначала лежит
его нулевой элемент, в следующем байте  - первый, еще на байт дальше -
второй, и так далее. Так что, зная адрес нулевого элемента массива, мы
легко можем  вычислить адрес, скажем, десятого -  для этого достаточно
добавить  к адресу нулевого  10.  А  где у  нас хранятся  адреса?  Вот
именно,  в указателях.  Теперь  нетрудно осознать,  какой смысл  имеют
операции сложения-вычитания для указателей:

<div class="incode">
	 char s[100];   /* Массив из 100 элементов типа char */<br>
<br>
	 char *p = &s[0]; /* Указатель на нулевой элемент массива */<br>
	 *(p+10)='l';	  /* Изменяем десятый элемент */<br>
<br>
         /* "перенацеливаем" указатель  на первый  элемент */<br>
	 p++;<br>
<br>
	 *(p+10) = 'k';  /* Меняем  11 элемент  */<br>
<br>
	 /* Проверяем содержимое нулевого элемента */<br>
	 if ( *(p-1) )<br>
	 &nbsp;&nbsp;...;<br>
</div>

Но в этом  примере массив и указатель имеют тип  <em>char</em>. 
То есть, размер
элемента  равен  одному байту.   Так  что,  прибавив  к адресу  1,  мы
сдвигаемся  как  раз на  один  байт. А  как  быть,  если мы  работаем,
например, с типом <em>int</em>, у которого размер - 4 байта? Оказывается, что и
в  этом   случае  все   показанные  выше  арифметические   операции  с
указателями  дадут  правильный результат.  Разумеется,  к тому  числу,
которым выражается адрес, будет добавляться не  1, а 4, но нам об этом
даже не придется думать:

<div class="incode">
	 /* <br>
	 &nbsp;&nbsp;Единственная замена - вместо char поставили  int.<br>
	 &nbsp;&nbsp;Все по прежнему работает правильно<br>
	 */ <br>
<br>
	 int s[100];   /* Массив из 100 элементов типа int */<br>
<br>
	 int *p = &s[0]; /* Указатель на нулевой элемент массива */<br>
	 *(p+10)='l';	  /* Изменяем десятый элемент */<br>
<br>
         /* "перенацеливаем" указатель  на первый  элемент */<br>
	 p++;<br>
<br>
	 *(p+10) = 'k';  /* Меняем  11 элемент  */<br>
<br>
	 /* Проверяем содержимое нулевого элемента */<br>
	 if ( *(p-1) )<br>
	 &nbsp;&nbsp;...;<br>
</div>

Это и есть основная идея арифметики указателей (pointer arithmetic) -
добавляя (или вычитая) к указателю  какого-то типа число, мы тем самым
сдвигаем его на такое число элементов этого типа.

</p><p>

А чтобы  еще облегчить жизнь программистов,  С/С++ допускает некоторую
взаимозаменяемость  массивов и  указателей (довольно  большую,  на мой
взгляд). Так,  если у нас есть массив и указатель типа int

<div class="incode">
	int s[100];<br>
	int *p;<br>
</div>

то мы можем использовать их следующим образом

<div class="incode">
	p = s;	      /* То же, что и p=&s[0]     */<br>
<br>
	p[10]=1;      /* То же, что и *(p+10)=1 или s[10]=1 */<br>
<br>
	*s = 2;       /* То же, что и s[0]=2   */<br>
<br>
	*(s+10)=0;    /* То же, что и s[10]=0 */<br>
</div>

Разумеется,  это будет работать  не только  для <em>int</em>,  
но и  для других
типов.

</p><p>

Вот почему  на прошлом занятии я  говорил, что при  передаче массива в
функцию на самом деле передается адрес его первого элемента - ситуация
там такая же, как в первой строке - мы просто пишем <em>s</em> 
вместо <em>&s[0]</em>.

</p><p>

Кстати, часто возникают случаи,  когда функция ожидает указателя, а ей
хочется передать массив,  или наоборот. И благодаря взаимозаменяемости
указателей и  массивов сделать  это удается без  лишних хлопот,  как в
таком примере:

<div class="incode">
	 #include &lt;stdio.h><br>
<br>
	 void print1(char s[]) {<br>
	 &nbsp;&nbsp;printf(s);<br>
	 }<br>
<br>
	 void print2(char *s) {<br>
	 &nbsp;&nbsp;printf(s);<br>
	 }<br>
<br>
	 int main() {<br>
	 &nbsp;&nbsp;char str1[]="hello\n";<br>
	 &nbsp;&nbsp;char *str2="hello\n";<br>
	 &nbsp;&nbsp;print1(str2);<br>
	 &nbsp;&nbsp;print2(str1);<br>
	 &nbsp;&nbsp;return 0;<br>
	 }<br>
</div>


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="differ"></a>
	 В чем разница между массивами и указателями?</h2>
<p>

Ну, с тем общим, что есть у  массивов и указателей, мы разобрались. А
чем они все-таки отличаются друг от друга?

</p><p>

Во первых, вы не можете "двигать" начало массива - адрес его нулевого
элемента. А вот указатель - сколько угодно: 

<div class="incode">
	  char s[]="Hello, world";<br>
	  char *p;<br>
	  p=s;<br>
<br>
<br>
	  /* Ошибка! Адрес массива  менять нельзя */<br>
	  s+=10;<br>
<br>
	  /* А вот указатель менять можно */<br>
	  p+=10;<br>
</div>

Во вторых,  если вы  создали массив, вы  можете быть уверены,  что под
него отведена память (иными  словами, у него есть элементы). Указатель
же  в  этом смысле  -  некий полуфабрикат,  и  его  нужно еще  куда-то
нацелить либо инициализацией, либо присваиванием:

<div class="incode">
	 int s[10];<br>
	 int *p;<br>
<br>
	 /* Все в порядке, у s есть элементы */<br>
	 s[0] = 0;<br>
<br>
	 /* Плохо. p еще никуда не показывает */<br>
	 p[0] = 0;<br>
<br>
	 <br>
	 /* А так можно, p указывает на s[0] */ <br>
	 p=s;<br>
	 p[0] = 0;<br>
</div>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="arithm"></a>Арифметика указателей.</h2>
<p>

Теперь давайте  еще немного посмотрим на  арифметику указателей. Сразу
скажу, что с указателями мы будем встречаться еще не раз - будет время
привыкнуть  к ним.   Так что  я  не собираюсь  сейчас перегружать  вас
деталями  и тонкостями  работы с  ними. Хочу  лишь  привести несколько
самых распространенных идиом языка С, касающихся работы с указателями.

</p><p>

Будем считать,  что у нас есть  указатель p, который  нацелен на некий
элемент массива такого же типа.

</p><p>

Помимо того,  что я уже  вам показывал, в арифметике  указателей часто
используются операторы инкремента  и декремента. Чтобы просто сдвинуть
указатель на один  элемент, вы можете с равным  успехом пользоваться и
постфиксной, и префиксной формами инкремента и декремента:

<div class="incode">
	 p++; /* Сдвинули указатель на один элемент вперед */<br>
	 --p; /* А теперь на один элемент назад */<br>
</div>

Однако благодаря приоритетам и асоциативности операторов ++, -- и *, мы
можем  совместить  доступ к  элементу  и  смещение  указателя в  одном
выражении.  И при  этом префиксная  и постфиксная  формы  будут делать
разные вещи:

<div class="incode">
         /* <br>
	 &nbsp;&nbsp;Число 8 засылается в текущий элемент. После этого  указатель<br>
	 &nbsp;&nbsp;сдвигается на следующий элемент.<br>
	 */<br>
	 *p++=8;	 <br>
<br>
         /* <br>
	 &nbsp;&nbsp;Число 8 засылается в текущий элемент. После этого  указатель<br>
	 &nbsp;&nbsp;сдвигается на предыдущий элемент.<br>
	 */<br>
	 *p--=8;	 <br>
<br>
         /* <br>
	 &nbsp;&nbsp;Сначала указатель сдвигается на  следующий элемент.<br>
	 &nbsp;&nbsp;После этого в этот следующий элемент засылается число 8.<br>
	 */<br>
	 *++p=8;	 <br>
<br>
         /* <br>
	 &nbsp;&nbsp;Сначала указатель сдвигается на  предыдущий элемент.<br>
	 &nbsp;&nbsp;После этого в этот предыдущий элемент засылается число 8.<br>
	 */<br>
	 *--p=8;	 <br>
<br>
<br>
	 /* <br>
	 &nbsp;&nbsp;А вот так надо писать, если мы хотим поменять не<br>
	 &nbsp;&nbsp;указатель, а ту переменную, на которую он указывает<br>
	 */<br>
<br>
	 (*p)++;<br>
	 (*p)--;<br>
	 --*p;<br>
	 ++*p;<br>
</div>

Плюс  к  этому,  полезно  еще  бывает вычислить  разницу  между  двумя
указателями - при этом вы получаете число элементов массива между ними
(разумеется, чтобы у вас  получился осмысленный результат, надо, чтобы
оба  указателя  указывали на  элементы  одного  массива). В  очередном
примере таким образом вычисляется длина строки:

<div class="incode">
         char s[]="Hello";<br>
	 char *p=s;<br>
	 <br>
	 /* Увеличиваем p, пока не дойдем до нулевого байта */<br>
	 while (*p++);<br>
<br>
	 i = p - s - 1;<br>
<br>
	 printf("Длина строки s %d симолов\n",i);<br>
</div>

Указатели  можно сравнивать с  помощью операторов  отношения. Наиболее
часто это проверки == или !=, но можно встретить и другие:

<div class="incode">
         int *p1, *p2;<br>
	 ...<br>
	 if (p1!=p2)<br>
	 &nbsp;&nbsp;...;<br>
<br>
	 if (p1&lt;p2)<br>
	 &nbsp;&nbsp;...;<br>
	 else if (p1==p2)<br>
	 &nbsp;&nbsp;...;<br>
	 else /* p1>p2 */<br>
	 &nbsp;&nbsp;...;<br>
</div>

И, наконец (хотя это впрямую  и не относится к арифметике указателей),
значения указателей  можно засылать  с помощью оператора  приведения в
переменные  интегрального типа и  наоборот.  Такое  приходится делать,
если вам  понадобилось работать  с адресом, содержащимся  в указателе,
как с обычным числом:

<div class="incode">
    unsigned long VGA_BASE= 0xA0000;<br>
<br>
    char *p = (char*) VGA_BASE;<br>
<br>
    unsigned long addr;<br>
<br>
    p[0] = 1; /* Меняем байт по адресу 0xA0000 */<br>
<br>
    addr=(unsigned long)p; /* Засылаем p в переменную addr */<br>
</div>


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="multidim"></a>
	   Многомерные массивы, массивы указателей и т.п.</h2>
<p>


Пока  мы использовали  только одномерные  (с одним  индексом) массивы.
С/С++ позволяют работать  с массивами любой размерности, и  все, что я
говорил  вам  про арифметику  указателей  и  их  родство с  массивами,
справедливо и  в многомерном случае.  Однако случай  тут посложнее, и,
чтобы  правильно  многомерными   массивами  пользоваться,  нужно  ясно
представлять себе,  как они устроены.  Попытаюсь вам  это объяснить на
примере  двумерного  массива  (осознав  идею, вы  справитесь  с  любым
количеством размерностей). Начнем с простого.

</p><p>

Для того, чтобы создать двумерный массив, вам придется использовть два
набора квадратных скобок:

<div class="incode">
       /* Двумерный массив элементов double */<br>
       double m[2][4];<br>
</div>

Про такой массив  говорят, что у него 2 строки по  4 элемента в каждой
(именно про двумерные  еще говорят 2 строки, 4  столбца). Оба индекса,
как  и в  одномерных, начинаются  с  нуля, не  с единицы.  То есть,  в
массиве m у нас  есть строки 0 и 1, в каждой  из которых есть элементы
0..3.

</p><p>

Массив  этот также  можно  явно инициализировать  прямо при  создании,
опять таки, заключая списки  значений для строк в дополнительный набор
фигурных скобок:

<div class="incode">
       double  m[2][4] = <br>
       { <br>
       &nbsp;&nbsp;{ 1, 2, 3, 4 },<br>
       &nbsp;&nbsp;{-1, 1, 0, 0 } <br>
       };<br>
</div>

Как  и  в  случае  одномерных  массивов, вы  можете  задавать  не  все
значения, а только часть. Например, написав так

<div class="incode">
       double  m[2][4] = { { 1, 2 } };<br>
</div>

мы  инициализируем только нулевую  строку, да  и то  не всю,  а только
первые два ее элемента.

</p><p>

Как вы  помните, инициализируя одномерные массивы,  можно не указывать
размерность  - она  определится автоматически  по  количеству заданных
значений. С  многомерными массивами дело обстоит несколько  иначе - не
указывать  можно  только первую  размерность.   Вторая размерность  (и
прочие,  если их больше  двух) должна  быть указана.   Например, такая
запись

<div class="incode">
       double  m[][4] = { { 1, 2, 3, 4 }, {-1, 1, 0, 0 } };
</div>

приведет к созданию массива той же размерности 2x4.

</p><p>

Должен  сразу признаться  -  С позволяет  задавать  и линейный  список
инициализации многомерных массивов:

<div class="incode">
       double  m[][4] = { 1, 2, 3, 4 , -1, 1, 0, 0 };
</div>

Знать вам об  этом надо - можете встретить  в чьей-нибудь программе. А
вот использовать  эту возможность  я вам настоятельно  не советую  - и
читать такую запись труднее, и ошибку в программе сделать легче.

</p><p>

Что касается использования элементов  массива в программе - работать с
ними по-прежнему можно, как с обычными переменными:

<div class="incode">
     double m[2][4];<br>
     int i, j;<br>
     double *p;<br>
<br>
     for (i=0; i&lt;2; i++)<br>
     &nbsp;&nbsp;m[i][j] = i*0.01;<br>
<br>
     p = &m[1][0];<br>
</div>


Если вы  хотите испольовать такой массив в  качестве параметра функции
целиком,  это  тоже  можно  сделать.  И  при  этом,  как  и  в  случае
инициализации, в  объявлении и определении функции  можно не указывать
первую размерность. Правда, функции надо как то сообщить, какой именно
размер ей передан в каждом конкретном случае вместо "недостающего":

<div class="incode">
       /* Такая функция может работать только с массивами 2x4 */<br>
       double sum2x4(double arr[2][4]) {<br>
       &nbsp;&nbsp;int i,j;<br>
       &nbsp;&nbsp;double s;<br>
       &nbsp;&nbsp;for (i=0, s=0; i&lt;2; i++)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;for (j=0; j&lt;4; j++)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s+=arr[i][j];<br>
       &nbsp;&nbsp;return s;<br>
       }<br>
<br>
       /* A у такой первый размер может быть любым */<br>
       double sum(int dim, double arr[][4]) {<br>
       &nbsp;&nbsp;int i,j;<br>
       &nbsp;&nbsp;double s;<br>
       &nbsp;&nbsp;for (i=0, s=0; i&lt;dim; i++)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;for (j=0; j&lt;4; j++)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s+=arr[i][j];<br>
       &nbsp;&nbsp;return s;<br>
       }<br>
<br>
       double  m[][4] = { { 1, 2, 3, 4 }, {-1, 1, 0, 0 } };<br>
<br>
       main() {<br>
<br>
       &nbsp;&nbsp;double s1, s2;<br>
       &nbsp;&nbsp;s1 = sum2x4(m);<br>
       &nbsp;&nbsp;s2 = sum(2, m);<br>
       &nbsp;&nbsp;printf("%g %g\n", s1, s2);<br>
       }<br>
</div>

А  вот  со  взаимозаменяемостью  укаазтелей и  массивов  дело  обстоит
сложнее.  Вы, как  и с  одномерными массивами,  можете  использовать с
равными успехом указатель. Вот только какого типа? В одномерном случае
мы вместо массива могли ставить указатель на тип его элемента. Если вы
попытаетесь проделать такое же в случае двумерного

<div class="incode">
	    double arr[2][4];<br>
	    double *p;<br>
	    p=arr;<br>
</div>

вы   получите  предупреждение  от   транслятора  и   неработающую  или
неправильно работающую  программу. И если  перевести предупреждение на
человеческий язык, окажется, что  у вашего указателя неправильный тип.
Я  говорил раньше,  что массив  можно заменять  указателем на  тип его
элемента.   Выходит,  у  нашего  двумерного массива  тип  элемента  не
<em>double</em>,  а какой-то  другой?   Так  и есть.   
И  именно поэтому  новые
размерности  указываются  в новых  наборах  квадратных скобочек.   Наш
массив  <em>arr</em> как  бы остался  одномерным.  Просто  его  элементы вместо
объектов типа  <em>doublе</em> тоже являются  массивами.  И мы,  если возникнет
такая  потребность,  можем их  даже  использовать как  самостоятельные
массивы:

<div class="incode">
	  double arr[2][4];<br>
	  double *p;<br>
	  p = arr[0]; /* указатель на нулевую строку */<br>
</div>

А раз так,  то оказывается, что тип элемента <em>arr</em> 
-  вовсе не <em>double</em>, а
массив из 4 <em>double</em>. То есть

<div class="incode">
       double (*parr)[4];
</div>

Обратите  внимание  - круглые  скобки  здесь  необходимы.  Если вы  их
уберете,  вы  вместо  указателя  на  массив  получите  массив  четырех
указателей.

</p><p>

Так  вот,   если  написать  такой,  правильный,   тип  указателя,  его
взаимозаменяемость с  массивом восстановится.

</p><p>

Если   у  вас   туман  в   голове   от  многомерных   массивов  -   не
расстраивайтесь. Для меня сейчас  важно, чтобы вы поняли основную идею
- это  мы с  вами работаем  с многомерными  массивами, а  транслятор с
одномерными  -  массивами,   массивами  массивов,  массивами  массивов
массивов  и так далее.  Если вы  это запомните,  то потом  вам гораздо
легче будет разобраться  по книге с деталями и  тонкостями.  К тому же
судя  по тем  программам, которые  я видел,  программисты предпочитают
работать не с многомерными массивами,  а с массивами указателей, или с
указателями  на указатели  - и  понять проще,  и во  многих отношениях
более удобно.  Попробую вам это продемонстрировать.

</p><p>

Если  вы помните,  текстовая  строка в  С  - это  одномерный массив  c
элементами  типа char,  который  заканчивается нулевым  байтом. И  эти
строки настолько популярны, что  для них даже предусмотрен специальный
способ инициализации:

<div class="incode">
       char str[] = "Hello";
</div>

Часто также подобную инициализацию используют прямо для указателей

<div class="incode">
      char *s = "Hello";
</div>

В  последнем случае  создается безымянный  массив с  нашей  строкой, а
потом в указатель заносится адрес этого массива.

</p><p>

В  обоих случаях  в  конец массива  автоматически добавляется  нулевой
байт, который  служит признаком конца строки. И  этот признак помогает
без  дополнительных  ухищрений   работать  с  массивами  разной  длины
(например,  передавать  разные  строки  одной  и той  же  функции,  не
указывая в  отдельном параметре их  длину). 

</p><p>

Все  вместе это  дает очень  удобный и  экономный (по  расходу памяти)
способ  работы  со  строками  любой  длины, и  именно  таким  способом
пользуются  функции стандартной  библиотеки.   Но здесь  речь идет  об
одиночных строках. А  как быть, если мы хотим  сохранить в массиве или
передать в функцию целый набор строк, например, страницу текста? Можно
использовать  двумерный  массив,  но   при  этом  мы  вынуждены  будем
зафиксировать   максимальную  длину   строки.   А  поскольку   заранее
неизвестно,  какие строки нам  попадутся, то  делать это  скорее всего
придется с большим запасом.

<div class="incode">
     #include &lt;stdio.h><br>
<br>
     void print_text(char text[][100]) {<br>
     &nbsp;&nbsp;int i;<br>
     &nbsp;&nbsp;for (i=0; i&lt;2; i++)<br>
     &nbsp;&nbsp;&nbsp;&nbsp;printf("%s",text[i]);<br>
     }<br>
<br>
     main() {<br>
     &nbsp;&nbsp;char s[][100] = { "Hello, " , "world\n" };<br>
     &nbsp;&nbsp;print_text(s);<br>
     &nbsp;&nbsp;return 0;<br>
    }<br>
</div>

Есть у такого способа и  другая неприятность. Обратите внимание - хотя
в  этом примере первая  размерность и  оставлена пустой,  сама функция
рассчитана на  печать только  двух строк.  Если  же число  строк может
быть разным,  то нам придется  как-то сообщать функции о  том, сколько
именно  строк ей  передали в  массиве.   Пустая строка  "" в  качестве
специального значения в  конце массива не спасет -  текст вполне может
содержать и пустые строки.

</p><p>

Оба этих неудобства можно обойти, работая не с двумерным массивом, а с
с массивом указателей на char:

<div class="incode">
     #include &lt;stdlib.h><br>
     #include &lt;stdio.h><br>
<br>
     void print_text(char *text[]) {<br>
     &nbsp;&nbsp;int i;<br>
     &nbsp;&nbsp;for (i=0; text[i] != NULL; i++)<br>
     &nbsp;&nbsp;&nbsp;&nbsp;printf("%s",text[i]);<br>
     }<br>
<br>
     main() {<br>
     &nbsp;&nbsp;char *s[] = { "Hello, " , "world\n", NULL };<br>
     &nbsp;&nbsp;print_text(s);<br>
     &nbsp;&nbsp;return 0;<br>
    }<br>
</div>

Мы теперь не указываем никаких  размеров - каждый указатель смотрит на
массив подходящего для его  строки размера. А конец массива указателей
мы смогли пометить специальным значением.  (Если кто не помнит, <em>NULL</em> 
- это  пустой указатель.  Я рассказывал  вам  об этом,  когда говорил  о
правилах  хорошего тона при  работе с  указателями). И  теперь функция
просто  печатает  строки  одна  за  другой,  пока  не  увидит  пустого
указателя.

</p><p>

А  иногда бывает  удобно  использовать даже  не  массив указателей,  а
указатель на указатель. Например,  если в программе надо предусмотреть
случай, когда у нас не то что  ни одной строки нет, а даже нет массива
для хранения этих строк:

<div class="incode">
     #include &lt;stdlib.h><br>
     #include &lt;stdio.h><br>
<br>
     void print_text(char **text) {<br>
     &nbsp;&nbsp;int i;<br>
     &nbsp;&nbsp;if (text == NULL) <br>
     &nbsp;&nbsp;&nbsp;&nbsp;printf("No text at all\n");<br>
     &nbsp;&nbsp;else {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;for (i=0; text[i] != NULL; i++)<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s",text[i]);<br>
     &nbsp;&nbsp;}<br>
     }<br>
<br>
     main() {<br>
     &nbsp;&nbsp;char *s[] = { "Hello, " , "world\n", NULL };<br>
     &nbsp;&nbsp;char **p = NULL;<br>
     &nbsp;&nbsp;print_text(s);<br>
     &nbsp;&nbsp;print_text(p);<br>
     &nbsp;&nbsp;return 0;<br>
    }<br>
</div>

Такая  программа, если  ей  по ошибке  передадут  <em>NULL</em> 
вместо  массива
строк, не сломается, а напечатает "No text at all".

</p><p>

Надеюсь,  что  я  смог   вам  объяснить,  почему  многие  программисты
предпочитают  работать с  массивами  указателей, а  не с  многомерными
массивами.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="main"></a>
	   "Настоящая" функция main()</h2>
<p>


И в  завершение этого  занятия я хочу,  наконец, показать вам,  как по
настоящему  выглядит объявление  функции <em>main()</em>  - теперь  вы  к этому
готовы.

</p><p>

Давайте сначала вспомним про <em>main()</em> то, о чем я уже говорил.

</p><p>

Во-первых,  это "выделенная"  функция.  Она  служит как  бы "мостиком"
между задачей  и операционной системой  - с нее  начинается выполнение
программы, а выход из <em>main()</em>  означает завершение задачи.  И поэтому в
отличие  от других  функций у  программиста гораздо  меньше  свободы в
выборе  ее возвращаемого значения  и параметров  - просто  потому, что
операционная система должна знать, как с этой функцией работать.

</p><p>

Во вторых, эта функция должна возвращать значение типа <em>int</em>

<div class="incode">
      int main() {<br>
      &nbsp;&nbsp;return 0;<br>
      }<br>
</div>

поскольку  по возвращенному  из <em>main()</em>  значению  операционная система
определяет, нормально  или с  ошибками отработала программа.  При этом
нулевое  значение  расценивается  системой, как  успешное  завершение,
ненулевое означает ошибку.

</p><p>

Вот,  пожалуй, и  все, что  я рассказывал  про <em>main()</em>.  До сих  пор мы
использовали  ее  только с  пустым  списком  параметров. Этот  вариант
вполне законный, но не единственный. Есть и другие. Вот один из них

<div class="incode">
      int main(int argc, char *argv[]);
 </div>

Как  видите,  первым  стоит  параметр  типа <em>int</em>.   Затем  идет  массив
указателей на <em>char</em>, то есть, набор строк. Что означают эти параметры и
как ими пользоваться?

</p><p>

Давайте вспомним какую-нибудь  команду операционной системы. Например,
команду <em>cd</em>. Если вы выполните эту команду без параметров

<div class="session">
	cd
</div>

то окажетесь в своем домашнем каталоге. Но вы можете также указать и
другой каталог

<div class="session">
       cd /usr/bin<br>
</div>

и  при этом команда  переместит вас  именно туда.   Команда <em>cd</em>  (как и
большинство  команд  в UNIX)  -  это  программа,  написанная на  C.  И
определяет она, как именно вы ее вызвали, именно при помощи параметров
функции  <em>main()</em>. Первый,  
целый, параметр  означает количество  строк во
втором параметре-массиве. А во втором лежат слова той команды, которой
вы  запустили программу.  Причем  в самом  начале,  в нулевой  строке,
хранится само имя команды, а  затем те параметры, которые вы в команде
задали. Так что, когда вы пишете

<div class="session">
	cd
</div>

в main() передаются: в  <em>argc</em> - 1, в <em>argv[0]</em> - "cd", 
в <em>argv[1]</em> - <em>NULL</em>.
Если же написать 

<div class="session">
        cd /usr/bin
</div>

то в  <em>argc</em> окажется  2, в <em>argv[0]</em>  - <em>"cd"</em>,  
в <em>argv[1]</em> -  <em>"/usr/bin"</em>, в
<em>argv[2]</em>  - <em>NULL</em>.  Как видите,  
второй параметр,  массив  указателей, в
полном  соответствии  с  правилами  хорошего тона  завершается  пустым
указателем <em>NULL</em>.  Так что  у <em>main()</em> есть  сразу 
два  способа определения
длины  этого массива  - либо  по <em>argc</em>,  либо по  специальному значению
<em>NULL</em>.

</p><p>

Чтобы было понятнее,  давайте напишем программу, которая распечатывает
значения <em>argc</em> и  <em>argv</em>, а 
потом посмотрим, что  она выводит. Назовем ее
<em>printargs.c</em>:

<div class="code">
          #include &lt;stdlib.h><br>
	  #include &lt;stdio.h><br>
<br>
	  int main(int argc, char *argv[]) {<br>
	  &nbsp;&nbsp;int i;<br>
<br>
	  &nbsp;&nbsp;printf("argc==%d\n", argc);<br>
<br>
	  &nbsp;&nbsp;for (i=0; i&lt;argc; i++)<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;printf("argv[%d] == %s\n", i, argv[i]);<br>
<br>
	  &nbsp;&nbsp;return 0;<br>
	  }<br>
</div>

Теперь <em>'make printargs'</em> и пробуем запустить:

<div class="session">
       ./printargs<br>
       argc==1<br>
       argv[0] == ./printargs<br>
<br>
       ./printargs hello<br>
       argc==2<br>
       argv[0] == ./printargs<br>
       argv[1] == hello<br>
<br>
       ./printargs hello world<br>
       argc==3<br>
       argv[0] == ./printargs<br>
       argv[1] == hello<br>
       argv[2] == world<br>
</div>

Вот и мы с вами написали команду для операционной системы.

</p><p>

Такой  набор параметров  для <em>main()</em>  используется чаще  всего.  
Нередко,
правда, вместо массива указателей используется указатель на указатель:

<div class="incode">
	  int main(int argc, char **argv)
</div>

но это  все тот же список слов  в команде, просто работают  с ним чуть
иначе.

</p><p>

Иногда  используется   еще  один  -  тоже  вполне   законный  -  набор
параметров:

<div class="incode">
	 int main(int argc, char *argv[], char *envp[]);
</div>

Как видите, первые  два параметра такие же, как и  раньше. Но при этом
появился еще один  массив строк. Дело в том,  что операционная система
держит кучу полезной информации  в так называемых переменных оболочки.
Например, написав

<div class="session">
	  echo $PATH
</div>

вы увидите содержимое переменной <em>PATH</em> - пути, в котором система ищет
команды для запуска. А команда 

<div class="session">
	  printenv
</div>

распечатает вам  содержимое всех  переменных. Так вот,  через параметр
<em>envp</em>  функция <em>main()</em>  может прочесть  
переменные среды.  Правда, аналога
<em>argc</em> для  этого массива нет,  так что сколько  в нем строк  вы сможете
определить только по завершающему его <em>NULL</em>.

</p><p>

В качестве  упражнения предлагаю вам  подправить программу <em>printargs.c</em>
таким образом,  чтобы она печатала  не только параметры команды,  но и
переменные оболочки.

</p>
<br><br><br>
<p>
На этом  мы занятие закончим.  На следующем буду рассказывать  вам про
динамическую память.

</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>
