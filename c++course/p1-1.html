<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 1</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 1</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li><a href="p1-1.html#intro">Введение</a>
	<ul>
          <li><a href="p1-1.html#objective">
	        Чему именно мы будем учиться?<br>
	        На что можно рассчитывать к концу курса?
	      </a>
          <li><a href="p1-1.html#notdiscussed">О чем мы НЕ будем говорить</a>
          <li><a href="p1-1.html#steps">Как я поделил материал курса</a>
          <li><a href="p1-1.html#lit">Какие книги читать?</a>
          <li><a href="p1-1.html#plan">План курса</a>
          <li><a href="p1-1.html#history">
	         Эволюция языков программирования.<br> 
		 История создания С++.
	      </a>
	</ul>
        <li><a href="p1-1.html#c_start">Начинаем знакомство с C</a>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="intro"></a>Введение</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
<p>

На мой взгляд,  изучать С++, да и любой  другой язык программирования,
только  по  книге -  пустая  трата  времени.  Если вы  хотите  достичь
ненулевого результата, вам определенно понадобится практика. Так что я
рассчитываю,  что   время  от  времени  вы   будете  делать  кое-какие
упражнения за компьютером.

</p><p>

Для этого вам понадобится три вещи:

<ul>

   <li> Сам компьютер с какой-нибудь операционной системой.
   <li> Текстовый редактор - набирать текст программ.
   <li> С и С++ трансляторы - транслировать ваши программы.
</ul>

И, разумеется, вам для этого понадобится время, желание и терпение.

</p><p>

Я  думаю,  что любого  современного  С  и  С++ транслятора  вам  будет
достаточно для работы.

</p><p>

Лично я использую gcc и g++ под операционной системой FreeBSD, так что
команды, которые  я буду приводить  по ходу занятий,  будут относиться
именно  к  этой  связке  транслятор-ОС. Если  вы  будете  пользоваться
другими  трансляторами  или системами,  вам  придется выяснить,  какие
именно команды нужно набирать в вашем случае.

</p><p>

Сразу скажу,  что я  изучал С++ много  лет назад. Фактически,  когда я
активно на  нем работал, это  был несколько иной  язык. Он еще  не был
стандартизован, в  нем не было  стандартной библиотеки в  ее нынешнем,
законченном   виде,  не   было  RTTI   (информации  о   типах  времени
исполнения),  отсутствовали namespaces (пространства  имен). Поддержка
исключений и  щаблонов была бедной  и нестабильной, по крайней  мере в
доступных  мне трансляторах. Так  что в  моем практическом  опыте есть
серьезные  пробелы.   Тем  не  менее,  я думаю,  что  смогу  дать  вам
представление и об этих возможностях языка.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="objective"></a>
	   Чему именно мы будем учиться?<br>
	   На что можно рассчитывать к концу курса?
	 </h2>
<p>

Когда  я  примеривался,  как  построить  этот курс,  я  держал  в  уме
некоторые временные ограничения. А  именно, моей целью было умять весь
материал  (довольно  объемный,  надо  заметить)  приблизительно  в  20
занятий  - из расчета  одно занятие  в  неделю минус  зимняя сессия  и
каникулы.

</p><p>

Вряд ли  этого хватит, чтобы сделать  из вас мастеров С++  или хотя бы
добротных программистов. Однако я  думаю, что этого вполне достаточно,
чтобы  дать вам  крепкий фундамент  в понимании  основных  концепций и
возможностей  языка.   Надеюсь, что  после  этого  курса  вы будете  в
состоянии писать  пусть и не очень сложные,  но вполне работоспособные
программы.   Вы станете понимать  С++, а  значит, сможете  читать код,
написанный другими людьми. И что самое главное, зная основы, вы будете
в  состоянии и  дальше совершенствоваться  в  этой области  - уже  без
посторонней помощи.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="notdiscussed"></a>
             О чем мы НЕ будем говорить
	 </h2>
<p>

Как  правило,  люди, начинающие  изучать  какой-то язык,  операционную
систему  и  т.п.,  что-то  об  изучаемом предмете  слышали,  но  не  в
состоянии провести  границу между ним и "смежными"  областями, к этому
предмету  не относящимися.  Поясню на  примере. Мне  часто приходилось
слышать вопросы вроде "как  на С++ нарисовать прямоугольник?" или "как
на С++ прочесть один символ  с клавиатуры?". Первое делается с помощью
графических библиотек,  второе зависит  от операционной системы.  И ни
то, ни другое не относится к С++.

</p><p>

Так  вот,  я  постараюсь  в  рамках  курса  ограничиться  стандартными
средствами  языка,  а  не  изучать  навороты  какой-нибудь  конкретной
реализации, пусть  даже очень  популярной. Так что  не ждите  от наших
занятий ни работы  с графикой, ни изучения возможностей  СERN ROOT, ни
знакомства с библиотеками численного анализа - мы постараемся говорить
только  о  том, что  есть  (во всяком  случае,  должно  быть) в  любом
современном трансляторе С++.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="steps"></a>
	     Как я поделил материал курса
	 </h2>
<p>

Надо сказать,  что С++  вырос из  С. Масса программ  на С  без проблем
транслируется С++-трансляторами. И  такая совместимость была внесена в
язык преднамеренно. Можно даже сказать, что в какой то степени С++ это
"расширенный"  С.   Однако  его  объектно-ориентированные  возможности
подразумевают   совершенно    иную   по   сравнению    с   С   технику
программирования. Существует  даже расхожее мнение,  что для успешного
изучения С++ надо сначала забыть С (если вы его знали).

</p><p>

Несмотря на  это, я думаю, что  разумно разделить изучение  С++ на две
фазы - сначала изучить то общее, что есть и в С, и в С++, и лишь потом
переходить к более сложным и мощным возможностям языка. Почему? Просто
потому, что лучше иметь представление о двух языках, чем об одном.  С
сам по  себе очень мощный и  популярный язык, и нередко  это лучший по
сравнению с С++ выбор (а порой и единственно возможный).

</p><p>

К сожалению,  для того,  чтобы полностью разделить  эти две  фазы, нам
понадобилось бы  гораздо больше времени  - фактически это были  бы два
курса  вместо одного.  Но все  таки я  попытаюсь где  возможно сделать
такое разделение, или  по крайней мере буду обращать  ваше внимание на
те места, где С++ расходится с С.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="lit"></a>
	     Какие книги читать?
	 </h2>
<p>

И  по С++,  и по  С  написана масса  хороших книг.   Мне больше  всего
нравится  книга   Бьярне  Страуструпа  (как  его   фамилию  только  не
переводят)  "Язык  программирования  С++.  Третье  издание".   Кстати,
Страуструп - автор С++.  Для тех, кто захочет почитать что-нибудь и по
С,  наилучшим выбором безусловно  будет книга  Кернигана и  Ричи "Язык
программирования С" (эта тоже  написана авторами языка). Обе эти книги
переведены на русский.

</p><p>

В книге  Страуструпа рассмотрены все  концепции С++, есть в  ней также
описание     стандартной    библиотеки    и     раздел,    посвященный
объектно-ориентированному проектированию программ.  Правда, должен вас
предупредить - ее  не назовешь легким чтивом.  Так  что если вам будет
трудно ее читать, попробуйте подобрать что-нибудь попроще. Что именно,
советовать  не  буду (просто  не  знаю),  но  дам пару  рецептов,  как
подобрать хорошую книгу.

</p><p>

<ul>
   <li> Прежде всего  проверьте, что кгига содержит  описание всех ключевых
   возможностей  языка.  В  ней  должны  быть  рассмотрены  перегрузка
   (overloading)   функций    и   операторов,   классы,   наследование
   (inheritance),   шаблоны   (templates),  исключения   (exceptions),
   пространства имен (namespaces),  обязательно должен быть раздел про
   стандартную библиотеку.

   <li> Избегайте  книг, название  которых начинается  с  чего-нибудь вроде
   "Turbo-C++",  "Visual-C++",  "Еще-какой-нибудь-С++"  - такие  книги
   обычно рассказывают  не о самом языке, а  о конкретном трансляторе,
   загружая читателя ненужными деталями реализации.

   <li> Я бы не  советовал книги из серии "ВСЕ-ЧТО-УГОДНО  за 3 недели (или
   за 14 дней)".  Такие книги обычно любит выпускать издательство Sams
   Publishing.   Те их  книги, которые  я читал,  мне  не понравились.
   Правда, может  быть, это  вопрос вкуса, и  вы будете в  восторге от
   них?

   <li> Если вы хорошо читаете  по английски, лучше пользоваться книгами на
   английском, а не переводами  - меньше проблем будет с терминологией
   и привнесенными переводчиком и издателем ошибками.

   <li> Не  используйте слишком  активно web-ресурсы,  по крайней  мере, на
   первых порах.  Разумеется, там можно  найти все что угодно.  Но для
   того, чтобы  понять, насколько  хорош и достоверен  источник, нужно
   уже иметь хотя бы минимальное знание языка.

</ul>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="plan"></a>
	     План курса
	 </h2>
<p>

Как я уже сказал,  курс разбит на две части - С  и С++, по семестру на
каждую.  В прошлом  году это  было 10  и 9  занятий  соответсвенно (не
считая практических). Что получится в этом году - посмотрим.

</p><p>

В прошлом году я выкладывал  очередную лекцию на web по мере написания
(обычно  во  время   занятия).  В  этом  году  на   web  доступны  все
лекции. Никто  не запрещает вам забегать вперед.  Однако я рассчитываю
дорабатывать лекции по  ходу дела, так что к  конце года их содержимое
будет несколько отличаться от нынешнего.

</p><p>

Вот примерный  список того, с  чем мы будем знакомиться  целый учебный
год.

<ol>

  <li> Введение (мы с вами сейчас здесь)
  <li> C-подмножество
  <li> C++
 
</ol>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="history"></a>
	         Эволюция языков программирования.<br> 
		 История создания С++.
	 </h2>
<p>
По  мере  развития  компьютеров  (память,  быстродействие)  возможными
становились  все более  длинные и  сложные  программы.  Соответственно
развивалась техника  написания программ и появлялись  все новые языки,
поддерживающие  новые  стили   программирования.  Изложу  свою  версию
происходившего.

</p><p>

Самые первые  программы писали в машинных кодах.  Данные и инструкции,
их обрабатывающие составляли единый массив программы. Примерно на этом
же  уровне  развития стоят  и  ассемблеры  -  программа на  ассемблере
отличается  от программы  в кодах  в основном  заменой  числовых кодов
машинных команд на символьные названия инструкций.

</p><p>

Однако  на ассемблере  длинную программу  написать  непросто.  Поэтому
довольно быстро  появились языки программирования высокого  уровня - в
них   каждый  оператор,   написанный  программистом,   при  исполнении
программы   заменялся   уже   целым   набором   машинных   инструкций.
Естественно,  чтобы  программы  на  языке  высокого  уровня  работали,
необходимо  сначала перевести операторы  языка во  все те  же машинные
инструкции.  Делается это  специальными программами - интерпретаторами
и  трансляторами.  Интерпретатор переводит  каждую строку  программы в
машинный код  прямо во время  ее работы, транслятор  сначала переводит
всю программу в код, и только после этого ее можно запустить.

</p><p>

Большим  преимуществом  языков  высокого   уровня  было  то,  что  они
позволяли в какой-то степени забыть о том, на  каком именно компьютере
программа исполняется. То есть, программы стали более переносимы.

</p><p>

Первые языки высокого уровня  были процедурными. Характерные примеры -
Фортран,  Алгол.   Основой  процедурного стиля  программирования  было
вынесение необходимых алгоритмов  в отдельные процедуры (или функции).
При работе программы  эти процедуры вызывались с тем  или иным набором
данных и возвращали результат. 

</p><p>

Когда процедурный  стиль программирования утвердился,  стало ясно, что
надо   заняться   данными.    Процедурные  языки   предлагали   весьма
ограниченный набор встроенных типов данных (характерный набор - целые,
вещественные, логические,  символьные) и довольно  бедные средства для
создания  сложных  типов  на  основе  встроенных  (массивы).   Поэтому
следующим шагом  было создание языков с  развитыми структурами данных.
Очень хороший пример  такого языка - Паскаль Вирта.   О том, насколько
назрела  потребность  в  подобных  языках,  говорит  история  Паскаля.
Изначально    написанный    как    язык   для    обучения    студентов
программированию,   он   очень    быстро   завоевал   популярность   у
программистов во всем мире.

</p><p>
 
Однако со  временем мир вырос и  из языков с  развитыми типами данных.
По   мере  роста  программ   все  актуальнее   становилось  "сокрытие"
информации.   В  самом  деле,  зачем программисту  знать,  как  именно
называется,  скажем, временный  массив, используемый  для перемножения
матриц.   Ему достаточно  знать название  процедуры и  ее  параметры -
другими словами,  интерфейс модуля.   А ненужные детали  только мешают
работать. И  вот появился "модульный" стиль  программирования и языки,
его  поддерживающие  (характерные  примеры  -  Модула,  ранние  версии
Турбо-паскаля).

</p><p>

Теперь несколько  слов о С. Этот  язык появился в  70х, одновременно с
операционной  системой  UNIX.   Его  создателям  нужен  был  мощный  и
эффективный язык  для системного  программирования, который к  тому же
был  бы хорошо  переносим. Именно  на  нем написан  код ОС  UNIX и  ее
многочисленных клонов.  Язык  оказался весьма удачным.  

</p><p>

Это  безусловно язык  высокого уровня,  и программистам  на  нем легко
работать,  но при  этом он  не жертвует  эффективностью -  по скорости
выполнения   программ  его,   пожалуй,  можно   сравнивать   только  с
ассемблерами.   К тому  же это  хорошо  переносимый язык  (как и  сама
система UNIX).  Трансляторы С  есть практически на любых архитекутрах,
причем  программы, написанные на  этом языке,  с успехом  работают при
переходе   с   одного   типа   компьютера  на   другой.    Есть   даже
кросс-трансляторы,   которые  позволяют   на  одном   типе  компьютера
подготовить  программу для  другого. С  поддерживает и  процедурный, и
модульный стили программирования, а  его возможности по части создания
составных типов  данных хотя и  не очень широки, но  вполне достаточны
для рещения любой задачи.  Поэтому  (а также потому, что это "рабочий"
язык весьма популярной сейчас системы UNIX), за 30 лет он не только не
устарел, но наоборот набирает популярность.

</p><p>

Теперь,   после  этого   отступления,  вернемся   к   эволюции  языков
программирования. Вполне естественно, что на модульных языках жизнь не
остановилась.   У процедур, структурированных  данных и  модулей, даже
когда  все эти  три  стиля используются  совместно  и корректно,  есть
большой  нелостаток.    Вся  эта  комбинация   несколько  искуственна.
Программист, использующий  какой-нибудь модуль, вполне  может передать
его  процедуре  данные,  рассчитанные  совсем на  другой  алгоритм.  И
результат, который он получит, вряд ли будет осмысленным.

</p><p>

Вот  тут-то на  сцену и  выходит объектно  ориентированный  стиль. Его
основная идея - сами данные лучше всего знают, какими алгоритмами себя
обрабатывать. Другими словами, тип в языке перестает быть просто типом
данных  - он уже  включает в  себя и  правильные алгоритмы,  которые с
этими данными  умеют работать. И  такой тип называется  объектом, либо
классом  -   в  разных  языках   по  разному.  Отсюда  и   название  -
объектно-ориентированное программирование.

</p><p>

Вот мы наконец и добрались до С++. Ранние версии этого языка появились
в  начале  80х (он  тогда  назывался  С  с классами).   Он  изначально
замышлялся автором как язык, основанный на С и включающий в себя С как
подмножество. Сделано это было по нескольким причинам: автору хотелось
сохранить гибкость, эффективность  и переносимость, характерные для С,
а также  облегчить переход на  него огромной армии  С-программистов (я
думаю,   что  заодно   он  хотел   и  поднять   шансы   С++  завоевать
популярность). Этот  язык поддерживает,  и судя по  росту популярности
(по  сравнению  с другими  ОО-языками),  хорошо поддерживает  объектно
ориентированный  стиль  программирования.   Он стандартизован,  причем
довольно давно, так что сейчас  для него уже есть хорошие трансляторы,
реализующие   стандарт.  Что  еще   очень  ценно   на  мой   взгляд  -
стандартизован  не только сам  язык, но  и библиотека  шаблонов (STL),
которая содержит заготовки для  различных типов данных и алгоритмы для
работы с ними (в  стандартной библиотеке содержатся не только шаблоны,
есть  там и  много других  полезных вещей,  но я  уж по  привычке буду
называть ее STL).

</p><p>

И  в заключение  - на  объектно-ориентированных языках  жизнь  тоже не
остановилась. Но это уже совсем другая история.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">

</p>

<br><br><br>

<hr align="center" width="50%">
<h1 align="center"><a name="c_start"></a>Начинаем знакомство с C</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
<p>

Для того, чтобы программа на С  или С++ заработала, ее нужно набрать в
каком-нибудь    редакторе,    затем    обработать    компилятором    -
оттранслировать,  и, наконец,  запустить.  Сам  текст программы  - его
принято называть исходным  кодом - записывают в файл  с расширением .с
(для  С-программ)   или  с  расширениями  <em>.С</em>,  
<em>.сс</em>,   <em>.сxx</em>,  <em>с++</em>  (для
С++-программ).  Примеры:  <em>first.c</em>,  <em>hello.c</em> -  
С-программы;  &nbsp;&nbsp;<em>myprog.C</em>,
<em>hello.cc</em> - C++-программы.

</p><p>

Теперь давайте посмотрим, как выглядит простейшая программа;

<div class="code">
       /* Самая первая программа на С-С++ - true.c */<br>
       int main()<br>
       {<br>
       &nbsp;&nbsp;return 0;<br>
       }<br>
</div>

попробуем ее странслировать и запустить:

<div class="session">
	  ~/c++course> make true<br>
	  cc -O -pipe   true.c  -o true<br>
	  ~/c++course> ./true<br>
	  ~/c++course><br>
</div>

Небольшое примечание -  <em>"~/c++course>"</em> - приглашение операционной
системы  (у  вас оно  может  выглядеть  иначе),  после которого  можно
вводить  команды.  Команда  "make&nbsp;true"  -  вызов  программы  
<em>make</em>  с
указанием собрать  программу <em>true</em>.  <em>make</em> хорош 
тем,  что по расширению
файла догадывается, какой именно транслятор вызвать. В нашем случае он
вызвал транслятор С - выполнил команду

<div class="session">
	 cc -O -pipe   true.c  -o true
</div>

Следующей командой мы запускаем собранную программу на выполнение:

<div class="session">
	~/c++course> ./true
</div>

Эта  программа   ничего  не  выводит   на  экран,  по   ее  завершении
операционная  система снова  выдает приглашение,  означающее,  что она
готова воспринимать новые команды:

<div class="session">
       ~/c++course>
</div>

Эта программа с тем же успехом может быть обработана и
С++-транслятором:

<div class="session">
	~/c++course> rm true<br>
	~/c++course> mv true.c true.C	<br>
	~/c++course> make true<br>
	c++  -O -pipe   true.C  -o true<br>
	~/c++course> ./true<br>
	~/c++course> <br>
</div>

Примечание:  первой командой  <em>'rm&nbsp;true'</em> мы  удаляем 
старую  собранную
программу. затем мы переименовываем исходный файл 
<em>'mv&nbsp;true.c&nbsp;true.C'</em>, подчеркивая, что это теперь 
С++-программа. И снова  вызываем  make,  который  на этот  раз  
обрабатывает  программу
транслятором С++ - <em>'c++&nbsp;-O&nbsp;-pipe&nbsp;true.C&nbsp;-o&nbsp;true'.

</p><p>

Ну вот -  первая программа уже работает, давайте  теперь посмотрим, из
чего она состоит.

</p><p>

Как вы, наверное, уже догадались, строчка

<div class="incode">
       /* Самая первая программа на С-С++ - true.c */
</div>

это комментарий. Транслятор его просто не замечает, и нужен он только
человеку, который будет жту программу читать. Все, что содержится
между "скобками" из пар символов /* и */, игнорируется транслятором.
Комментарий не обязательно должен умещаться в одну строку. Вы можете
написать, например, так:

<div class="incode">
	  /*<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;Самая первая программа на С.<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;Файл: - true.c<br>
	  */<br>
</div>

Между     "скобками"     комментария     можно    разместить     любой
текст.  Единственное,  чего  делать  не  следует  -  вставлять  внутрь
комментария пары символов /* */ - создавать вложенные комментарии.

</p><p>

Следующая после комментария строка выглядит так:

<div class="incode">
       int main()
</div>

Здесь мы объявляем функцию с именем <em>main</em>, которая 
возврашает результат
типа <em>int</em> (целое значение) и  не содержит аргументов - 
список в круглых
скобках пуст. Программа на С и С++, естественно, может содержать много
функций.  Но <em>main()</em>  -  специальная функция  -  именно она  вызывается
первой  при  запуске  программы,  а  когда  эта  функция  завершается,
программа заканчивает свою работу.

</p><p>

После <em>main()</em> идет заключенный в фигурные скобки единственный
исполняемый оператор программы:

<div class="incode">
	{<br>
	&nbsp;&nbsp;return 0;<br>
	}<br>
</div>

Этот  оператор  завершает   выполнение  функции  <em>main()</em>,  
возвращая  в
качестве  ее  результата значение  0.  Обратите  внимание  на точку  с
запятой после этого оператора - в С и С++ операторы должны разделяться
точкой с запятой.

</p><p>

Конструкция  из фигурных  скобок, в  которой стоит  <em>return</em>, 
называется
блоком  (иногда  ее  называют   составным  оператором).  В  ней  может
содержаться сколько угодно операторов, могут быть и другие - вложенные
- блоки. Нельзя только определять внутри блока  функции - ни в С, ни в
С++ вложенных функций нет. (Впрочем в классах С++ разрешено определять
функции внутри блоков, однако и там речь не идет о вложенных функциях,
просто такие функции приобретают специальное значение.)

</p><p>

Интересный вопрос - а зачем  нужно возвращать из <em>main()</em> 
значение, если
по ее завершении заканчивается и  программа? И эта программа ничего не
выводит?  Это значение  нужно операционной  системе чтобы  узнать, чем
закончилась  работа программы  -  можно заставить  систему по  разному
реагировать на разные результаты, или коды завершения.

</p><p>

Давайте  посмотрим это  на  примере.  Но  сначала  изготовим еще  одну
программу  - близнеца  первой, только  возвращать  она будет  не 0,  а
1. Заодно   поменяем   и  комментарий:   хотя   для  транслятора   это
безразлично.

<div class="code">
        /* Вторая программа на С-С++ - false.c */<br>
        int main()<br>
        {<br>
        &nbsp;&nbsp;return 1;<br>
        }<br>
</div>

Как и раньше, странслируем ее:

<div class="session">
        ~/c++course> make false<br>
        cc -O -pipe   false.c  -o false<br>
        ~/c++course><br>
</div>

А вот для запуска воспользуемся другой командой, точнее, комбинацией
команд: 

<div class="session">
        ~/c++course> ./true && echo OK<br>
        OK<br>
        ~/c++course> ./false && echo OK<br>
        ~/c++course> <br>
</div>

Как видите, в  таком контексте система по разному  реагирует на <em>true</em> 
и <em>false</em>,  стало быть,  она  обращает внимание  на  значение, 
которое  мы
возвращаем  из <em>main()</em>.  Так уж  сложилось, что  возврат 
значения  0 из
программы означает ее успешное  завершение, а любое ненулевое значение
сигнализирует о какой-нибудь ошибке.

</p><p>

Кстати, что вы думаете об  этих программах? Они вам показались слишком
простыми и бессмысленными? А между тем, обе они именно в таком виде (с
точностью  до комментариев)  присутствуют в  любой системе  UNIX, даже
названия  у них  такие  же -  <em>true</em>  и <em>false</em>.  И  используются они  при
написании сценариев (скриптов) для командных интерпретаторов.

</p><p>

Давайте писать  следующую программу. И пусть  эта программа что-нибудь
нам  напечатает. Сразу  должен  сказать, что  ни  в С,  ни  в С++  нет
операторов  ввода-вывода (как например,  <em>read</em>  и <em>write</em> 
в Фортране  или
Паскале).  Это  совсем  не  значит,  что в  С  и  С++  программировать
ввод-вывод  хлопотно  или   неудобно.  Просто  для  него  используются
стандартные  функции  и   библиотеки,  входящие  в  комплект  поставки
транслятора. А теперь - новая программа.

<div class="code">
             /* Программа, которая печатеат приветствие - hello.c */<br>
             #include &lt;stdio.h><br>
<br>
             int main()<br>
             {<br>
             &nbsp;&nbsp;printf("Hello, world\n");<br>
             &nbsp;&nbsp;return 0;<br>
             }<br>
</div>

Попробуем ее оттранслировать и запустить:

<div class="session">
        ~/c++course> make hello<br>
        cc -O -pipe   hello.c  -o hello<br>
        ~/c++course> ./hello<br>
        Hello, world<br>
        ~/c++course><br>
</div>

Итак эта программа в процессе работы напечатала нам сообщение

<div class="session">
        Hello, world
</div>

По  сравнению с первыми  двумя программами  здесь добавлены  всего две
строки - #include &lt;stdio.h> и printf("Hello, world\n"); Давайте
сначала обсудим вторую

</p><p>

<em>printf("Hello,&nbsp;world\n");</em>  - это  вызов  
функции  <em>printf</em>.  В  круглых
скобках перечислен  список аргументов, с  которыми функция вызывается.
В данном  случае мы вызвали  ее с единственным аргументом  - текстовой
строкой, заключенной в  кавычки.  Сам текст - дань  традициию, с такой
программы начинается и книга Кернигана, Ричи по С, и книга Страуструпа
по С++.

</p><p>

Функция <em>printf</em> - из стандартной библиотеки С.  
Передавать ей можно любое
количество  параметров, но  не меньше  одного, причем  первый параметр
обязательно  должен  быть   текстовой  строчкой.  При  вызове  функция
печатает строку, стоящую  первой, но не "один к  одному".  Если в этой
строке  встречаются специальные  комбинации  символов, начинающиеся  с
символа %  (процент), функция пытается подставить  вместо них значения
остальных  параметров,  с  которыми  она  была  вызвана.   Для  первой
комбинации используется  второй параметр, для  второй - третий,  и так
далее. Если кто-то знаком с Фортраном = это немного напоминает вывод с
помощью  операторов  print/format. Так,  для  печати текстовой  строки
используется комбинация %s, для печати отдельного символа - %c, целого
числа %d. Ту же строку с  помощью <em>printf</em> можно было бы вывести 
и таким способом (можете при желании проверить):

<div class="incode">
        printf("%s, worl%c\n", "Hello",'d');
</div>

Обратите  внимание, что  одиночный  символ (третий  параметр в  списке
вызова)  заключен не в  кавычки, а  в апострофы.  Ели бы  мы поставили
кавычки, функции был бы передан  не символ, а строка из одного символа
- вещи совершенно разные, как вы позже узнаете.

</p><p>

Теперь давайте поменяем одну букву в названии функции на заглавную:

<div class="incode">
       printf => Printf
</div>

и снова попытаемся странслировать программу.

<div class="session">
        ~/c++course> make hello<br>
        cc -O -pipe   hello.c  -o hello<br>
        /tmp/cc7xcZru.o: In function `main':<br>
        /tmp/cc7xcZru.o(.text+0xf): undefined reference to `Printf'<br>
        *** Error code 1<br>
<br>
        Stop in /home/ovg/c++course/html.<br>
        ~/c++course><br>
</div>

Что-то у нас многовато сообщений  на этот раз. Транслятор пытается нам
объяснить, что  он не смог отыскать  функцию <em>Printf</em>, и  
поэтому не смог
собрать программу.  Дело в  том, что и  для С,  и для С++  заглавная и
строчная  буква -  разные вещи,  так  что мы  теперь пытаемся  вызвать
функцию с  другим именем. Это может оказаться  особенно неприятным для
тех, кто  раньше работал  на языках, не  различающих регистр  букв (на
Паскале, например). Что  поделаешь, привыкайте писать идентификаторы и
имена функций единообразно.

</p><p>

Теперь давайте разберемся со строчкой

<div class="incode">
         #include &lt;stdio.h>
</div>

Эта  строка -  указание  транслятору (а  точнее, препроцессору)  перед
обработкой  программы  включить  в  указанное  место  текст  из  файла
<em>stdio.h</em>. Причем имя файла можно  заключать не только в угловые скобки,
но и в  кавычки - в первом случае транслятор  будет искать в известных
ему "стандартных" местах, во втором он сначала проверит, нет ли такого
файла в текущем каталоге, и  лишь потом перейдет к своему стандартному
списку.

</p><p>

Что в таких файлах может содержаться и какие есть ограничения на имена
файлов? Содержаться  там может все,  что угодно, ограничений  на имена
файлов  нет. Вы например,  с успехом  можете поступить  так: перенести
весь текст  программы hello.c в  файл test.bin, а в  
программе hello.c написать единственную строчку

<div class="incode">
        #include "test.bin"
</div>

Только не забудьте сначала поменять заглавную P в Printf на маленькую.
И такая программа с успехом странслируется.

</p><p>

Однако  из того, что  это работает,  еще не  следует, что  так следует
поступать.  Хотя запретов  на  подобные имена  файлов  (и на  подобное
деление программ)  нет, есть  устоявшиеся правила и  традиции, которые
помогают программистам разрабатывать программы и библиотеки и понимать
код друг друга. 

</p><p>

Такие  файлы  принято  именовать  файлами-заголовками  (header-files),
отсюда  и   стандартное  для  них   расширение  .h.  Впрочем,   в  С++
файлы-заголовки   нового   стиля    принято   именовать   вообще   без
расширений. И  выносить в них  принято часть, необходимую для  связи с
внешним миром - объявления констант и функций, определения новых типов
данных - одним словом, то, что принято называть интерфейсом библиотеки
или модуля.

</p><p>

Файл stdio.h содержит в  себе такой интерфейс для функций ввода-вывода
в  С-стиле. Если  бы  вы  захотели посчитать  синус,  вам бы  пришлось
включить файл math.h - интерфейс математических функций, и так далее.


</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>

