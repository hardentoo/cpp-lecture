<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 9</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h1 align="center">
	  часть 1, занятие 9
	</h1>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции<br><h1>Обзор стандартной библиотеки С.</h1></caption>
  <tr>
    <td>
        <ul>
          <li><a href="p1-9.html#errno">
	     Работа над ошибками - errno, strerror(), perror()</a>
	  <li>Потоки - буферизованный ввод-вывод.
	  <ul>
	    <li><a href="p1-9.html#streams">Общие сведения.</a>
	    <li><a href="p1-9.html#printf">Функции семейств printf и scanf.</a>
	    <li><a href="p1-9.html#fmtprintf">Форматная строка printf.</a>
	    <li><a href="p1-9.html#fmtscanf">Форматная строка scanf.</a>
	  </ul>
	  <li><a href="p1-9.html#signals">Работа с сигналами.</a>
	  <li><a href="p1-9.html#longjmp">Дальние переходы - &lt;setjmp.h>.</a>
       </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">

<br><br><br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h1><a name="errno"></a>Обзор стандартной библиотеки С.</h1>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Работа над ошибками - errno, strerror(), perror()</h2>
<p>

Многие функции стандартной библиотеки в случае ошибки возвращают некое
специальное (зависящее от конкретной  функции) значение - флаг ошибки.
Например, про  функцию <em>printf()</em> написано, 
что  она возвращает количество
переданных  в <em>stdout</em>  символов, либо,  в случае  ошибки, отрицательное
значение.  (О  том, что  такое  <em>stdout</em> и  <em>stderr</em>,  
мы  поговорим  чуть
ниже.  Пока  можете   считать,  что  вывод  идет  на   экран).   Но  в
возвращаемом значении  передается только  флаг ошибки. Как  быть, если
хочется узнать поточнее, что именно произошло?

</p><p>

Разработчики библиотеки предусмотрели  и такую возможность.  Для этого
каждой возможной  ошибке присвоены свой  номер и, с  помощью директивы
<em>#define</em>,  сивмолическое  имя,  а  в библиотеке  существует  глобальная
переменная  <em>errno</em>.   Если какая-то  функция  обнаруживает ошибку,  она
заносит    ее   номер    в    errno,   а    затем   возвращает    флаг
ошибки.  Соответственно, заметив  в программе  флаг ошибки,  вы можете
через <em>errno</em> получить более подробную информацию, например

<div class="code">
      /* Required for errno */<br>
      #include &lt;errno.h> <br>
<br>
      /* Required for fprintf */<br>
      #include &lt;stdio.h><br>
<br>
<br>
      main() {<br>
      &nbsp;&nbsp;if (printf("Hello, world\n") &lt; 0) {<br>
      &nbsp;&nbsp;/* Error occured */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (errno==ENOMEM)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"ENOMEM error occured\n");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;else<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Error number %d occured\n", errno);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;return 0;<br>
      }<br>
</div>

Многие  серьезные программы  так  и поступают  - анализируют  значение
<em>errno</em> и пытаются исправить ошибку  и повторить операцию. Но все-таки в
большинстве  программ такой  подробный  анализ не  требуется -  вполне
достаточно,  если программа  просто  напишет более  или менее  внятное
сообщение об ошибке. Для таких случаев предусмотрена функция <em>strerror</em>,
которая,  получив  в аргументе  код  ошибки,  возвращает указатель  на
строку  с   соответсвующим  этой  ошибке   сообщением,  которое  можно
напечатать:

<div class="code">
      /* Required for errno */<br>
      #include &lt;errno.h> <br>
<br>
      /* Required for strerror */<br>
      #include &lt;string.h><br>
<br>
      /* Required for fprintf */<br>
      #include &lt;stdio.h><br>
<br>
      main() { <br>
      &nbsp;&nbsp;if (printf("Hello, world\n") &lt; 0) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;/* Error occured */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;char *p = strerr(errno);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr," Error %s occured\n", p);<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;return 0;<br>
     }<br>
</div>

Но есть путь еще более простой - использовать функцию <em>perror()</em>. 
При этом
вам даже не понадобится <em>errno</em> - функция <em>perror()</em> 
сама прочитает значение
этой переменной. Пользоваться ей надо так:

<div class="code">
      /* Required for perror */<br>
      #include &lt;stdio.h><br>
<br>
      main() { <br>
      &nbsp;&nbsp;if (printf("Hello, world\n") &lt; 0) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;perror("printf returned error");<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;return 0;<br>
      }<br>
</div>

При этом  <em>perror()</em> выведет в  <em>stderr</em> 
сначала указанную нами  строку, а
потом,    после     двоеточия,    сообщение,    соответсвующее    коду
ошибки. Например,

<div class="session">
        printf returned error: Disc quota exceeded
</div>
 
Как  видите, совсем  просто. Правда,  <em>perror()</em>  только это  и умеет  -
выводить сообщение в <em>stderr</em>, но частенько и этого бывает достаточно.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	    <h2><a name="streams"></a>Потоки - буферизованный ввод-вывод.</h2>
            <h3>Общие сведения.</h3>
<p>

До сих пор  мы пользовались для ввода-вывода функциями  
<em>scanf()</em> и <em>printf()</em>
Обе они относятся к  семейству функций так называемого буферизованного
ввода-вывода. Слово "буферизованный" означает, что перед тем как дойти
по назначению (например, из <em>printf()</em> на экран, 
или с клавиаутры <em>в scanf()</em>),
информация  собирается  в большие  порции.  Делается  это потому,  что
работать с большими порциями информации выгоднее.

</p><p>

Мы  выводили  наши сообщения  только  на  экран,  а вводили  данные  с
клавиатуры. На самом деле, одна и  та же задача 
c помощью <em>printf()</em> может
прекрасно выводить и на экран

<div class="session">
        ./hello 
</div>

и в файл, если поставить после имени задачи знак переадресации выхода и
указать имя выходного файла

<div class="session">
        ./hello  > hello.result
</div>

То же касается и ввода с помощью <em>scanf()</em>, только надо переадресовать
входную информацию (знак &lt;):

<div class="session">
         ./hello<br>
         ./hello &lt; hello.input<br>
</div>

Можно проделать и то, и другое

<div class="session">
         ./hello &lt; hello.input > hello.result
</div>

и даже передать данные с выхода одной задачи на вход другой

<div class="session">
         ./hello | ./read_message
</div>

Все  это  приводились  командные  строки операционной  системы.   Сама
программа, будучи один раз собрана,  даже ничего не подозревает о том,
откуда поступают данные и  куда она выводит сообщения (такие программы
называются  программами с наивным  интерфейсом).  Во  всех приведенных
случаях программа  работает с так называемыми потоками  данных - берет
данные  из   стандартного  входного  потока  <em>stdin</em>,   а  передает  в
стандартный  поток  вывода  <em>stdout</em>.   Оба  этих  потока  открываются
(создаются) для задачи операционной системой - потому они и называются
стандартными. Из <em>stdin</em>  можно только читать данные, 
в  <em>stdout</em> - только
записывать.   Есть у  программы еще  один стандартный  поток  данных -
<em>stderr</em>,   предназначенный   специально  для   печати   "экстренной"
информации,  например, сообщений  об ошибках.   Правда,  чтобы вывести
сообщение  в него,  надо  воспользоваться функцией  <em>fprintf()</em> 
(еще  одна функция семейства <em>printf</em>):

<div class="incode">
          fprintf(stderr, "Error number %d\n", errno);
</div>

Этот поток также открывается  для задачи автоматически, и по умолчанию
сообщения и из <em>stdout</em>, и из  <em>stderr</em> 
попадают на одно и то же устройство
(например, на экран).  Однако это действительно другой поток данных, и
вы  можете  почувствовать  это,  запустив  программу  такой  командной
строкой

<div class="incode">
          ./some_program > result
</div>

При этом весь вывод от <em>printf()</em> пойдет  
в файл <em>result</em>. А вот все, что вы
выводили на stderr, по прежнему будет печататься на экране.

</p><p>

Программа может использовать для своих нужд и другие потоки, но только
<em>stdin</em>,  <em>stdout</em>  и <em>stderr</em>  
открываются  автоматически -  дополнительные
потоки  должна  открыть  сама  программа  (обычно  с  помощью  функции
<em>fopen()</em>). 

</p><p>

После  работы с  потоками их  надо закрывать  (для этого  есть функция
<em>fclose()</em>) -  иначе при выводе  
часть данных из незакрытого  потока может
потеряться, так и не попасть  из задачи в файл. Стандартные потоки для
вас закроет  операционная система по окончании  работы программы (если
только вы  специально не потребуете  оставить их открытыми).   Но если
программа сама открыла какой-то  поток, то она и должна самостоятельно
его закрыть.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h3><a name="printf"></a>Функции семейств printf и scanf.</h3>
<p>

Все функции  этой группы  предназначены для ввода/вывода  информации в
соответствии с указанной форматной строкой. Две вы уже знаете:

<div class="incode">
       scanf(char *formatstring, ...);<br>
       printf(char *formatstring, ...);<br>
</div>

Первая считывает данные из стандартного ввода <em>stdin</em>, а вторая -
выводит в стандартный вывод <em>stdout</em>.

</p><p>

Следующая пара - <em>fscanf()</em> и <em>fprintf()</em>. 
Работают так же, как первые
две, но им в первом аргументе надо указывать поток (тип переменной
потока - FILE*):

<div class="incode">
      fscanf(FILE *stream, char *formatstring, ...);<br>
      fprintf(FILE *stream, char *formatstring, ...);<br>
</div>

Например, 

<div class="incode">
      /* Выводим в stderr  */<br>
      fprintf(stderr, "Hello\n");<br>
<br>
      /* <br>
      &nbsp;&nbsp;Выводим в stdout, но используем не printf(), а fprintf<br>
      */<br>
      fprintf(stdout, "Hello\n");<br>
</div>

Есть очень полезная разновидность, которая пользуется не потоками, а
строками.

<div class="incode">
      sscanf(char *buffer, char *formatstring, ...);<br>
      sprintf(char *buffer, char *formatstring, ...);<br>
</div>

Например:

<div class="incode">
        char buf[64];<br>
        int i;<br>
<br>
        /* Выводим число 10 в буферную строку */<br>
        sprintf(buf, " %d\n", 10);<br>
        /* Теперь buf содержит текстовую строку " 10" */<br>
<br>
        <br>
        /* Читаем число из буферной строки в переменную */<br>
        sscanf(buf," %d", &i);<br>
        /* Теперь переменная i равна 10 */<br>
</div>

То, что я перечислил - не все представители семейства <em>scanf/printf</em>, 
но самые популярные.

</p><p>

Теперь  давайте  поговорим о  форматных  строках  для этого  семейства
функций.   Во всех  примерах дальше  я  использую <em>printf()</em>  
и <em>scanf()</em>,  но
правила разбора форматной строки одинаковы во всем семействе.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h3><a name="fmtprintf"></a>Форматная строка printf.</h3>
<p>

Как вы  помните, первый аргумент  функции <em>printf()</em> 
- это  так называемая
форматная  строка.  Функция  печатает   ее  содержимое,  но  при  этом
спецификации формата  (специальные комбинации символов) обрабатываются
особым образом. Встретив спецификацию, <em>printf()</em> вставляет в вывод свой
очередной аргумент, напечатанный в соответствии с предусмотренными для
этой  спецификации правилами,  а затем  продолжает  просмотр форматной
строки.

</p><p>

Спецификация    формата    начинается    с    <em>%</em>,    а    заканчивается
символом-спецификатором преобразования. Например, <em>%d</em> - вывод знакового
десятичного целого числа. Между  <em>%</em> и символом-спецификатором могут (но
не  обязательно)  стоять дополнительные  флаги.  Например, <em>%6d</em>  (здесь
число  6 -  флаг, который  указывает, что  при печати  под  число надо
отвести не меньше шести позицмй).

</p><p>

При работе  с любым транслятором  вы можете рассчитывать  на некоторый
"стандартный" набор  флагов и спецификаторов  форматной строки, однако
зачастую   в  трансляторах   присутствуют   и  расширения,   например,
дополнительные  флаги,  которые  позволяют  учитывать  растущие  нужды
программистов  и развитие  компьютеров.  Так  что, когда  вы начинаете
работать  с новым  транслятором, стоит  разок просмотреть  описание на
предмет особенностей форматной строки  в его библиотеке. На системе, в
которой мы работаем, такое описание можно получить, набрав команду

<div class="session">
        man 3 printf  
</div>

Теперь давйте посмотрим, какие бывают символы-спецификаторы и для
чего они служат.

<ul>
<li> Вывод целых чисел - %d, %i, %u, %o, %x, %X.

</p><p>

Со спецификатором <em>%d</em> вы уже знакомы 
- он выводит целое десятичное число
со знаком. То же самое делает <em>%i</em>.

</p><p>

<em>%u</em> тоже выводит  целое десятичное число, но беззнаковое  (в самый раз,
если вы хотите напечатать содержимое переменной типа 
<em>unsigned&nbsp;int</em>).

</p><p>

<em>%o</em> выводит беззнаковое целое в восмеричной форме. Например

<div class="incode">
   printf("%o\n", 64)
</div>

напечатает   вам  100   (десятичное  64   -  это   восьмеричное  число
100). Впрочем, сейчас восьмеричные  числа не очень популярны, больше в
ходу шестнадцатиричные.

</p><p>

<em>%x</em> и <em>%X</em> - эти выводят беззанковые шестнадцатиричные. Например

<div class="incode">
   printf("%x\n",15);
</div>

напечатает вам <em>f</em> (для цифр от 10 до 15 используются буквы 
от <em>a</em> до <em>f</em>
для <em>%x</em> и от <em>A</em> до <em>F</em> для формата <em>%X</em>). 

<br><br>

<li> Вывод чисел с плавающей запятой - %f, %e, %E, %g, %G

</p><p>

<em>%f</em>.  Этот  символ выводят  число  типа  double  в виде  [-]ddd.ddd  (в
квадратных  скобках здесь  и  дальше я  буду указывать  необязательную
(optional) часть строки - так принято). Например, оператор

<div class="incode">
      printf("%f\n",3.0e-1);
</div>

напечатает вам 0.300000.

</p><p>

<em>%e</em>, <em>%E</em>.  Эти выводят число 
типа <em>double</em> в виде [-]d.ddde+-dd (для <em>e</em>) или 
[-]d.dddE+-dd (для <em>E</em>). Например

<div class="incode">
      printf("%e %E\n", 0.000001, 3.1415);
</div>

печатает <em>1.000000e-06&nbsp;3.141500E+00</em>.

</p><p>

<em>%g</em>, <em>%G</em>. Эта спецификация самая удобная, 
если вы не заботитесь о красоте
вывода, а  просто хотите напечатать  число. Она сама за  вас подумает,
когда  использовать <em>%e</em>,  а когда  <em>%f</em>. Например,  
заменив  в предыдущем <em>printf()</em> <em>%e</em> на <em>%g</em>

<div class="incode">
      printf("%g %g\n",0.000001, 3.1415); 
</div>

вы получите <em>1e-06&nbsp;3.1415</em>.

</p><p>

А разница между <em>%g</em> и <em>%G</em> такая же, 
как между <em>%e</em> и <em>%E</em>.

<li> Символы и строки - %с и %s.

</p><p>

<em>%c</em> печатает  одиночный символ. 
Например,  <em>printf("%c",'%');</em> напечатает
символ <em>%</em>.

</p><p>

<em>%s</em> печатает C-строку - набор символов, заканчивающихся нулевым байтом.
Отсюда следует,  что вывести на  печать нулевой байт таким  образом не
удастся. А  вот любые  другие символы, если  они в строке  есть, будут
напечатаны.Так

<div class="incode">
   printf("%s","1 Hello, world\n2 Hello, world\n");
</div>

напечатает в нашем понимании не одну, а две строки:

<div class="session">
          1 Hello, world<br>
          2 Hello, world<br>
</div>

поскольку в нем стоят <em>\n</em> (символы перевода строки). 

<br><br>

<li> Печать процента -   <em>%%</em>

</p><p>

Эта спецификация  просто печатает символ <em>%</em>.  
Написать <em>printf("%%")</em> все
равно, что <em>printf("%c",'%')</em>.

<br><br>

<li> Печать указателей - <em>%p</em>

</p><p>

В  указателях, как  вы  помните,  хранятся адреса,  то  есть их  можно
рассматривать   как  целые  числа   достаточного  размера.   Если  вас
интересует, какой именно  адрес хранится в том или  ином указателе, вы
можете  напечатать его  значение (в  шестнадцатиричном виде)  с помощю
спецификации <em>%p</em>. Так, коротенькая программка

<div class="code">
    main() {<br>
    &nbsp;&nbsp;int i;<br>
    &nbsp;&nbsp;int *p = &i;<br>
    &nbsp;&nbsp;printf("%p\n",p);<br>
   }<br>
</div>

на моей машине напечатала шестнадцатиричное число <em>0xbfbfe938</em>.

<br><br>

<li> Длина результируюещей строки - <em>%n</em>.

</p><p>

Хотя это тоже спецификация для  форматной строки вывода, но она ничего
не выводит, скорее наоборот.  Встретив ее в форматной строке, <em>printf()</em>
записывает в очередной аргумент  (этот аргумент должен быть указателем
на <em>int</em>)  то количество  символов, которое он  уже напечатал  к данному
моменту. Например, в таком фрагменте

<div class="incode">
         int i, j;<br>
         i = 123;<br>
         printf("i=%d%n",i, &j);<br>
</div>

<em>printf()</em> напечатает строку i=123, а потом 
зашлет в переменную j число 5
- именно столько символов он к этому времени напечатал.

</ul>
</p><p>

Теперь перейдем к флагам. Флаги ставятся, как я уже говорил, между <em>%</em> и
символом-спецификатором. Перечислю их.

<ul>

<li> 'Ширина' (десятичное  число).   Пример:  <em>%3d&nbsp;&nbsp;%20s</em>

</p><p>

Этот  флаг   задает  минимальную  ширину   поля.  Слово  "минимальную"
означает, что все символы будут  напечатаны даже в том случае, если вы
по  ошибке  задали недостаточную  ширину.   (До  сих  пор помню  шутки
Фортрана -  указал при печати  таблицы недостаточную ширину  и получил
звездочки вместо цифр. Зато  таблица красивой осталась ...). Например,
если вы хотите напечатать красивую таблицу, вам понадобится, чтобы все
выводимые числа занимали одинаковое число позиций.  В этом случае надо
указать флаг-ширину поля.  Так, если  вы захотите напечатать числа 1 и
123 по спецификации %d %d, то получите

<div class="incode">
             '1 123'
</div>

А указав ширину, допустим, в 3 символа "%3d %3d", увидите 

<div class="incode">
             '&nbsp;&nbsp;1 123'
</div>

Как видите, во втором случае под печать 1 было отведено три позиции.

</p><p>

В  качестве  ширины  поля  можно   указать  не  число,  а  символ  '*'
(звездочка).  В этом случае  числовое значение  для ширины  поля будет
взято из очередного аргумента <em>printf</em>. Например
<em>printf("%*d\n", 3, 1);</em> напечатает '&nbsp;&nbsp;1',
а <em>printf("%*d\n", 1, 1);</em> -  '1',

</p><p>

Это  сделано для  того, чтобы  можно было  прямо при  работе программы
настраивать формат печати на "масштаб" выводимых данных.

<br><br>

<li> 'Ширина.точность' - точность вывода чисел. Пример: <em>%6.2f</em>

</p><p>

Когда при печати числа с  плавающей запятой вы указываете ширину поля,
эта  ширина расходуется  на  все  компоненты -  на  знак, сами  цифры,
десятичную точку, символ и цифры порядка. Указав после ширины с точкой
еще  одно число, вы  сообщите функции  <em>printf()</em> 
минимальное  число цифр,
которое должно быть напечатано после десятичной точки. (На самом деле,
этот флаг определен  еще и для печати целых чисел и  строк. И даже при
печати чисел с плавающей  запятой по разным спецификациям он действует
немного по  разному. Но на  эти тонкости у  нас нет времени.) Как  и в
случае ширины, во флаге точности вместо числа можно поставить '*', при
этом  соответсвующее  значение  будет  взято из  очередного  аргумента
<em>printf()</em>.

<br><br>

<li> '-' - выравнивание по левому краю. Примеры <em>%-3d&nbsp;%-3s</em>

</p><p>

По  умолчанию выводимые элементы  выравниваются по  правому краю  - то
есть, если вывод надо дополнить пробелами, то эти пробелы ставятся до,
а  не после  печатаемого поля.  Указав  флаг '-',  вы можете  добиться
выравнивания по левому краю. Сравните,  как выглядит печать числа 1 с
этим флагом и без него:

<div>
   %d    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;печатает&nbsp;'1'<br>
   %3d   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;печатает&nbsp;'&nbsp;&nbsp;1'<br>
   %-3d' &nbsp;&nbsp;&nbsp;печатает&nbsp;'1&nbsp;&nbsp;'<br>
</div>

<br><br>
   
<li> '+' - обязательно печатать знак. Пример <em>%+d</em>

</p><p>

По умолчанию знак печатается только у отрицательных чисел. Указав флаг
'+',  вы  заставите  <em>printf()</em>  
указывать  знак  и  перед  положительными
числами.

<br><br>

<li> ' ' (пробел) - печатать пробел перед числом. Пример: <em>%&nbsp;d</em>

</p><p>

Этот флаг печатает пробел перед числом, но только в том случае, если у
числа не печатается  знак. Например, напечатав 1 и  -1 по спецификации
"%&nbsp;d", вы  в первом сулчае получите  ' 1' (с пробелом), а  во втором -
'-1' (без пробела).

<br><br>

<li> 0 (нуль) - дополнение чисел нулями слева. Пример: <em>%03d</em>

</p><p>

Этот флаг указывает, что числа надо дополнять слева нулями до всей
ширины поля. Напечатав по спецификации  %03d 1 и -1, вы получите 001
и -01 соответственно.

<br><br>

<li> # - более подробный формат числа. Примеры <em>%#o</em> <em>%#x</em>

</p><p>

Этот флаг делает формат выводимого числа более информативным. Действие
его  зависит от  того, с  каким спецификатором  он указан.  При печати
восьмеричных   чисел   (<em>%#o</em>)    перед   числом   
печатается   0,   для
шестнадцатиричных  (<em>%#x</em> или  <em>%#X</em>) 
печатается  префикс <em>0x</em>  или  <em>0X</em>, для
чисел с плаваюшей запятой (<em>%#f</em> <em>%#e</em> <em>%#E</em> 
<em>%#g</em> <em>%#G</em>) обязательно печатается
десятичная  точка,  а для  спецификаций  <em>%g</em> и  <em>%G</em>  
кроме  точки еще  и
печатаются завершающие нули (без этого флага они были бы отброшены).

<br><br>

<li> h, l, L - модификаторы размера, Примеры - <em>%hd</em> <em>%Lg</em>

</p><p>

По умолчанию  <em>printf()</em> ожидает, 
что  передаваемые ему целые  числа имеют
такой же  размер, как <em>int</em>,  
а вещественные  - как double.  Флаги h  и l
сообщают  ему,  что  передается  число  размера  <em>short</em>  
или  <em>long</em>  <em>int</em>
соответственно, а флаг <em>L</em> говорит, 
что передается <em>long&nbsp;double</em>.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h3><a name="fmtscanf"></a>Форматная строка scanf</h3>

<p>

У  функции <em>scanf</em>  первый  аргумент -  тоже  форматная строка,  которая
определяет, что  делать с остальными  аргументами.  Но эта  функция не
печатает информацию,  а считывает ее,  так что и набор  спецификаций у
нее  несколько  иной,  и   в  обработке  форматной  строки  есть  свои
особенности. И к тому же  эта функция не очень приспособлена для того,
чтобы организовывать более или менее интелектуальный ввод данных. Даже
прочитать  в ней ровно  одну строку  - вместе  с пробелами,  до сивола
перевода   строки  -   непросто.   Так   что   программисты  частенько
предпочитают    пользоваться   чем-нибудь    другим    -   так    жить
проще.  Например, читают  целую строку  с помощью  другой библиотечной
функции, а потом уж из этой строки вытягивают то, что им нужно. Почему
так?

</p><p>

Давайте   разбираться,  что   означает  форматная   строка   в  случае
<em>scanf()</em>. Предстаьте, что вы написали

<div class="incode">
         printf("hello, world");
</div>

Тут все  ясно - программа  напечатает <em>'hello,&nbsp;world'</em>. 
А  что случится,
если такую же строку поставить в <em>scanf()</em>?

<div class="incode">
         scanf("hello, world");
</div>

Ведь  информация  для нее  поступает  извне  программы  - например,  с
терминала или из файла. А я вот возьму и наберу <em>'Goodbye'</em>. Как поведет
себя при  этом функция  <em>scanf()</em>? И куда  попадет та строка,  которую я
ввел? А  начинаешь со всем  этим разбираться - вопросов  только больше
становится. Так  что эта функция хороша  лишь в том  случае, когда вам
надо  прочитать  что-то  по  хорошо  известному  формату  -  например,
таблицу, подготовленную другой программой.

</p><p>

Ну   вот,  после  этого   пессимистичного  вступления   давайте  бегло
посмотрим, как надо работать и что можно делать с помощью <em>scanf()</em>.
И для начала вот несколько правил работы с этой функцией.

<ul>

<li> Правило  первое.  Прежде  всего,  надо  помнить, 
что  в  <em>scanf()</em>  надо
передавать не сами переменные, а их адреса (либо указатели)

<div class="incode">
            int i;<br>
            int *p = malloc(sizeof(int));<br>
            scanf("%d %d", &i, p);<br>
</div>

поскольку функция должна изменять  ваши переменные.

<br><br>

<li> Правило  второе.  Вводимые   данные  должны  соответсвовать  форматной
строке. Работает  эта функция  следующим образом: -  она просматривает
форматную строку по мере поступления входных данных, ожидая что формат
этих данных совпадает с  форматной строкой. При первом же несовпадении
она прекращает  прием данных из входного  потока.  Так что,  если вы в
программе написали

<div class="incode">
          scanf("i=%d",&i);
</div>

а на клавиатуре набрали

<div class="session">
          m=10
</div>

scanf  не   сможет  считать   с  клавиатуры  значение   переменной.  В
большинстве  случаев эта функция  требует точного  совпадения вводимой
информации  с  форматной  строкой.  Исключение составляют  пробелы  и,
разумеется, сами форматные спецификации.

<br><br>

<li> Правило  третье.  Пробел  в  форматной  строке  <em>scanf()</em>  
означает  любое
количество "пустого места".  Причем для <em>scanf()</em> 
"пустое место"  - это не
только пробелы  и табуляции (что вполне естественно),  но и, например,
перевод   строки   или   перевод   страницы  (что   поначалу   кажется
непривычным). Так, оператор

<div class="incode">
              scanf("%d %d", &i, &j);
</div>

с равным успехом считает значения переменных и из

<div><pre>
         '1 2'
</pre></div>

и из

<div><pre>
         '    1            2              '
</pre></div>
      
и даже из

<div><pre>
        '       1         '
        '                 '
        '              2  '
</pre></div>

В апострофах я привел то, что якобы набиралось на клавиатуре.

</p><p>

(На самом  деле ситуация  еще смешнее -  все три  приведенных варианта
ввода прекрасно можно прочитать  и форматной строкой <em>"%d%d"</em>. 
Для <em>scanf()</em>
пробелы-разделители  в  форматной строке  вообще  не  нужны.  Да и  во
входном  потоке  они требуются  только  тогда,  когда  без них  нельзя
отличить одно поле от другого.)

</ul>

</p><p>

Теперь перейдем к спецификациям. Устроены по тому же принципу, что и у
<em>printf()</em> (процент, флаги, сам спецификатор), но набор несколько иной.

<ul>

<li> %d, %i, %o, %u, %x. Смысл,  в общем, такой же, 
как и  для <em>printf()</em>. Но есть
одна   особенность.  Спецификация   <em>%i</em>  может   считывать   не  только
десятичные, но и восьмеричные и шестнадцатиричные числа. Различает она
их  по  первым  символам -  если  число  начинается  с 0  (нуля),  оно
считается восьмеричным, если с 0x или 0X - шестнадцатиричным.

<br><br>

<li> %c.  Ввод  символа. Можно также  вводить несколько символов,  задав их
количество во флаге ширины, но при этом соответсвующий аргумент должен
указывать на массив достаточного размера.

<br><br>

<li> %%. В  потоке ожидается символ  процента. При этом сам  сивол процента
никуда не пересылается, аргумент под эту спецификацию не нужен.

<br><br>

<li> %s. Ввод строки, не содержащей "пустого места" (пробелов, табуляций, и
т.п.). В конец строки будет добавлен символ '\0'.

<br><br>

<li> %e, %f, %g.  Ввод  чисел с плавающей запятой  любом допустимом формате
(эти спецификации в случае <em>scanf()</em> взаимозаменяемы). 
<b>ВАЖНОЕ ОТЛИЧИЕ</b> от
соответствующих спецификаций <em>printf()</em> - без флагов эта спецификация
соответсвует типу <em>float</em>, а не <em>double</em>.

<br><br>

<li>%p.   Эта   спецификация   позволяет   считать   значение   указателя,
напечатанного по такой же спецификации функцией <em>printf()</em>.

<br><br>

<li>%[...].  Это -  тоже спецификатор,  хотя и  не из  одного  символа. Он
выбирает  из  ввода  самую  длинную  строку,  состоящую  из  символов,
указанных в  квадратных скобках. Например, по  спецификации <em>%[012]</em> из
входного  потока 20005  будет прочитана  строка 2000.  Как и  <em>%s</em>, этот
спецификатор добавит '\0' в конец массива.

<br><br>

<li>%[^...].   Такой  спецификатор  выберет   самую  длинную   строку,  не
содержащую указанных символов.

<br><br>

<li>%n. Смысл такой  же, как и для <em>printf()</em> 
-  в соответсвующий аргумент будет
записано число символов, которое обработал <em>scanf()</em>, 
пока не встретил эту спецификацию.

<br><br>
</ul>

Что касается флагов, то их  поменьше, чем у <em>printf()</em>, 
поскольку <em>scanf()</em> во
многих  случаях настраивается на  формат вводимых  чисел автоматически
(как, например, при вводе по <em>%i</em>).

<ul>

<li>Флаги h, l, L. Как и у <em>printf()</em>, 
модификаторы размера. Для целых чисел <em>h</em>
означает  работу с  размером  <em>short</em>, а  <em>l</em>  
- с  размером <em>long</em>.  <b>ВАЖНОЕ
ОТЛИЧИЕ</b> от  случая <em>printf()</em>  
при вводе чисел  с плавающей запятой  - для
ввода <em>double</em> надо указывать <em>l</em>. Флаг  <em>L</em>, 
как и в <em>printf()</em>, ставится при
работе с <em>long&nbsp;double</em>.

<br><br>

<li>Флаг ширины.  Это число указывает максимальную ширину  поля ввода. При
этом вовсе не обязательно, что именно столько символов будет прочитано
из потока  например, при вводе  целого числа пробел вызовет  переход к
следующей спецификации, даже если ширина поля еще не исчерпана.

<br><br>

<li>Флаг *.  Этот флаг  приводит к тому,  что <em>scanf()</em>  
обрабатывает вводимые
данные  в  соответсвии  со   спецификацией,  но  результат  никуда  не
пересылается. Например,

<div class="incode">
   scanf("%*d %d",&i); 
</div>

считав строку 

<div class="incode">
   8 12
</div>

занесет в  переменную i  второе число  - 12. Этот  флаг полезен  в том
случае,  когда  для  некоторых  полей  вам  хочется  только  проверить
соответствие вводимых данных ожидаемому формату.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="signals"></a>Работа с сигналами</h2>

<p>			 

Сразу   оговорюсь,   работа  с   сигналами   относится  к   интерфейсу
операционной системы и по определению зависит от конкретной системы. Я
бы вообще  не стал останавливаться на  этом вопросе, но  в будущем мне
придется  сравнивать   соответсвующий  механизм  в  С++   с  тем,  что
предоставлял обычный С.

</p><p>

Я  думаю,  все  вы  знаете,  как снять  с  выполнения  "зациклившуюся"
программу -  нажать ^C (&lt;Control>&lt;C>). Но  что при этом  на самом деле
происходит  с задачей?   И  почему не  каждая  задача прекращает  свою
работу в этом случае?

</p><p>

На самом деле  нажатие ^C воспринимает не сама  задача, а операционная
система,  которая и  реагирует  на него,  посылая  связанной в  данный
момент задаче  так называемый сигнал - специальное  уведомление о том,
что  произошло некоторое событие.  А уж  задача, получив  этот сигнал,
выполняет в  ответ на него какое-то  действие. Для случая с  ^C она по
умолчанию завершает работу. Существуют и другие сигналы, и их довольно
много (сколько именно, зависит от операционной системы).

</p><p>

Казалось  бы, какая  разница,  на  что именно  задача  реагирует -  на
сигнал, или на нажатие ^С? Однако разница есть, и огромная.

</p><p>

Во первых, не все сигналы вообще доходят до задачи (тем не менее и про
такие все  равно принято говорить  - сигнал послан  задаче). Некоторые
сигналы  приводят к  тому, что  операционная система  что-то  делает с
задачей, даже не уведомляя ее об этом.

</p><p>

Во вторых  (для тех сигналов, которые передаются  задаче), у программы
появляется возможность при помощи одного  и того же механизма (одних и
тех же  вызовов функций) работать  с разными сигналами.   Задача может
изменить свою реакцию на тот  или иной сигнал. Например, по нажатию ^C
программа может не заканчивать  работу, а только печатать сообщение. А
может и  послать такой сигнал  сама себе -  и при этом  отреагирует на
него точно так же, как и при нажатии ^C.

</p><p>

Пожалуй,   надо    пояснить   механизм   реакции    на   сигнал   чуть
подробнее. Когда  задача получает сигнал,  выполнение "основного" кода
приостанавливается,  и  вызывается  обработчик  этого сигнала  -  либо
предусмотренный  по  умолчанию,  либо  назначенный в  программе.  Этот
обработчик  может   завершить  работу  программы   (вызвав,  например,
<em>abort()</em>).  Но  если  он   этого  не  сделает,  и  функция  обработчика
закончится  обычным  return,  то  после нее  работа  "основного"  кода
продолжится с того места, на котором была приостановлена.

</p><p>

Реакции  на   сигнал  по  умолчанию   позволяют  игнорировать  сигнал,
завершать  по нему  работу (возможно,  с созданием  образа  задачи для
последующей  отладки),   приостанавливать  и  возобновлять  выполнение
задачи.  Кроме того,  задача может  заблокировать какой-либо  сигнал -
такой  сигнал,  будучи посланным,  не  пропадет,  но  и не  дойдет  до
программы, пока она не снимет блокировку.

</p><p>

Помимо  этого,  при необходимости  можно  назначить  для сигнала  свою
функцию обработки. Вот как это выглядит в тексте программы:

<div class="code">
      #include &lt;signal.h><br>
      #include &lt;stdio.h><br>
<br>
      /* Пишем свой обработчик для сигналов */<br>
      void my_handler(int sig_number) {<br>
      &nbsp;&nbsp;fprintf(stderr, "signal %d caught\n", sig_number);<br>
      }<br>
<br>
<br>
      main() {<br>
<br>
      &nbsp;&nbsp;/* <br>
      &nbsp;&nbsp;&nbsp;&nbsp;Говорим, что по сигналу SIGINT нужно<br>
      &nbsp;&nbsp;&nbsp;&nbsp;вызывать наш обработчик<br>
      &nbsp;&nbsp;*/<br>
      &nbsp;&nbsp;signal(SIGINT, my_handler);<br>
<br>
      &nbsp;&nbsp;/* Искуственно зацикливаем программу */<br>
      &nbsp;&nbsp;while (1);<br>
<br>
     }<br>
</div>

Собрав и запустив такую программу, и нажав ^C, вы увидите сообщение

<div class="session">
   '^Csignal 2 caught'
</div>

после чего задача продолжит работу.

</p><p>

К  такому  же  эффекту  приведет  и  вызов  <em>kill()</em>  с  соответсвующими
аргументами, выполненный  прямо из  нашей же проограммы  (например, из
бесконечного цикла в <em>main()</em>.

<div class="incode">
	     ...<br>
	     while (1) {<br>
	     &nbsp;&nbsp;kill(0, SIGINT);<br>
             }<br>
	     ...<br>
</div>

Как я  уже говорил,  набор сигналов зависит  от системы, в  которой вы
работаете.    Если   вас    интересует   полный   список,   посмотрите
документацию. Или  (на unix-подобных системах)  наберите команду 
<em>kill&nbsp;&nbsp;-l</em>.  Я же  приведу  несколько, 
на  мой  взгляд, наиболее  популярных,
указав также реакцию по умолчанию на данный сигнал:

<ul>
<li> SIGINT   - прервать программу (как при ^C) 
<li> SIGABRT  - прервать программу и создать образ памяти
		      (как при вызове abort())
<li> SIGSEGV  - прервать программу и создать образ памяти
		      (это сигнал защиты памяти - может возникать, 
		       например, если вы выходите за границы массива)
	  
<li> SIGTERM  - Завершить программу 
		      (этот сигнал предназначен специально для 
		       того, чтобы программа могла нормально завершить
		       свою работу. Его так и называют - software
		       termination signal, сигнал программного 
		       завершения) 
	   
<li> SIGSTOP  - Остановить задачу
		      (До задачи не доходит. Выполнение задачи
		      приостанавливается)

<li> SIGKILL  - Снять задачу
		      (До задачи не доходит. Система снимает задачу -
		      прекращает ее работу)
</ul>		      

Обратите внимание  на последние  два сигнала -  это те  самые, которые
никогда не попадают в задачу:  так что не пытайтесь перехватывать их в
программе.

</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="longjmp"></a>Дальние переходы - &lt;setjmp.h></h2>

<p>			 

Мы только что говорили о сигналах, и вы теперь знаете, что по сигналу
можно вызывать свою функцию-обработчик. Однако в обработчике выбор у
вас не велик - вы либо завершаете программу, либо, по <em>return</em>,
продолжаете программу с того места, на котором она приостановилась,
получив сигнал. Функции <em>longjmp/setjmp</em> позволяют обойти это
ограничение, передав управление из обработчика сигнала (как, впрочем,
и из обычной функции) в другую точку программы. Я бы сказал, что они
позволяют вернуться в прошлое. Посмотрите на такую программу,
а потом я поясню, как она работает.

<div class="code">
     #include &lt;setjmp.h><br>
<br>
     jmp_buf jmpb;<br>
<br>
     main() {<br>
<br>
     &nbsp;&nbsp;int i;<br>
<br>
     &nbsp;&nbsp;i = setjmp(jmpb);<br>
<br>
     &nbsp;&nbsp;if (i==0) {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;printf("First message");<br>
     &nbsp;&nbsp;}<br>
     &nbsp;&nbsp;else {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;printf("%d\n",i);<br>
     &nbsp;&nbsp;&nbsp;&nbsp;return;<br>
     &nbsp;&nbsp;}<br>
     &nbsp;&nbsp;longjmp(jmpb,2);<br>
     }<br>
</div>

Здесь мы имеем две функции и обычный условный оператор, который
анализирует результат работы первой функции. Однако код этот
выполняется весьма неожиданным для неподготовленного человека образом.

</p><p>

Дело в том, что на самом деле <em>setjmp()</em> всегда возвращает 0. 
Так что при
старте программы мы увидим сообщение первого <em>printf()</em>. 
Затем, после
условного оператора, вызывается <em>longjmp()</em>, и при этом происходит очень
интересная вещь - программа возвращается к той точке, где вы вызывали
<em>setjmp()</em>. Только на этот раз все выглядит так, 
будто  <em>setjmp()</em> вернула не
0, а другое число - то, которое стоит вторым аргументом в <em>longjmp()</em>. 
Так
что в нашем случае мы вслед за сообщениеи от первого <em>printf()</em> увидим
вывод второго - число 2. После чего по оператору <em>return</em> программа
завершится. Связующим звеном между двумя функциями служит переменная
типа <em>jmp_buf</em> - по ней <em>longjmp()</em> узнает, 
к какой именно <em>setjmp()</em> нужно
вернуть программу. Ну, а вызвав <em>longjmp()</em> не из <em>main()</em>, а из
функции-обработчика сигнала, вы добьетесь того, что после обработки
сигнала задача не вернется к прежней работе, а займется чем-нибудь другим.

</p>
    </td>
  </tr>
</table>

</div>

</body>
</html>
