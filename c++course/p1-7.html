<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 7</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 7</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li><a href="p1-7.html#usertypes">Пользовательские типы данных в С.</a>
	  <ul>
	    <li><a href="p1-7.html#struct">Структуры.</a>
	    <li><a href="p1-7.html#bitfield">Битовые поля.</a>
	    <li><a href="p1-7.html#union">Объединения.</a>
	    <li><a href="p1-7.html#enum">Перечисления.</a>
	    <li><a href="p1-7.html#typedef">Оператор typedef.</a>
	  </ul>
        <li><a href="p1-7.html#heap">Динамическая память, С-стиль.</a>
	  <ul>
	    <li><a href="p1-7.html#malloc">malloc() и calloc()</a>
	    <li><a href="p1-7.html#realloc">realloc()</a>
	    <li><a href="p1-7.html#nomem">Если памяти не хватило ...</a>
	    <li><a href="p1-7.html#free">free()</a>
	    <li><a href="p1-7.html#voidptr">Универсальный указатель void*</a>
	    <li><a href="p1-7.html#safety">Правила хорошего тона.</a>
	  </ul>
      </ul>
    </td>
  </tr>
</table>
<br><br><br>
<hr align="center" width="50%">
<h1 align="center"><a name="usertypes"></a>
Пользовательские типы данных в С.</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
<p>


Сегодняшнее занятие мы начнем со знакомства c пользовательскими типами
данных в С, затем будем учиться работать с динамической памятью.

</p><p>

В С  совсем немного возможностей по  построению пользовательских типов
данных.  Точнее,  сами  возможности  практически безграничны,  но  вот
"базовых кирпичиков", из которых  все строится, всего 4. Это структуры
(structures),  объединения,  или  союзы  (unions), битовые  поля  (bit
fields)   и  перечисления   (enumerations).   Причем  последний   тип,
перечисление,  в  С  не   очень  популярен  -  никаких  дополнительных
преимуществ,  кроме  улучшения читаемости  программы,  он  не дает.  А
наиболее  распространен  первый тип  -  структуры.  Давайте  с него  и
начнем.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="struct"></a>Структуры.</h2>
<p>

Представьте,   что  вам   надо  написать   библиотеку  для   работы  с
комплексными числами.  Ясно, что  и результаты функций, и их параметры
будут  состоять  из реальной  и  мнимой  частей.  Можно, конечно,  для
представления комплексного числа пользоваться массивом из двух <em>double</em>:

<div class="incode">
	/* Complex number as array */<br>
	double cmplx[2]; /* [0] - real part, [1] - img */<br>
</div>

Можно,  но  не очень  удобно  - хотя  бы  потому,  что вместо  массива
комплексных   чисел  вам  придется   работать  с   двумерным  массивом
вещественных

<div class="incode">
	/* Array of complex numbers-arrays */<br>
	double cmplxarr[10][2]; /* [][0] - real part. [][1] - img */<br>
</div>

Поэтому  в таких случаях  гораздо удобнее  построить свой  тип данных,
чтобы переменная такого типа вела  себя как одно целое. Для этого надо
определить структуру:

<div class="incode">
	  /* complex.h */<br>
<br>
	  struct COMPLEX { <br>
	  &nbsp;&nbsp;double re;<br>
	  &nbsp;&nbsp;double im; <br>
          };<br>
</div>

или то же самое, но короче

<div class="incode">
	  /* complex.h */<br>
<br>
	  struct COMPLEX { <br>
	  &nbsp;&nbsp;double re, im;<br>
          };<br>
</div>


Как видите,  для определения  структуры сначала ставят  ключевое слово
<em>struct</em>,  затем название  типа (это  не название  
переменной,  а именно
название   пользовательского  типа),  а   затем  в   фигурных  скобках
определяют так называемые  поля - таким же образом,  как вне структуры
вы бы  определяли переменные. Так,  в нашей структуре  для комплексных
чисел  есть два  поля типа  <em>double</em> с  именами <em>re</em>  
и <em>im</em>.   Обычно, если
программа состоит из нескольких файлов, то такое описание типа выносят
в  файл-заголовок  (поэтому я  и написал  
в комментарии  <em>complex.h</em>). А
потом включают его в те файлы, где таким типом хотят пользоваться.

</p><p>

Написав подобное определение, мы теперь можем пользоваться нашим новым
типом данных - создавать переменные, указатели на него, массивы, и так
далее. Только название нашего нового типа будет <em>'struct COMPLEX'</em>, 
а не
<em>COMPLEX</em>. Вот примеры использования  нового типа для создания различных
объектов:

<div class="incode">
	  #include "complex.h"<br>
<br>
	  struct COMPLEX number1, number2; /* два числа */<br>
	  struct COMPLEX arr[10];          /* массив    */<br>
	  struct COMPLEX *ptr;		   /* указатель */<br>
</div>

Кстати,  если структура понадобилась  только в  одном файле,  то можно
даже совместить описание типа и создание переменных, вот так:

<div class="incode">
	  struct COMPLEX { <br>
	  &nbsp;&nbsp;double re, im;<br>
          } number1, *ptr;<br>
<br>
	  struct COMPLEX number2;<br>
</div>

Разумеется,  проделывать  такое в  файле-заголовке  не следует,  иначе
транслятор попытаться создать  переменные с одинаковыми именами везде,
куда вы этот заголовок включите.

</p><p>

Ограничений на типы используемых полей  очень немного - это могут быть
встроенные типы, массивы, указатели, другие структуры. Нельзя, правда,
включить в структуру  ее саму в качестве поля. А  вот указатель на эту
же  структуру можно,  и этим  часто пользуются  при  описании элемента
дерева, связного списка и т.п. Вот пример структуры с разными полями:

<div class="incode">
          /* Структура - элемент односвязного списка */<br>
          struct LIST_ELM {<br>
<br>
	  &nbsp;&nbsp;char info[100];      /* поле-массив char */<br>
<br>
          &nbsp;&nbsp;/* Поле-указатель на предыдущий элемент */<br>
	  &nbsp;&nbsp;struct LIST_ELM *prev; <br>
	  };<br>
</div>

Прямо  при создании  структур (имеются  в виду  переменные, а  не само
описание типа)  их можно  инициализировать - задавать  полям начальные
значения. Форма записи при этом следующая (на примере <em>LIST_ELM</em>):

<div class="incode">
	  struct LIST_ELM first = { "First item", NULL };<br>
<br>
	  struct LIST_ELM second = { "Second item", &first };<br>
</div>

Как видите, в фигурных  скобках мы просто перечисляем инициализирующие
значения  подходящего  типа.  Разумеется,   если  бы  поле  само  было
структурой  или массивом,  то для  его инициализации  нам  пришлось бы
поставить вложенный список значений в фигурных скобках:

<div class="incode">
	  struct USELESS {<br>
	  &nbsp;&nbsp;char *p;<br>
	  &nbsp;&nbsp;int a[2];<br>
	  &nbsp;&nbsp;double d;<br>
	  };<br>
<br>
	  struct USELESS useless = { NULL, { 1,2 }, 3.14 };<br>
</div>

Я показал вам, как  определять структуры, создавать и инициализировать
переменные   такого    типа.    Осталось   еще    научиться   с   ними
работать. Операторы  для работы с создаваемыми  пользователем типами -
один  из  признаков   объектно-ориентированного  языка,  и,  когда  мы
доберемся до  С++, мы научимся  проделывать подобные вещи. Но  пока мы
стараемся держаться в рамках С,  а в нем не предусмотрено операций для
работы с пользовательскими типами данных,  и относится это не только к
структурам.   Поэтому с  каждым  полем вам  придется  работать, как  с
самостоятельной  переменной. Но прежде  всего надо  научиться получать
доступ к нужному полю. Для этого  в С есть два специальных оператора -
.  (точка) и -> (стрелочка,  составленная из минуса и знака "больше").
Точка используется,  когда у  вас есть сама  структура, а  стрелочка -
если вы  работаете с указателем на  структуру. Вот как  это выглядит в
программе (на примере определенного раньше типа <em>COMPLEX</em>):

<div class="incode">
	 #include "complex.h"<br>
<br>
	 struct COMPLEX number, *ptr;<br>
<br>
	 /* Работа со полями структуры - точка */<br>
	 number.re = 1.0;<br>
	 number.im = number.re;<br>
<br>
	 /* Работа с полями через указатель - стрелочка */<br>
	 ptr = &number;<br>
	 ptr->re=1.0;<br>
	 ptr->im=ptr->re;<br>
</div>

Разумеется,  во втором  случае можно  было бы  использовать комбинацию
звездочки (доступ через указатель) и точки

<div class="incode">
	 (*ptr).re=1.0;<br>
	 (*ptr).im=(*ptr).re;<br>
</div>

но в  варианте со стрелочкой  транслятору приходится разбираться  не с
двумя операторами, а  с одним. А уж о  читаемости программы и говорить
не приходится, особенно  если поля у вас сами  являются указателями на
структуры. Попробуйте переписать без стрелочки строку

<div class="incode">
         p->next->q1->i=0;
</div>

и вы сразу это оцените.

</p><p>

Вы, наверное,  догадались из этих  примеров - если отвлечься  от формы
записи, то  можно считать, что  поля структур ведут себя,  как обычные
переменные соответствующего  типа. Вы можете ставить  поля в выражения,
передавать их функциям,  получать адрес поля и так  далее. Здесь у вас
не  должно быть особых  трудностей, поскольку  вы уже  видели подобное
поведение у элементов массива.

</p><p>

Но все-таки структуры придуманы  прежде всего для того, чтобы работать
с разнородной информацией, как  с одним целым.  Пока все преимущества,
которые мы  видели - поля  переменной сгруппированы в одном  объекте и
доступны  через  имя  этой   переменной.   Что  еще  можно  делать  со
структурой?  Разумеется,  передавать в функцию в  качестве параметра и
возвращать  результат.   Однако тут  есть  одна  особенность -  нельзя
передавать  в  функцию  и  возвращать  из нее  саму  структуру,  нужно
использовать ее  адрес. Связана эта  особенность с тем,  что структура
может  нести в  себе большой  объем данных,  так что  при  передаче по
значению приходилось бы копировать все данные из оригинала в локальную
копию  (или из  локальной  копии в  возвращаемое  значение). И,  чтобы
избежать  подобных  накладных  расходов  и  связанной  с  ними  потери
эффективности,   создатели  языка   потребовали,   чтобы  в   качестве
параметров  и  возвращаемых   значений  использовались  только  адреса
подобных объектов. Вот как это выглядит на практике:

<div class="code">
	 #include &lt;stdio.h><br>
	 #include "complex.h"<br>
<br>
	 /* Заносим комплексное значение по указанному адресу */<br>
	 void set_somplex(struct COMPLEX *n, double re, double im) {<br>
	 &nbsp;&nbsp;n->re = re;<br>
	 &nbsp;&nbsp;n->im = im;<br>
         }<br>
<br>
	 /* Складываем два числа, возвращаем результат */<br>
	 struct COMPLEX *add_complex(<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;struct COMPLEX *n1, <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;struct COMPLEX *n2<br>
	 ) <br>
	 { <br>
	 &nbsp;&nbsp;static struct COMPLEX result;<br>
	 &nbsp;&nbsp;result.re = n1->re + n2->re;<br>
	 &nbsp;&nbsp;result.im = n1->im + n2->im;<br>
	 &nbsp;&nbsp;return &result;<br>
         }<br>
<br>
	 main() {<br>
	 &nbsp;&nbsp;struct COMPLEX number1, number2, *ptr;<br>
<br>
	 &nbsp;&nbsp;set_complex( &number1, 1.0, 1.0);<br>
	 &nbsp;&nbsp;set_complex( &number2, 1,0, 0.0);<br>
<br>
	 &nbsp;&nbsp;ptr=add_complex(&number1, &number2);<br>
<br>
	 &nbsp;&nbsp;printf("%g %g\n", ptr->re, ptr->im);<br>
	 }<br>
</div>

	 
Между прочим,  попробуйте догадаться,  почему я в  функции <em>add_complex</em>
для  хранения  результата  использовал  статическую  структуру,  а  не
автоматическую.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="bitfield"></a>Битовые поля.</h2>
<p>

Вот, собственно, и все, что я собирался сказать о структурах. Перейдем
теперь  к битовым  полям.   Прежде, чем  показать,  как они  выглядят,
приведу характерный пример, где  они требуются.  Представьте себе, что
вы пишете программу для работы  с контроллером КАМАК. И в документации
на  контроллер  написано  что-нибудь  в таком  духе:  "CSR  (cтатусный
регистр) доступен  по адресу 0xD8000. Для генерации  цикла КАМАК номер
функции (0..31) нужно занести в  биты 1-5 статусного регистра, а в бит
0   занести  1.    После   завершения  цикла   бит   0  будет   очищен
контроллером.".  И  вам  надо  выполнить  8  функцию  КАМАК,  а  затем
дождаться  завершения цикла.  Разумеется,  все это  можно проделать  с
помощью операций битовой арифметики:

<div class="incode">
	 volatile char *csr = (char*)0xD8000;<br>
<br>
	 /* Заслать в биты 1..5 функцию 8, взвести бит 0 */<br>
	 *csr = (8&lt;&lt;1)|1<br>
<br>
	 /* Дождаться, пока контроллер очистит бит 0 */<br>
	 while ( (*csr & 1) != 0) ;<br>
</div>

Такое, конечно, сработает. Но  писать долго, читать непонятно. Неплохо
бы иметь возможность работать с  группами битов как с переменными. Вот
именно для этого и предусмотрены битовые поля.

</p><p>

Само  по себе определение  битового поля  очень похоже  на определение
структуры, только после каждого поля указывается его размер в битах. И
в  качестве   типа  поля  указывать  можно  только   <em>int</em>,  
<em>signed</em>  или
<em>unsigned</em>. Вот  как мы  могли бы описать  статусный регистр  из примера
выше:

<div class="incode">
      struct CSR {<br>
      &nbsp;&nbsp;unsigned  busy : 1;     /* Бит, запускающий цикл */<br>
      &nbsp;&nbsp;unsigned  f : 5 ;       /* 5 битов под функцию */<br>
      &nbsp;&nbsp;int unused: 2;          /* Три неиспользуемых старших бита */<br>
      };<br>
</div>

Теперь,  создав переменную  такого  типа,  мы будем  иметь  в ней  три
"маленьких" целых числа  - unused с длиной 3  бита и диапазоном -4..3,
беззнаковое f длиной  5 бит и диапазоном 0..31,  и беззнаковое busy из
одного бита,  то есть,  с диапазоном 0..1.  Причем все  эти переменные
окажутся упакованными  в один  байт.  И теперь  мы можем  проделать со
статусным регистром требуемую работу в гораздо более понятной форме:

<div class="incode">
         volatile struct CSR *mycsr = (struct CSR *)0xD8000;<br>
<br>
	 /* Заслать в биты 1..5 функцию 8 */<br>
	 csr->f = 8;<br>
<br>
	 /*  взвести бит 0 */<br>
	 csr->busy = 1;<br>
<br>
	 /* Дождаться, пока контроллер очистит бит 0 */<br>
	 while ( csr->busy ) ;<br>
</div>

Можно еще более усовершенствовать определение нашего битового поля -
не давать имя первой, неиспользуемой, группе битов, благо С это
позволяет: 

<div class="incode">
      struct CSR {<br>
      &nbsp;&nbsp;unsigned  busy : 1;     /* Бит, запускающий цикл */<br>
      &nbsp;&nbsp;unsigned  f : 5 ;       /* 5 битов под функцию */<br>
      &nbsp;&nbsp;int       : 2;     /* Три неиспользуемых старших бита */<br>
      };<br>
</div>

При этом 3 бита под безымянное поле все равно будут выделены, так что
нужные нам поля <em>f</em> и <em>busy</em> окажутся на прежних местах.

</p><p>

Хочу  вас   сразу  предупредить.   Единственный   сюжет,  когда  стоит
использовать   битовые   поля  -   это   именно   работа  с   внешними
устройствами.  Ну, может  быть  изредка еще  и  перепаковка данных  из
одного кода в другой. Не стоит пытаться в расчетной задаче экономить с
их помощью память - в скорости работы программы вы точно проиграете, а
выигрыш по памяти будет скорее всего грошовым.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="union"></a>Объединения.</h2>
<p>


Третий из  определяемых пользователем типов данных  - это объединение,
или союз.  Определяется этот тип  с помощью другого ключевого  слова -
<em>union</em>, например, так.

<div class="incode">
       union DOUBLE_UCHAR8 {<br>
       &nbsp;&nbsp;double d;<br>
       &nbsp;&nbsp;unsigned char uc[8];<br>
       };<br>
</div>

Как видите  у союза  тоже есть  поля. Вот только  ведут себя  эти поля
совсем иначе, не так, как в  структуре. Дело в том, что все поля союза
располагаются по  одному адресу.  Помните,  я рассказывал на  одном из
занятий о том,  как неприятно бывает, когда вы  подсовываете функции 4
байта <em>int</em>, а транслятор по незнанию берет  8 - четыре ваших, 
и еще 4 -
мусора,  и использует  их как  <em>double</em>? Так  вот, союз  -  это законный
способ проделать то же самое,  когда вы этого действительно хотите. Во
многих книгах  пишут, что союз  может держать значение только  в одном
поле, На  мой взгляд, правильнее  и понятнее говорить, что  союз через
разные  поля дает  доступ  к  одному и  тому  же содержимому.   Просто
программа   интерпретирует  это   содержимое  по   разному.  Например,
используя  тот  союз,  что  мы  написали  выше,  можно  посмотреть  на
внутреннее    представление   числа    типа   double    (на   байтовую
последовательность, которую представляет собой данное число):

<div class="incode">
	   int i;<br>
	   union DOUBLE_UCHAR8 v;<br>
<br>
	   /* Засылаем значение в поле типа double */<br>
	   v.d = 2.71828;<br>
<br>
	   /* Смотрим, как оно выглядит в виде цепочки байтов */<br>
	   for (i=0; i&lt;8; i++)<br>
	   &nbsp;&nbsp;printf("uc[%d]= %d\n", i, v.uc[i] );<br>
</div>

Союз тоже  можно инициализировать  прямо при создании.  Правда, только
значением для первого поля:

<div class="incode">
	  union DOUBLE_UCHAR8 u = { 3.14 };
</div>

Это, впрочем, вполне естественно - память под полями одна и та же, так
что инициализатор для второго поля испортил бы нам первое значение.

</p><p>

Союзы прежде всего полезны там, где у вас по смыслу в одной переменной
могут  храниться разные  типы  данных. Например,  в качестве  карточки
библиотечного каталога  - либо номер  (ISBN), либо структура  с такими
полями, как автор, название книги и  т.п. И в отличие от битовых полей
союзы  можно и  нужно  использовать в  подобных  случаях для  экономии
памяти.


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="enum"></a>Перечисления.</h2>
<p>

И,  наконец, последний  тип -  перечисление  (enumeration).  По-моему,
наименее  популярный - это  можно понять  даже по  соотношению частоты
определения перечислений и структур в той же стандартной библиотеке С.
Этот  тип позволяет  создавать синонимы  для  последовательности целых
чисел,  а затем  эти  синонимы использовать  в качестве  символических
констант.  Или   использовать  сам  этот  тип   в  качестве  параметра
функции. Например, мы можем написать

<div class="incode">
	  enum BOOLEAN {<br>
	       FALSE,<br>
	       TRUE<br>
	  };<br>
</div>

А потом использовать вместо 0 и 1 имена FALSE и TRUE. Или использовать
имя нашего типа для задания параметра:

<div class="incode">
         void f(enum BOOLEAN flag) {<br>
<br>
	 &nbsp;&nbsp;if (flag==FALSE)<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;printf("flag==FALSE\n");<br>
	 &nbsp;&nbsp;else<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;printf("flag==TRUE\n");<br>
         }<br>
<br>
	 main() {<br>
	 &nbsp;&nbsp;f(FALSE);<br>
	 &nbsp;&nbsp;f(TRUE);<br>
	 }<br>
</div>

Удобно, конечно,  и программа  лучше читается. Вот  только С  не любит
напрягаться на предмет  проверки типов. Так что с  таким же успехом мы
могли бы в  main написать f(25), и даже  предупреждения от транслятора
не увидели бы. Однако все-таки немного расскажу вам про него.

</p><p>

Если вы просто  перечисляете имена элементов в enum,  то первое имя он
сделает  синонимом нуля,  второе  -  единицы, и  так  далее в  порядке
возрастания. Именно поэтому с таким  enum, как мы написали выше, FALSE
стало  синонимом 0,  а  TRUE  - синонимом  1.  Однако можно  заставить
транслятор начать нумерацию с любого числа:

<div class="incode">
       enum COLOR {<br>
       &nbsp;&nbsp;RED = 1,		/* Просим начать нумерацию с 1 */<br>
       &nbsp;&nbsp;GREEN,              /* GREEN == 2 */<br>
       &nbsp;&nbsp;BLUE		/* BLUE  == 3 */<br>
       };<br>
</div>

Проделывать такое  можно не  один раз. При  этом можно создавать  и по
несколько  синонимов для  одного и  того же  числа. И  можно оставлять
"пустые места" в последовательности чисел:

<div class="incode">
       enum PIXELCOLOR {<br>
<br>
       &nbsp;&nbsp;black,          /* black == 0 */<br>
       &nbsp;&nbsp;background = 0, /* Тоже 0     */<br>
       &nbsp;&nbsp;red,	    /* red == 1 */<br>
       &nbsp;&nbsp;green,	    /* green == 2 */<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* пропускаем значение 3 */<br>
       &nbsp;&nbsp;blue = 4,       <br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* пропускаем 5,6 */<br>
       &nbsp;&nbsp;white=7<br>
       };<br>
</div>

Вот, собственно, и все, что я хотел сказать про перечисления.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="typedef"></a>Оператор typedef.</h2>
<p>


Думаю,  что пришло  время рассказать  вам про  оператор  <em>typedef</em>. Этот
оператор служит  для создания синонимов для имени  типа. Применять его
можно  с  любыми  типами,  но  особенно  он  помогает  при  работе  со
структурными  типами  и со  сложными  в  понимании типами  указателей.
Пользоваться им очень просто.  Представьте, что вы создаете переменную
или несколько переменных в одном операторе.  А теперь добавьте вначале
ключевое слово typedef, и  вы получите не переменные, а имена-синонимы
для соответсвующих типов:

<div class="incode">
	typedef int MY_INT; <br>
<br>
	struct COMPLEX { int re, im };<br>
	typedef struct COMPLEX COMPLEX_t, *COMPLEX_ptr;<br>
</div>

Теперь  вы можете  создавать  переменные с  использованием этих  новых
имен:

<div class="incode">
        MY_INT i = 1;<br>
<br>
        COMPLEX_t n = { 1.0, 0.0};<br>
	COMPLEX_ptr ptr = &n;<br>
</div>

Специально  подчеркну -  это не  новые типы  данных, это  синонимы уже
имеющихся. Для  транслятора исходные, "настоящие" имена типов

<div class="incode">
	   int<br>
	   struct COMPLEX<br>
	   struct COMPLEX *<br>
</div>

теперь ничем не отличаются от

<div class="incode">
           MY_INT<br>
	   COMPLEX_t<br>
	   COMPLEX_ptr<br>
</div>

Ну вот, а теперь давайте разбираться с динамической памятью.

</p>
    </td>
  </tr>
</table>

<br><br><br>

<hr align="center" width="50%">
<h1 align="center"><a name="heap"></a>Динамическая память, С-стиль.</h1>
<br>
<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
<p>

Прежде всего, что  такое динамическая память? В прошлый  раз мы с вами
учились  работать с  массивами,  в том  числе,  учились создавать  их,
задавая размер либо явно,  либо списком инициализации.  То есть, когда
мы писали какую-нибудь программу, размер массива был нам уже известен.
В то  же время  в жизни встречается  очень много задач,  когда заранее
нельзя    сказать,    сколько    элементов   нам    потребуется    для
работы. Представьте, например, что  вам надо написать функцию, которая
перемножает  матрицы.   А про  матрицы  известно  только  то, что  они
квалратные - число  строк равно числу столбцов. Для  того, чтобы такую
функцию написать,  вам придется создать двумерный  массив для хранения
результата - размерности не меньшей, чем у двух исходных матриц.

</p><p>

Разумеется,  отчасти эту  проблему можно  решить, создавая  в подобных
случаях  массивы или  другие  стурктуры данных  "с  запасом". Но  этот
способ, во-первых, неэкономно использует  память, и во вторых, годится
только  для  некоторых задач.   Гораздо  правильнее  в такой  ситуации
создать массив нужного размера  динамически - непосредственно во время
работы программы, когда этот  размер уже известен. И если операционная
система позволяет получать память по мере необходимости, то нет ничего
удивитльного  и  в  том,   что  она  также  предоставляет  возможность
совобождать  уже ненужную память,  возвращать ее  в систему,  чтобы ей
могли пользоваться другие задачи.

</p><p>

Под  термином "динамическая  память" как  раз и  подразумевают память,
выделяемую под объекты такого рода.  А само хранилище, из которого эта
память берется,  часто называют  "кучей" (heap) или  свободной памятью
(free store).

</p><p>

В  С  захват  и  освобождение  памяти выполняются  с  помощью  функций
стандартной  библиотеки   -  это  так  называемый   С-стиль  работы  с
динамической памятью. С++  понимает С-стиль, но у него  есть и другой,
более  подходящий для объектно-ориентированного  языка. Но  мы сегодня
будем говорить только о С-стиле работы с динамической памятью.

</p><p>

Для  решения  всех  мыслимых  задач  в С  предусмотрено  всего  четыре
функции,  работающих с  динамической  памятью. Назову  их, не  уточняя
пока, что они возвращают, и какие у них параметры.

<div class="incode">
	  malloc();<br>
	  calloc();<br>
	  realloc();<br>
	  free();<br>
</div>

Первые две захватывают память (alloc  в названии от слова allocation -
резервирование).  Третья, <em>realloc</em>,  позволяет  изменять (как  правило,
увеличивать)   размер  уже   захваченного  массива   без   потери  его
содержимого.   Последняя функция,  как можно  догадаться  по названию,
освобождает уже  ненужную память.  Для того,  чтобы пользоваться этими
функциями, в программу надо включить файл-заголовок

<div class="incode">
          #include &lt;stdlib.h>
</div>

чтобы  транслятору  стали известны  их  объявления.  А теперь  давайте
учиться работать с ними.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="malloc"></a>malloc() и calloc()</h2>
<p>


Функция  <em>malloc()</em> захватывает  область  памяти, размер  в байтах  этой
области  вы  указываете  в  качестве  аргумента.   Функция  возвращает
указатель  на  захваченную  память  (то  есть, ее  адрес).   При  этом
выделяемая память никак не  инициализируется, не очищается, так что не
стоит  полагаться  на  то,  что  ее  байты  будут  содержать  какие-то
определенные значения. Сохранив возвращенное функцией значение в своем
указателе,  вы можете  затем  использовать этот  указатель в  качестве
переменной,  массива, и  вообще как  вам вздумается,  лишь  бы правила
языка соблюдались. Вот так например, можно создать динамический массив
из ста символов, а затем заполнить его нулями:

<div class="code">
          #include &lt;stdlib.h><br>
<br>
	  main() {<br>
<br>
	  &nbsp;&nbsp;int i;<br>
	  &nbsp;&nbsp;char *p;<br>
<br>
	  &nbsp;&nbsp;/* Резервируем 100 байтов под массив char */<br>
	  &nbsp;&nbsp;p = malloc(100);<br>
<br>
	  &nbsp;&nbsp;for (i=0; i&lt;100; i++)<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;p[i] = 0;<br>
<br>
	  &nbsp;&nbsp;return 0;<br>
<br>
	  }<br>
</div>

Повторю  -  функции <em>malloc</em>  в  аргументе  передается размер  требуемой
области в  байтах. Так что  если нам нужен  массив не <em>char</em>,  а другого
типа, например, <em>int</em>, то придется сначала пересчитать число элементов в
байты с помощью оператора <em>sizeof()</em>. Впрочем, это можно сделать прямо в
вызове <em>malloc()</em>:

<div class="incode">
          int *p;<br>
<br>
	  /* Резервируем место под 100 элементов int */<br>
	  p = malloc( 100 * sizeof(int) );<br>
<br>
	  /* То же самое. Догадайтесь, почему так лучше? */<br>
	  p = malloc( 100 * sizeof(*p) );<br>
</div>

Функция  <em>malloc()</em>,   как  я  уже  говорил,   никак  не  инициализирует
выделяемую  память. Другая  функция, <em>calloc()</em>,  не  только захватывает
память, но  и очищает  ее, заполняет байты  нулями. Но  вызывается она
немного иначе,  у нее  два аргумента -  количество элементов  и размер
элемента в байтах:

<div class="code">
          #include &lt;stdlib.h><br>
<br>
	  main() {<br>
<br>
	  &nbsp;&nbsp;int i;<br>
	  &nbsp;&nbsp;char *сp;<br>
	  &nbsp;&nbsp;int *ip;<br>
<br>
	  &nbsp;&nbsp;/* Резервируем и очищаем 100 байтов под массив char */<br>
	  &nbsp;&nbsp;сp = сalloc(100, 1 );<br>
<br>
	  &nbsp;&nbsp;/* Резервируем и очищаем 100 элементов int */<br>
	  &nbsp;&nbsp;ip = сalloc(100, sizeof(*ip) );<br>
<br>
	  &nbsp;&nbsp;return 0;<br>
<br>
	  }<br>
</div>

Итак, функция  <em>calloc(nelm, elmsize)</em> выделит столько же  байтов, что и
<em>malloc(nelm*elmsize)</em>. Да еще и очистит выделенную память.

</p><p>

Хотя в примерах выше мы пользовались динамической памятью только
для  создания массивов,  ничто  не запрещает  создавать таким  образом
структуры, переменные  встроенных типов и  т.п. На самом деле  все эти
функции работают  с "сырой" памятью,  и им абсолютно  безразлично, как
программист  ее  будет  использовать.   А тот  указатель  (точнее  тип
указателя),  в который  вы  записываете адрес  области, лишь  помогает
программе интерпретировать  эту область нужным  вам образом. Поставьте
вместо указателя на int указатель  на структуру - и вы будете работать
с динамически созданной структурой или массивом структур:

<div class="code">
	  #include &lt;stdlib.h><br>
	  #include "compleh.h"<br>
<br>
	  struct COMPLEX { double re, im; };<br>
<br>
	  main() {<br>
<br>
	  &nbsp;&nbsp;struct COMPLEX *ptr;<br>
<br>
	  &nbsp;&nbsp;ptr=malloc(sizeof(struct COMPLEX));<br>
<br>
	  &nbsp;&nbsp;ptr->re = 1.0;<br>
	  &nbsp;&nbsp;ptr->im=0.0;<br>
<br>
	 }<br>
</div>


Можно даже создать в выделенной области что-то вроде союза, нацелив на
начало области указатели на разные  типы. Главное при этом не выходить
за рамки выделенной вам памяти.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="realloc"></a>realloc()</h2>
<p>


Функция  <em>realloc()</em>  позволяет изменять  
размер  уже выделенного  участка
динамической памяти. То есть,  создав динамический массив и обнаружив,
что  вам  не  хватает  элементов,  вы можете  его  "нарастить".   Или,
наоборот,  уменьшить  его  размер,   если  в  конце  оказались  лишние
элементы.  Вот как этой функцией можно пользоваться:

<div class="code">
          #include &lt;stdlib.h><br>
<br>
	  main() {<br>
<br>
	  &nbsp;&nbsp;int *ip;<br>
<br>
	  &nbsp;&nbsp;/* Резервируем 100 элементов int */<br>
	  &nbsp;&nbsp;ip = malloc(100*sizeof(*ip) );<br>
<br>
	  &nbsp;&nbsp;...;<br>
<br>
	  &nbsp;&nbsp;/* Не хватило - наращиваем до 200 элементов */<br>
	  &nbsp;&nbsp;ip = realloc(ip, 200*sizeof(*ip) );<br>
<br>
	  &nbsp;&nbsp;...;<br>
<br>
	  &nbsp;&nbsp;/* Нам достаточно 150 элементов, убираем 50 лишних */<br>
	  &nbsp;&nbsp;ip = realloc(ip, 150*sizeof(*ip) );<br>
<br>
	  &nbsp;&nbsp;...;<br>
<br>
	  &nbsp;&nbsp;return 0;<br>
<br>
	  }<br>
</div>

Как видите, у этой функции  два параметра - указатель на уже имеющуюся
область динамической памяти и  новый размер этой области. А возвращает
эта  функция,  как и  две  первых,  указатель  на захваченную  область
нужного размера в байтах.

</p><p>

Функции  <em>malloc()</em>   и  <em>calloc()</em>   
обычно  не  вызывают   вопросов  (первая
захватывает  память,  вторая  захватывает   и  обнуляет).  Но  вот  на
поведение <em>realloc()</em> стоит посмотреть повнимательнее.

</p><p>

Прежде всего,  эта функция, как уже говорилось,  может изменять размер
только динамического массива. То есть, в качестве первого аргумента ей
можно  передать только  указатель, который,  как в  примере  выше, был
получен  от  <em>malloc()</em>  или  <em>calloc()</em>  
(или  от  предыдущего  вызова  самой
<em>realloc()</em>).  Если вы попытаетесь 
передать ей адрес статического массива,
ничего хорошего из этого не получится:

<div class="incode">
	  char s[100];<br>
	  char *p;<br>
	  char *p1;<br>
	  p=malloc(100);<br>
<br>
	  /* Так хорошо и правильно */<br>
	  p1=realloc(p, 150);<br>
<br>
	  /* А вот так делать нельзя!!! */<br>
	  p1=realloc(s,150);<br>
</div>

Второе касается содержимого новой области. Если вы увеличиваете размер
массива  с помощью  <em>realloc()</em>,  то содержимое  
исходного  массива у  вас
сохранится.  Новые же элементы  будут содержать  "мусор". Естественно,
уменьшая размер массива, вы  вместе с "лишними" элементами потеряете и
их значения:

<div class="incode">
	  int *ip;<br>
<br>
	  /* Создали массив из 2 целых, записали значения */<br>
	  ip=malloc(2*sizeof(int));<br>
	  ip[0]=0;<br>
	  ip[1]=1;<br>
<br>
	  /* <br>
	  &nbsp;&nbsp;Добавляем еще один элемент. <br>
	  &nbsp;&nbsp;ip[0] ip[1] содержат прежние значения.<br>
	  про содержимое ip[2] ничего сказать нельзя<br><br>
	  */<br>
	  ip=realloc(ip, 3*sizeof(int));<br>
<br>
<br>
	  /* <br>
	  &nbsp;&nbsp;А теперь оставляем только нулевой элемент.<br>
	  &nbsp;&nbsp;Естественно, вместе с элементами ip[1] ip[2] <br>
	  &nbsp;&nbsp;мы потеряли и  их содержимое<br>
	  */<br>
	  ip = realloc(ip, sizeof(int));<br>
</div>

Третье,  и, пожалуй,  самое важное,  что надо  учитывать при  работе с
<em>realloc()</em>  - когда  вы пользуетесь  этой функцией,  
система  не изменяет
размер той  самой области,  с которой вы  работали, а создает  для вас
другую,  копируя   в  нее  содержимое  первой.    А  исходную  область
освобождает. А  это означает, что содержимое массива  вы сохраняете, а
вот адрес  этого массива становится (не всегда,  правда), другим. Или,
другими  словами, передав  этой функции  указатель в  качестве первого
аргумента, вы должны забыть о  нем, и в дальнейшем использовать только
тот новый, который вернет realloc:

<div class="incode">
          char *p1, *p2;<br>
<br>
	  p1=malloc(100);<br>
<br>
	  /* Сохраняем копию указателя в p2 */<br>
	  p2 = p1;<br>
<br>
	  /* <br>
	  &nbsp;&nbsp;После realloc() p1 скорее всего поменяется.<br>
	  &nbsp;&nbsp;Поэтому пользоваться старой копией p2 нельзя,<br>
	  &nbsp;&nbsp;память под этим адресом уже освобождена в realloc()<br>
          */<br>
<br>
	  p1=realloc(p1, 1000);<br>
<br>
	  p1[0] = 'c';	  /* Правильно */<br>
	  p2[0] = 'c';   /* Ошибка. Эта память уже не наша */ <br>
</div>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="nomem"></a>Если памяти не хватило ...</h2>
<p>


Возможно, кто-то  обратил внимание - во  всех примерах, иллюстрирующих
захват  памяти,   молчаливо  полагалось,  что   программа  эту  память
получает.   Однако  ресурсы  любого  компьютера  ограничены,  и  может
статься,  что  в  системе  не окажется  нужного  количества  свободной
памяти. В  этом случае все три  функции сообщат вам  об ошибке, вернув
<em>NULL</em>. Так  что полезно после  вызова любой из этих  
функций проверить, увенчалась ди ваша попытка успехом:

<div class="incode">
	   char *p;<br>
<br>
	   /* Хотим получить гигабайт */<br>
	   p = malloc(1024*1024*1024);<br>
<br>
	   /* Проверяем, удалось ли  */<br>
	   if (p == NULL) {<br>
	   &nbsp;&nbsp;printf("failed to get gigabyte of memory\n");<br>
	   &nbsp;&nbsp;exit(1);<br>
           };<br>
</div>


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="free"></a>free()</h2>
<p>

Теперь,  когда  вы имеете  представление,  как пользоваться  функциями
семейства <em>alloc()</em>, давайте поговорим  про четвертую функцию для работы
с динамической памятью - про  <em>free()</em>.  

</p><p>

Если вы  используете в программе динамический массив,  рано или поздно
наступает  момент, когда он  перестает быть  нужен.  Если  этот момент
совпадает с  завершением задачи, можно  особо не беспокоиться  на этот
счет - хорошая система, снимая задачу с выполнения, заодно и освободит
отведенную ей память. Однако чаще  случается, что массив уже не нужен,
а  программа продолжает  работать. И  в этом  случае совсем  не вредно
освободить  выделенную  память   -  во-первых,  другим  задачам  может
пригодиться, а во вторых, вашей  же задаче может не хватить памяти для
другого  массива. А  для того,  чтобы динамическую  память освободить,
надо  вызвать функцию <em>free()</em>,  передав ей  в аргументе  тот указатель,
который вы получили от <em>malloc()</em>, <em>calloc()</em> 
или <em>realloc()</em>.  Естественно,
после вызова <em>free()</em> этим указателем уже нельзя будет пользоваться.

<div class="incode">
<br>
	  int *p;<br>
<br>
	  /* Создаем и используем динамический массив */<br>
	  p = malloc(5 * sizeof(int));<br>
	  p[0] = 1;<br>
<br>
	  /* Массив больше не нужен, освобождаем память */<br>
	  free(p);<br>
<br>
	  /* Ошибка! Массива, на который указывал p, уже нет ! */ <br>
	  p[0]=1;<br>
<br>
	  /* Создаем, используем и уничтожаем еще один массив */<br>
	  p = malloc(2 * sizeof(int));<br>
	  p[0] = 1;<br>
	  free(p);<br>
</div>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="voidptr"></a>Универсальный указатель void*</h2>
<p>

Вот еще на что хотелось бы обратить ваше внимание. Если вы в программе
попытаетесь в операторе  присваивания использовать указатели на разные
типы, например, так:

<div class="incode">
          int *ip;<br>
	  double *dp;<br>
<br>
	  dp = ip;<br>
</div>

то   транслятор  выдаст   вам  сообщение   о  том,   что   так  делать
нехорошо. Правда,  это будет  только предупреждение, программу  он все
равно  странслирует. Однако  такое  предупреждение выдается  не зря  -
подобные операции с указателями,  если это сделано по ошибке, приводят
к  весьма печальным  последствиям.  Поэтому и  рекомендуют в  подобных
случаях явно приводить один тип к другому:

<div class="incode">
	  dp = (double*) ip;
</div>

Казалось  бы, при  таком  внимательном отношении  транслятора к  типам
указателей примеры выше должны пестреть от операторов приведения:

<div class="incode">
	  char *cp;<br>
	  double *dp;<br>
<br>
	  cp = (char *) malloc(100);<br>
	  dp=  (double*)calloc(100, sizeof(double));<br>
</div>

А  как же  получается,  что  во всех  примерах  работы с  динамической
памятью  мы ни  разу не  пользовались приведением  типа? Какой  же тип
указателя используют эти функции  стандартной библиотеки, и чем он так
нравится транслятору?

</p><p>

Давайте вспомним  то, что  я говорил про  тип <em>void</em>. Этот  тип означает
отсутствие значения.  Переменных этого  типа не существует. Первое его
применение,  с которым  мы  сталкивались -  явное  указание того,  что
функция ничего  не возвращает или  не содержит параметров. Так  вот, в
данном случае мы имеем дело со вторым его полезным применением.

</p><p>

Хотя переменных типа <em>void</em> не бывает, указатели такого типа, например

<div class="incode">
      void *ptr;
</div>

вполне  законны  и очень  полезны.   Для  них  не работает  арифметика
указателей, поскольку отсутствует  само понятие размера элемента.  Так
что транслятор  просто не позволит  вам написать для  такого указателя
<em>ptr[2]</em> или <em>ptr++</em>.  И  единственное, 
зачем подобный указатель может вам
пригодиться - это для хранения  значения другого указателя.  Так что в
этом случае транслятор  делает исключение, позволяя использовать такие
указатели в присваивании без явного приведения типа:

<div class="incode">
      void *vp;<br>
      char *cp;<br>
      double *dp;<br>
<br>
      /*<br>
      &nbsp;&nbsp;Несмотря на отсутствие оператора приведения типа, ни одна <br>
      &nbsp;&nbsp;из следующих строк не даст предупреждения транслятора<br>
      */<br>
      cp = vp;<br>
      vp = cp;<br>
      dp = vp;<br>
      vp = dp;<br>
</div>

Именно  такими   указателями  и   пользуются  функции  для   работы  с
динамической  памятью -  <em>malloc()<em> возвращает  такой  указатель, 
<em>free()</em> получает аргумент такого типа, и так далее.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="safety"></a>Правила хорошего тона.</h2>
<p>


В  завершение этой  темы дам  два совета,  которые  помогут сэкономить
время и  избежать многих неприятных  ошибок при работе  с динамической
памятью.

</p><p>

Во-первых,  не  забывайте  о  правилах  хорошего  тона  при  работе  с
указателями.   Ваши   указатели  должны  содержать   либо  <em>NULL</em>,  либо
какой-нибудь разумный адрес.   В частности, освободив память функцией,
не забудьте  стереть уже недействительный адрес -  занести в указатель
<em>NULL</em>,  иначе вы  рискуете  по ошибке  попытаться  использовать уже  не
принадлежащую    задаче   память.     И   почаще    проверяйте   перед
использованием, <em>NULL</em> у вас в указателе или нет:

<div class="incode">
	  char *p = malloc(100);<br>
	  char c;<br>
	  ...<br>
<br>
	  free(p);<br>
	  p=NULL;<br>
<br>
<br>
	  /* Так плохо - пытаемся использовать NULL */<br>
	  c = *p;<br>
<br>
	  /* А так безопасно  */<br>
<br>
	  if (p!=NULL) {<br>
	  &nbsp;&nbsp;/* p на что-то указывает, можно работать */<br>
	  &nbsp;&nbsp;c = *p;<br>
          }<br>
</div>

И во вторых, не теряйте длину выделенной области - иначе вы не сможете
узнать, сколько же  у вас элементов в динамическом  массиве. Точно так
же  нельзя  терять  исходный  адрес,  который  вернула  вам  
<em>malloc()</em>, <em>calloc()</em> или <em>realloc()</em> 
- без  него вы не сможете освободить выделенную
область. Вот вам пример, который иллюстрирует обе этих проблемы:

<div class="incode">
    char *p;<br>
    int i;<br>
    <br>
    i = read_array_size();<br>
<br>
    p = malloc(i);   /* Получили массив из i элементов */<br>
<br>
    i=10;	     /* Переписали значение i */<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Программа теперь не знает число элементов */<br>
<br>
<br>
    p++;  /* Сместили указатель, "потеряли" адрес области */<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Теперь не сможем освободить память */<br>
</div>

<br><br><br>
Вот и все на сегодня. На этом занятие закончено.

</p><p>

Мы уже подощли  к концу первой фазы - изучения  языка С. Я рассчитываю
еще рассказать  вам про  директивы трансляции и  макроопределения, про
раздельную трансляцию, а также сделать обещанный краткий обзор функций
ввода-вывода  и  стандартной  библиотеки  вообще.  Думаю,  это  займет
одно-два  занятия.  После этого  мы  закончим изучение  С-подмножества
языка и перейдем  к изучению тех возможностей, которые  есть в С++, но
отсутсвуют в обычном С.

</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>
