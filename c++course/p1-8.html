<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 8</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 8</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Препроцессор и раздельная трансляция.
	<ul>
	  <li><a href="p1-8.html#stages">Фазы трансляции.</a>
	  <li><a href="p1-8.html#cpp">Директивы препроцессора.</a>
	  <ul>
	    <li><a href="p1-8.html#include">#include</a>
	    <li><a href="p1-8.html#define">Макроопределение - директива #define</a>
	    <li><a href="p1-8.html#undef">Отмена макроопределения - #undef</a>
	    <li><a href="p1-8.html#ifdef">Директивы условной трансляции</a>
	  </ul>
	  <li><a href="p1-8.html#separation">Раздельная трансляция. extern и static.</a>
	</ul>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="stages"></a>
  Препроцессор и раздельная трансляция.</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	   <h2>Фазы трансляции.</h2>

<p>

Сегодня  я расскажу  вам  о  средствах препроцессора,  в  том числе  о
наиболее мощном  из них -  макроопределениях с параметрами.   Затем мы
будем  говорить про  раздельную  трансляцию, познакомимся  при этом  с
ключевым словом  <em>extern</em> и узнаем  еще об одном значении  уже знакомого
вам  ключевого слова  <em>static</em>. На  этом закончится  изучение собственно
языка С (или, если угодно, С-подмножества языка С++).

</p><p>

До  сих пор  и на  лекциях, и  на практических  занятиях  мы старались
уместить текст  программы в  один файл. И  для трансляции  программы я
советовал использовать команду  <em>make</em>. Например, в редакторе создавался
файл  <em>prog.c</em>, а  затем  командой  
<em>'make&nbsp;prog'</em>  вы  получали готовую  к
заупску программу. Ну, если  вы внимательно следили за поисходящим, то
замечали,  что  команда  <em>make</em>  на  самом деле  вызывала  транслятор  -
выполняла команду  <em>'cc prog.c&nbsp;-o&nbsp;prog'</em>.  

</p><p>

Складывалось  впечатление, что  транслятор  набранный текст  программы
сразу преобразует в исполняемую  программу. Однако на самом деле текст
программы   при   этом   претерпевал   целый   ряд   невидимых   глазу
трансформаций.  Невидимых  потому, что "промежуточные  результаты" нас
не интересовали.  Однако при необходимости можно, задав соответсвующие
ключи,   получить  от   транслятора  любой   из   этих  "промежуточных
результатов". 

</p><p>

Итак, вот что на самом деле происходит с программой при трансляции:

<div>

<ol>
<li> Сначала запускается так называемый  препроцессор языка С. Он делает
из текста на языке С ... текст на языке С. Не очень понятно? Потерпите
немного.
<br><br>
<li> Затем  этот "второй" текст  на С  обрабатывается транслятором,  и в
результате  получается  текст  на  ассемблере (ассемблер  -  это  язык
низкого  уровня, состоящий  в сущности  из  символических эквивалентов
машинных команд).  Текст на  ассемблере уже учитывает специфику вашего
компьютера, его систему  команд. Но это все еще  текстовый файл, файл,
который можно читать.
<br><br>
<li> После  этого  транслятор  языка  С  запускает  для  нас  транслятор
ассемблера,  и   тот  преобразует  ассемблерную  программу   в  в  так
называемый объектный файл. Это уже не текстовый файл, а так называеымй
двоичный.   Он  содержит  уже  не символические  эквиваленты  машинных
команд,  а сами  команды.  Однако  запустить его  еще нельзя  -  в нем
остаются своего  рода "пробелы" - в частности,  так называемые внешние
ссылки  -   специальным  образом   помеченные  ссылки  на   функции  и
переменные,  которых не  нашлось в  исходном файле.   Это  могут быть,
например, ссылки на библиотечные  функции и переменные.
<br><br>
<li> И, наконец, на последнем  этапе транслятор запускает так называемый
связывающий загрузчик (linker,  loader), передавая ему имена объектных
файлов и библиотек, из которых надо собрать готовую программу.
<br><br>
</ol>


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="cpp"></a>Директивы препроцессора.</h2>
<p>

Давайте  попробуем  разобраться,  для  чего  же нужна  первая  фаза  -
препроцессор, который делает из текста на С текст на С.

</p><p>

Препроцессор читает  то, что вы набрали  в реадкторе, и  ищет в тексте
свои директивы (они так и называются "директивы препроцессора").  Если
такая директива  ему встречается, препроцессор  подставляет вместо нее
текст на  С (какой именно,  зависит от директивы). Впрочем,  не всегда
подставляет,  иногда и  выбрасывает то,  что вы  написали. Так  что на
выходе  получается  вполне законный  файл  на  языке  С.  Правда  (как
правило), гораздо более длинный и менее читаемый.  И уже не содержащий
директив   препроцессора.  Если  вам   захочется  взглянуть,   во  что
препроцессор превращает вашу программу, укажите ключ <em>'-E'</em> транслятору,
например, <em>'cc&nbsp;-E&nbsp;prog.c'</em>.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="include"></a>Директива #include</h3>
<p>


Директив препроцессора совсем немного.

Директиву    #include вы уже  знаете -  встретив ее,  
препроцессор вместо  нее всталяет
содержимое указанного  файла (кстати, при  этом и во  включаемом файле
обрабатываются  все директивы  препроцессора). Так  что, если  до этой
фазы мы имели, например. два таких файла:

<div class="incode">
    /* prog.h */<br>
    int f(int i);<br>
<br>
    /* prog.c */<br>
    #include "prog.h"<br>
    main() {<br>
    &nbsp;&nbsp;int x;<br>
    &nbsp;&nbsp;x = f(0);<br>
    }<br>
</div>

то  на  выходе  препроцессора  получим  (строки, начинающиеся  с  #  -
служебные,  и  интересны в  основном  транслятору,  можете считать  их
комментариями).

<div class="incode">
	# 1 "prog.c"<br>
	# 1 "&lt;built-in>"<br>
	# 1 "&lt;command line>"<br>
	# 1 "prog.c"<br>
<br>
	# 1 "prog.h" 1<br>
<br>
	&nbsp;&nbsp;&nbsp;&nbsp;int f(int i);<br>
	# 3 "prog.c" 2<br>
	&nbsp;&nbsp;&nbsp;&nbsp;main() {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = f(0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
</div>


Как видите, эта директива  избавляет программиста от рутинной работы -
ведь  реальные файлы-заголовки  подлиннее, чем  наш  prog.h. Например,
файл  stdio.h разворачивается  в 340  строк.  Не набирать  же все  это
вручную.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="define"></a>Макроопределение - директива #define</h3>
<p>

Макроопределение,  или   макроподстановка  -  пожалуй,   самая  мощная
директива  препроцессора.  И  вместе  с тем  самая  коварная.  Давайте
посмотрим, как ей пользоваться. Взгляните на такой кусочек программы:

<div class="incode">
    int x[100];<br>
    int y[100];<br>
    int i;<br>
<br>
    for (i=0; i&lt;100; i++) {<br>
    &nbsp;&nbsp;x[i]=fx(i);<br>
    &nbsp;&nbsp;y[i]=fy(i);<br>
    }<br>
</div>

Этот код считает значения функций fx и fy в 100 точках - например, для
того, чтобы потом построить их графики. Если нам понадобится увеличить
количество точек, придется в трех  местах заменять 100 на другое число
- и   писанины   много,   и   ошибиться  легко.   Однако   с   помошью
макроопределения мы можем облегчить себе жизнь:

<div class="incode">
    #define SIZE   100    <br>
<br>
    int x[SIZE];<br>
    int y[SIZE];<br>
    int i;<br>
<br>
    for (i=0; i&lt;SIZE; i++) {<br>
    &nbsp;&nbsp;x[i]=fx(i);<br>
    &nbsp;&nbsp;y[i]=fy(i);<br>
    }<br>
</div>

Теперь,  встретив директиву <em>#define</em>,  препроцессор будет  везде вместо
<em>SIZE</em> подставлять <em>100</em>. И когда  
нам понадобится рассчитать не 100 точек
а 150, нужно будет заменить только одно число - в строке с директивой.

</p><p>

Для тех, кто знаком с Паскалем, еще один пример использования #define:

<div class="incode">
   /* <br>
   &nbsp;&nbsp;Simulating Pascal syntax. Will be expaned to<br>
<br>
   &nbsp;&nbsp;&nbsp;&nbsp;if (i&lt;0) {<br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=-i;<br>
   &nbsp;&nbsp;&nbsp;&nbsp;}<br>
   */<br>
<br>
   #define THEN<br>
   #define BEGIN {<br>
   #define END   }<br>
<br>
   if (i&lt;0) THEN BEGIN<br>
   &nbsp;&nbsp;i=-i;<br>
   END<br>
</div>

Кстати, обратите внимание  на первую директиву - мы  не указали в ней,
на  что   THEN  надо  заменять,   так  что  это  слово   будет  просто
выбрасываться из текста программы.

</p><p>

То, что вы видели - примеры простых макроопределений, макроопределений
без  параметров. Даже  они  (если ими  разумно пользоваться)  помогают
избегать досадных ошибок и делают программы более читабельными. Однако
этим возможности директивы  #define не исчерпываются. Предположим, вам
часто  приходится  выполнять  в  программе  одну  и  ту  же  операцию,
допустим, находить меньшее из двух чисел:

<div class="incode">
     int result, x,y,z;<br>
     ...<br>
     result = ( x&lt;y ? x : y);<br>
     result = ( x&lt;z ? x : z);<br>
     result = ( x+2 &lt; y ? x+2 : y ); <br>
</div>

Операции   в    каком-то   смысле   повторяющиеся,    однако   простой
макроподстановкой тут не обойтись,  поскольку текст разный: - в первом
сравнении  x и y,  потом x  и z,  а в  последней строке  вообще вместо
первого  аргумента  стоит x+2.  Можно,  конечно, написать  простенькую
функцию, которая делает то же самое:

<div class="incode">
     int min(int a, int b) {<br>
     &nbsp;&nbsp;return ( a&lt;b ? a : b );<br>
     }  <br>
     result = min(x,y);<br>
     result = min(x,z);<br>
     result = min(x+2,y);<br>
</div>

Повторяющиеся  куски  мы изжили.  И  программа  стала более  читаемой.
Однако мы при этом проиграли в быстродействии - в программе добавились
накладные расходы на вызов функции. Оказывается, и в этом случае можно
обойтись макроопределением, правда на этот раз с параметрами:

<div class="incode">
     #define min(a, b)    ( a&lt;b ? a : b )<br>
<br>
     result = min(x,y);<br>
     result = min(x,z);<br>
     result = min(x+2,y);<br>
</div>

Встретив  такое  макроопределение,   препроцессор  не  только  заменит
<em>min(...)</em>  на указанный  текст, он  еще  и подставит  
вместо <em>a</em>  и <em>b</em>  те
аргументы,  которые  мы укажем.  И  это  снова  будет чисто  текстовая
подстановка  - транслятору  достанется тот  же  текст, что  и в  самом
первом -  еще без функций -  варианте. И при этом  программа не только
нисколько не потеряла в быстродействии,  но и стала более понятной (по
сравнению с первым вариантом).

</p><p>

В  дополнение к  этому в  макроопределениях можно  использовать другие
макроопределения - препроцессор будет расширять и их. Например:

<div class="incode">
    #define BASE 0xА000<br>
    #define cptr(offset)	(char*)(BASE+offset)<br>
    #define peek(offset)	*cptr(offset)<br>
    #define poke(offset, val)	( *cptr(offset) = val )<br>
<br>
    int i;<br>
<br>
    /* <br>
    &nbsp;&nbsp;Next statement is equivalent to<br>
    &nbsp;&nbsp;&nbsp;&nbsp;i = *(char*)(0xA000 + 5);<br>
    */<br>
    i=peek(5);<br>
<br>
    /* <br>
    &nbsp;&nbsp;Next statement is equivalent to<br>
    &nbsp;&nbsp;&nbsp;&nbsp;*(char*)(0xA000 + 5) = 'c';<br>
    */<br>
    poke(5,'c');<br>
</div>

А  в результате оказывается,  что, используя  только макроопределения,
можно писать довольно сложные программы, сравнимые по быстродействию с
программами на ассемблере (а это очень хороший показатель). И при этом
они смотрятся ничуть не хуже, чем программы с настоящими функциями.

</p><p>

Казалось  бы, все  хорошо?  Но за  все  прходится платить.  И когда  я
говорил,  что <em>#define</em>  - самая  коварная директива,  я имел  в  виду в
первую очередь именно подстановки с параметрами. Попробую объяснить, в
чем тут дело.

</p><p>

На  самом деле,  корень всех  проблем с  макроопределениями один  - мы
имеем  дело   с  текстовыми   подстановками.   То,  что   является  их
единственным   преимуществом,    одновременно   доставляет   и   массу
хлопот. Приведу только два примера.

<ul>
  <li> Сюжет первый
  
<div class="incode">
	 #define mul(a,b)  a*b<br>
<br>
	 i = mul(2,3);     /* OK, i=2*3; */<br>
 <br>
	 i = mul(2,2+1);  /* Mistake, i=2*2+1; */<br>
</div>

Как  видите, неаккуратно написанное  макроопределение может  сыграть с
нами злую  шутку -  мы собирались перемножить  операнды, но  во втором
случае получили  в результате  подстановки совсем другое  выражение. С
подобными  неприятностями,  к счастью,  нетрудно  бороться -  главное,
ставить побольше скобок при создании макроопределения:

<div class="incode">
	#define mul(a,b)    ( (a) * (b) )
</div>

обратите  внимание -  теперь в  макроопределении кажыдй  из параметров
стоит в круглых скобках. На этот раз мы получим правильное выражение

<div class="incode">
	 i = mul(2,3);     /* OK, i=( (2) * (3)); */<br>
<br>
	 i = mul(2,2+1);   /* OK, i=( (2) * (2+1)); */<br>
</div>

в обоих случаях.
<br><br>

  <li> Сюжет второй
</p><p>
Использование  макроопределения выглядит,  как  вызов функции.  Теперь
поглядим вот на такие строчки:

<div class="incode">
	   i=1;<br>
	   k=min(i++,j);<br>
           printf("%d\n",i);<br>
</div>

Второй оператор  выглядит, как вызов функции. Поскольку  параметры в С
передаются по значению, можно ожидать, что <em>printf</em> напечатает нам 2.  А
теперь   вспомним,  как  выглядело   соответсвующее  макроопределение,
которое вы недавно видели

<div class="incode">
	#define min(a,b)    ( (a)&lt;(b) ? (a) : (b) )
</div>

И попробуем расширить второй оператор "вручную"

<div class="incode">
	k = ( (i++)&lt;(j) ? (i++) : (j) );
</div>

Инкремента то на самом деле два.  Да к тому же второй (из-за специфики
троичного оператора)  выполняется только тогда, когда  <em>i&lt;j</em>. Так что
<em>printf()</em> на самом деле будет печататать  
или 2, или 3 - в зависимости от значения переменной j.

</p><p>

</ul>
<br><br>

Подобных  ситуаций можно привести  множество. Но,  как я  уже говорил,
причина у  них одна -  текстовое расширение аргументов. Так  что, если
вам  придется  ими пользоваться,  старайтесь  в  уме представить,  как
расширится  та или  иная строка.  Ну, а  уж если  с  программой начнут
происходить странные  вещи, стоит затребовать  у транслятора результат
работы  препроцессора и посмотреть,  во что  же превращается  на самом
деле ваш код.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="undef"></a>Отмена макроопределения - #undef</h3>
<p>

Эта   директива  заставляет   препроцессор   "забыть"  известное   ему
макроопределение.   Она обычно  используется, когда  программист хочет
вместо    макроопределения    написать    настоящую   функцию    (если
макроопределение  находится  в заголовке,  то  избавляться  от него  с
помощью редактора  не стоит,  да приличная система  и не  позволит вам
этого). Так, например,  мы могли бы обойти последнюю  проблему с <em>min()</em>
следующим образом:

<div class="incode">
      /* Недоступный для редактирования файл example.h */<br>
      ...<br>
      #define min(a,b)    ( (a)&lt;(b) ? (a) : (b) )<br>
      ...<br>
<br>
<br>
      /* Наша программа example.c */<br>
<br>
      #include "example.h"<br>
<br>
<br>
<br>
      #undef min<br>
<br>
      int min(int x, int y) {<br>
      &nbsp;&nbsp;return x&lt;y ? x : y;<br>
      }<br>
<br>
      ...<br>
<br>
      i=1;<br>
      k=min(i++,j);<br>
      printf("%d\n",i);<br>
</div>

Как  видите,   здесь  мы  с  помошью  директивы   <em>#undef</em>  отменили  то
макроопределение,   которое  вызывало   проблемы,  а   затем  написали
настоящую  функцию с  тем  же  именем, которая  и  будет вызываться  в
программе.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h3><a name="ifdef"></a>Директивы условной трансляции</h3>
<p>
 
Директивы этого  типа похожи по  смыслу на условные  операторы <em>if-else</em>
языка C, но управляют не  работой программы, а работой препроцессора -
позволяют включать  в программу  тот или иной  текст в  зависимости от
того, какие макроопределения у нас  есть. Их два варианта. Первый дает
больше  возможностей, позволяя  (при трансляции)  вычислять выражения,
сравнивать    константы,    проверять    наличие    тех    или    иных
макроопределений. Вынлядит это примерно так:

<div class="incode">
	 #if !defined(WORDSIZE)<br>
<br>
	 &nbsp;&nbsp;#error WORDSIZE not defined<br>
<br>
         #elif WORDSIZE==2<br>
	 /* код для архитектуры с размером слова 2 */<br>
	 &nbsp;&nbsp;...<br>
         #elif WORDSIZE==4<br>
	 &nbsp;&nbsp;/* код для архитектуры с размером слова 4 */<br>
	 &nbsp;&nbsp;...<br>
	 #else<br>
<br>
	 &nbsp;&nbsp;#error Unsupported word size<br>
<br>
	 #endif<br>
</div>

Этот  пример  иллюстрирует,  кстати,  и  основное  применение  первого
варианта директив - добиться  переносимости программы, включая тот или
иной  код  в  зависимости  от значения  какой-то  константы  (зачастую
"вшитой" прямо в транслятор). 

</p><p>

Мы сейчас не будем подробно разбираться с этим первым вариантом - если
кому  понадобится (думаю,  что  не всем  и  в любом  случае не  скоро)
прочтете сами.

</p><p>

Второй  вариант  рассчитан специально  на  проверку  флагов (то  есть,
проверку     наличия     или      отсутсвия     того     или     иного
макроопределения). Например:

<div class="incode">
	#ifdef DEBUG<br>
<br>
	/* <br>
	&nbsp;&nbsp;вызов debug_print() будет вставлен в программу только <br>
	&nbsp;&nbsp;если в момент трансляции определено имя DEBUG<br>
        */<br>
	debug_print();<br>
<br>
        #endif<br>
</div>

или

<div class="incode">	
	/* файл example.h */<br>
	#ifndef EXAMPLE_H<br>
<br>
	/* <br>
	&nbsp;&nbsp;Здесь ситуация обратная, код будет включен в программу<br>
	&nbsp;&nbsp;только в том случае, если имя EXAMPLE_H не определено<br>
        */<br>
<br>
	#define EXAMPLE_H<br>
<br>
	...<br>
<br>
	#endif<br>
</div>

Обратите  внимание -  в последнем  примере мы  прямо  внутри условного
блока  трансляции   определяем  то  самое   имя,  отсутствие  которого
проверяли в <em>#ifndef</em>. Такой  прием вы встретите в любом файле-заголовке
стандартной библиотеки. А вскоре, когда мы, наконец, доберемся до С++,
вы и сами будете им пользоваться.  А нужен он для того, чтобы избежать
многократного включения в программу  одного и того же файла-заголовка.
Теперь, если препроцессору придется обрабатывать такую программу

<div class="incode">
	/* файл example.c */<br>
	#include "example.h"<br>
	#include "example.h"<br>
</div>

то по первой  директиве он включит код, содержащийся  в условном блоке
файла <em>example.h</em>, заодно определив  и имя <em>EXAMPLE_H</em>. 
Когда он доберется
до второй директивы <em>#include</em>, ему  уже будет известно 
имя <em>EXAMPLE_H</em>, и повторного включения того-же кода не произойдет.

</p><p>

Вот,  пожалуй, и все,  что я  собирался рассказать  вам о  первой фазе
трансляции  -  препроцессоре.   Давайте  теперь  поговорим  немного  о
раздельной трансляции.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="separation"></a>
	   Раздельная трансляция. extern и static.</h2>
<p>

Пока  программа  небольшая ее  можно  держать  в  одном файле.  И  для
получения  из  текста на  С  готовой  к  запуску программы  достаточно
набрать команду

<div class="session">
	cc prog.c -o prog
</div>

которая запустит транслятор, указав  ему, что исходный текст находится
в файле <em>prog.c</em>,  а готовую программу надо записать 
в файл  <em>prog</em> ( <em>-o</em> -
это ключ, который говорит транслятору, что в следующем слове командной
строки  указано имя  выходного файла).   Однако даже  в  таком простом
случае для сборки программы  транслятор использует не только наш файл,
но и один  из стандартных библиотечных - <em>libc</em>.   А библиотека эта тоже
когда-то  была  написана  на  С  и  обработана  тем  же  транслятором.
Библиотека   <em>libc</em>  -   единственная,  которую   транслятор  подключает
автоматически.   Если же  мы в  нашей программе  используем, например,
функцию вычисления  синуса (тоже  стандартную, но хранящуюся  в другом
файле), то нам придется явно сказать об этом транслятору:

<div class="session">
	cc prog.c -lm -o prog
</div>

Здесь  <em>-l</em> -  тоже ключ  транслятора, и  этот ключ  указывает,  что для
сборки программы надо использовать дополнительную библиотеку.

</p><p>

Поскольку программы могут  использовать функции из многих библиотечных
файлов, то и ключ <em>-l</em> можно указывать несколько раз. Например, команда

<div class="session">
       сс prog.c -lm -lcrypt -o prog
</div>

подключит  не  только математическую  библиотеку,  но  и библиотеку  с
функциями шифрования. Скажу вкратце  (порой полезно бывает знать), как
разыскивается нужная библиотека. Транслятор  берет то, что стоит после
ключа <em>-l</em> и вставляет впереди  <em>lib</em>, а 
сзади добавляет суффикс <em>.so</em> или
<em>.a</em>.  То,  что  получилось,  и  есть имя  библиотечного  файла.  Так,
например,  ключу  <em>-lcrypt</em>  соответсвует  
имя файла  <em>libcrypt.so</em>  или
<em>libcrypt.a</em>. Получив имя файла, транслятор разыскивает его (для этого
у него есть список каталогов,  где могут находиться файлы библиотек) и
подключает к программе.

</p><p>

При необходимости, например, если  библиотека лежит в необычном месте,
ее  можно подключить  и без  ключа,  явным образом.  Правда для  этого
придется указать ее полное имя  вместе с путем к каталогу. Например, в
команде

<div class="session">   
	сс prog.c /usr/lib/libm.a -lcrypt -o prog
</div>

математическая  библиотека подключается  явным  образом, а  библиотека
шифрования с помощью ключа транслятора.

</p><p>

Ну  вот, библиотеки  мы подключать  научились. Давайте  теперь учиться
работать с собственными файлами.

</p><p>

Если программа большая, ее текст неудобно держать в одном файле - хотя
бы потому, что в редакторе подолгу приходится искать то место, которое
мы хотим исправить. Гораздо удобнее разбить текст на части, положив их
в разные файлы. Например, держать <em>main()</em> 
по прежнему в файле <em>prog.c</em>, а
все  функции  вынести в  файл  <em>func.c</em>.  Собрать  готовую программу  из
нескольких файлов  по прежнему не  составит труда, просто  в командной
строке надо будет указать несколько файлов:

<div class="session">
	    cc prog.c func.c -o prog
</div>

Сама  по  себе  командная  строка простая.   Однако,  чтобы  правильно
разделить    исходный   текст    на   несколько    файлов,   требуются
дополнительные, хотя  и не  слишком большие усилия.  Давайте попробуем
это  проделать  -  попытаемся  написать  программу,  которая  печатает
несколько значений  факториала.  Причем  <em>main()</em> будем держать  в файле
<em>prog.c</em>, а саму функцию для расчета факториала - в <em>func.c</em>.

</p><p>

Начнем мы с файла <em>prog.c</em>.

<div class="code">
       /* prog.c */<br>
<br>
       extern int factorial(int arg);<br>
<br>
       int main() {<br>
<br>
       &nbsp;&nbsp;int i;<br>
       &nbsp;&nbsp;for (i=0; i&lt;10;i++) {<br>
       &nbsp;&nbsp;&nbsp;&nbsp;int result = factorial(i);<br>
       &nbsp;&nbsp;&nbsp;&nbsp;printf("i=%d factorial(i)=%d\n", i. result );<br>
       &nbsp;&nbsp;}<br>
<br>
       &nbsp;&nbsp;return 0;<br>
       }<br>
</div>

Обратите внимание на строку перед <em>main</em> - в ней мы говорим транслятору,
что   где-то   (возможно    в   другом   файле)   существует   функция
<em>factorial()</em>. Напомню - это называется объявлением функции. 

</p><p>

Единственное  в  этом файле,  что  вам  раньше  не встречалось  -  это
ключевое  слово  <em>extern</em>  перед  объявлением  
функции  <em>factorial</em>.   Оно
подчеркивает  тот факт,  что  <em>factorial</em> надо  искать  где-то в  другом
месте.   Для объявления  функции это  слово не  обязательно, а  вот до
переменной, определенной в другом файле, без него не добраться.

</p><p>

Теперь файл <em>func.c</em>:

<div class="code">
       /* func.c */<br>
<br>
       static void print_error(char *s) {<br>
       &nbsp;&nbsp;printf("error in factorial: %s\n",s);<br>
       }<br>
<br>
       int factorial(int arg) {<br>
       &nbsp;&nbsp;if (arg&lt;0) {<br>
       &nbsp;&nbsp;&nbsp;&nbsp;print_error("negative argument");<br>
       &nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>
       &nbsp;&nbsp;}<br>
       &nbsp;&nbsp;else if (arg==0)<br>
       &nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>
       &nbsp;&nbsp;else<br>
       &nbsp;&nbsp;&nbsp;&nbsp;return arg*factorial(arg-1);<br>
       }<br>
</div>

Здесь  у  нас есть  сама  функция  вычисления  факториала, которую  мы
используем  в <em>main()</em>,  и 
есть  еще одна  вспомогательная,  нужная только
факториалу  -  печатающая  сообщение  об ошибке.   

</p><p>

Причем  перед этой  вспомогательной  функцией стоит  уже знакомое  вам
ключевое слово <em>static</em>.  Только смысл у этого слова теперь другой - оно
говорит транслятору, что функция <em>print_error()</em> нужна нам только в этом
файле,  и ее  надо сделать  недоступной для  других, или,  как принято
говорить, не  надо ее экспортировать.  Мы таким образом  страхуемся от
будущих ошибок -  если когда-нибудь в файле <em>prog.c</em>  появится функция c
таким же именем.  никакого конфликта не возникнет. Таким же образом с
помощью ключевого слова <em>static</em> можно запрещать и экспорт переменных.

</p><p>

По хорошему стоит еще  вынести объявление факториала в файл-заголовок,
а потом включить этот заголовок и в prog.c, и в func.c:

<div class="incode">
       /* func.h */<br>
       extern int factorial(int arg);<br>
<br>
<br>
       /* prog.c */<br>
       #include "func.h"<br>
       ...<br>
<br>
<br>
       /* func.c */<br>
       #include "func.h"<br>
       ...<br>
</div>

Вот, собственно,  наша программа  и разбита на  два (точнее даже  - на
три) файла. И мы можем, наконец оттранслировать ее:

<div class="session">
	    cc prog.c func.c -o prog
</div>

Однако и это  еще не все.  Да, работать с  исходным текстом нам теперь
будет  гораздо удобнее  -  мы имеем  вместо  длинного файла  несколько
коротких.   Однако транслятору мы  жизнь не  только не  облегчили, но,
наоборот, усложнили.  Представьте, что  мы написали и отладили один из
файлов, допустим,  <em>func.c</em>, и он  нас вполне устраивает. А  вот функцию
<em>main()</em> мы  постоянно меняем - хотим, чтобы  вывод программы покрасивей
выглядел. И  так много раз - подправили,  оттранслировали, запустили -
не  понравилось. А  транслятору  при этом  каждый  раз приходится  "за
компанию" обрабатывать и  второй файл, который мы и  не думали менять.
Шутки   шутками,  но  длинные   программы,  случается,   часами  могут
транслироваться. Так  что стоит попытаться  облегчить (не тарнслятору,
себе) жизнь. 

</p><p>

Давайте   теперь  вспомним   то,  что   я  говорил   в   самом  начале
занятия.  Исходный   текст  при  сборке   программы  претерпевает  ряд
трансформаций -  обрабатывается препроцессором, затем  преобразуется в
ассемблер, из ассемблера  - в объектный файл, и  только после этого из
объектных файлов и библиотек собирается готовая к запуску программа.

</p><p>

С  четвертой, последней фазой,  ничего не  придумаешь -  чтобы собрать
программу, нужны  все объектные файлы  и библиотеки. А вот  первые три
вполне  могут выполняться  независимо для  каждого файла.  Просто надо
указать другой ключ транслятору:

<div class="session">
	сс -с func.c
</div>

При этом он  сделает нам из исходного файла объектный  и положит его в
<em>func.o</em>.  Вот  это, собственно,  и  есть  то,  что называют  раздельной
трансляцией.  Теперь, если мы после редактирования prog.c напишем

<div class="session">
	cc prog.c func.o -o prog
</div>

(вместо <em>func.c</em> - <em>func.o</em>), 
транслятору не придется выполнять лишнюю
работу. Можно даже подготовить оба объектных файла:

<div class="session">
	сс -с prog.c<br>
        cc -c func.c<br>
</div>

а потом собирать из них программу:

<div class="session">
	cc prog.o func.o -o prog
</div>

при  этом,  после редактирования  любого  из  файлов достаточно  будет
перетранслировать только его, а затем заново собрать программу.

</p><p>

Про раздельную трансляцию можно еще много говорить - как писать
<em>Makefile</em>   (чтобы  можно   было  
пользоваться   командой   <em>make</em>),  как
автоматически     отслеживать,    какие     из     файлов    требуется
перетранслировать,   как  собирать   несколько   объектных  файлов   в
библиотеку, и так  далее. Но времени на  это у нас нет, да  и к нашему
курсу это имеет слабое отношение. Так что остановимся на этом.



</p><p>
<br><br><br>	 

<center><h2>Что дальше?</h2></center>

Хотя я и сказал, что этой темой изучение С-подмножества заканчивается, 
на следующем занятии дело до новых возможностей С++ еще не дойдет. 

На следующем занятии я кратенько расскажу вам о библиотечных функциях.
Сразу оговорюсь,  что за  разумное время просто  невозможно рассказать
обо всех имеющихся в  стандартной библиотеке полезных функциях Поэтому
лишь  о   некоторых  из  них   мы  будем  говорить  более   или  менее
подробно. Большую же часть я просто назову и скажу, для чего они нужны
- просто чтобы вы знали об их существовании.
На этом мы нынешнее занятие закончим.

</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>

