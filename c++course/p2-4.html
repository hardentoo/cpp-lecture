<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 4</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 4</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>


<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li><a href="p2-4.html#headers">Оформление файлов заголовков</a> </li>
        <li><a href="p2-4.html#ovldremark">Замечание о перегружаемых операторах</a>
	    </li>
        <li>Конструкторы и деструкторы	
	  <ul>
            <li><a href="p2-4.html#ctors">Основная идея</a></li>
            <li><a href="p2-4.html#ctorexample">Пример</a></li>
            <li><a href="p2-4.html#ctordefault">Конструктор по умолчанию</a></li>
            <li><a href="p2-4.html#ctorfields">
	       Поля данных в конструкторах и деструкторах</a></li>
            <li><a href="p2-4.html#ctorfieldinit">
	       Инициализация полей в конструкторе</a></li>
            <li><a href="p2-4.html#ctorcast">
	       Конструкторы в качестве операторов приведения типа</a></li>
            <li><a href="p2-4.html#ctorunusual">
	       Использование конструкторов и деструкторов  
	       "не по назначению"</a></li>
            <li><a href="p2-4.html#ctorexotic">
	       Экзотика - личные конструкторы и деструкторы</a></li>
            <li><a href="p2-4.html#ctorfuncenhanced">
	       Усовершенствование класса FUNCTION</a></li>
	  </ul>
	</li>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="headers"></a>Оформление файлов заголовков</h2>

<p>

И  в С,  и тем  более в  С++ для  успешной обработки  файла  с текстом
программы транслятору приходится "помогать" - снабжать его недостающими
объявлениями типов  данных, функций  и так далее.  Как вы  уже знаете,
делается это с помощью файлов заголовков.

</p><p>

Чтобы  при   сборке  программы  из  нескольких   файлов  не  возникало
конфликтов имен, в файлы  заголовков обычно помещают только объявления
- то есть, такую информацию, которая не вызывает дублирования кода, не
создает тела функций,  не резервирует память под массивы,  и так далее
(я  сказал "обычно"  потому, что  иногда в  заголовках  все-таки можно
встретить  определения  статических  переменных  - например,  если  вы
работаете с системой поддержки версий CVS).

</p><p>

На прошлых занятиях мы  уже довольно  много  говорили  о  заголовочных
файлах, и сейчас я не собираюсь повторять пройденное, а хочу лишь дать
совет, как правильно оформлять такой файл в программе на С++.

</p><p>

Прежде  всего,  стоит  позаботиться  о  том, чтобы  ваш  заголовок  не
включался в  один и тот же файл  несколько раз - точнее,  чтобы он при
повторном  включении выглядел  "пустым".   Если этого  не сделать,  то
транслятор будет  работать дольше и  в некоторых случаях  может выдать
сообщения  об  ошибках.   С  повторным включением  борются  средствами
препроцессора - директивами <em>#ifndef, #endif</em>
 и <em>#define</em>. В качестве имени
в директиве <em>#define</em> должно  какое-то уникальное среди файлов 
заголовков
имя. Обычно для этого используется имя файла заголовков, в котором все
буквы  большие,  точка заменена  символов  подчеркивания, и  добавлены
символы подчеркивания в начале и в конце имени:

</p>

<div class="code">
          /* File  my_file.h */<br>
          #ifndef _MY_FILE_H_<br>
<br>
          #define _MY_FILE_H_<br>
<br>
          /* Здесь настоящая начинка файла заголовков */<br>
<br>
          #endif<br>
</div>

Теперь, при попытке повторного включения

<div class="code">
          /* my_file.cc */<br>
          #include "my_file.h"<br>
          #include "my_file.h"<br>
          ...<br>
</div>
          
все  будет в  порядке. В  самом деле,  при такой  структуре  файла при
первом включении  транслятор еще не  знает имени <em>_MY_FILE_H_</em>,  
так что
будет обработан  блок <em>#ifndef</em> (ifndef означает 
"if  not defined", "если не определено"), а  заодно в этом блоке 
будет  определено это имя. При
повторном включении имя <em>_MY_FILE_H_</em> уже существует, так что 
содержимое блока ifndef будет проигнорировано.

</p><p>

Второе, о  чем стоит  помнить -  ваш файл могут  по ошибке  включить в
текст  на С.  Обычно С++-код  сильно отличается  от С  (даже  в файлах
заголовков), так что транслятор  скорее всего и без посторонней помощи
выдаст кучу  сообщений об ошибках. Однако не  вредно и подстраховаться
на  этот  случай -  принудительно  вызвать  ошибку,  и заодно  сделать
сообщение  о ней  более внятным.  Различаить, какой  именно транслятор
обрабатывает ваш  заголовок, можно по  имени <em>__cplusplus</em>, 
определяемом
самим  С++-транслятором. А  сообщение об  ошибке генерируют  с помощью
директивы <em>#error</em>. Вот как выглядит my_file.h с такой защитой:
</p>
<div class="code"> 

          /* File  my_file.h */<br>
          #ifndef _MY_FILE_H_<br>
<br>
          #define _MY_FILE_H_<br>
<br>
          #ifndef __cplusplus<br>
          #error Need C++-compile to process this file<br>
          #endif <br>
<br>
          /* Здесь настоящая начинка файла заголовков */<br>
<br>
          #endif<br>
</div>
<p>

Если такой файл будет обрабаытваться не С++-транслятором, то сработает
второй  блок  ifndef (имя  <em>__cplusplus</em>  не  определено), и  
транслятор выдаст то сообщение об ошибке, которое мы написали в 
директиве <em>#error</em>.
</p><p>
Теперь  несколько  слов   о  самой  начинке.   По  С   вы  уже  должны
представлять,  что она  состоит из  объявлений функций,  типов данных,
объявлений  внешних  (то   есть,  доступных,  всем  файлам  программы)
переменных,  синонимов типов,  создаваемых  инструкцией <em>typedef</em>.   
С++ добавляет сюда еще и шаблоны,  и определения классов (включая тела тех
функций, которые  заданы прямо внутри классов).  Вот возможная начинка
нашего файла заголовков:
</p>
<div class="code">
          /* File  my_file.h */<br>
          #ifndef _MY_FILE_H_<br>
<br>
          #define _MY_FILE_H_<br>
<br>
          #ifndef __cplusplus<br>
          #error Need C++-compile to process this file<br>
          #endif <br>
<br>
          extern double total;  // total - внешняя переменная<br>
<br>
          typedef void (*PVF)(); // PVF синоним типа <br>
<br>
          double hypot(double, double); // объявление функции hypot() <br>
<br>
          // Определение класса (структуры, союза)<br>
          class COMPLEX {<br>
          &nbsp;&nbsp;double re;<br>
          &nbsp;&nbsp;double im;<br>
<br>
          &nbsp;&nbsp;// Определение функции в теле класса<br>
          &nbsp;&nbsp;double real() { return re; }<br>
<br>
          &nbsp;&nbsp;// Объявление функции <br>
          &nbsp;&nbsp;// (тело в другом файле, например, в my_file.cc <br>
          &nbsp;&nbsp;double imag();<br>
          }; // End of class COMPLEX<br>
<br>
          // Шаблон функции max<br>
          template&lt;class T> <br>
          &nbsp;&nbsp;T max(T a, T b> { return a>b ? a : b; } <br>
<br>
          #endif<br>
</div>
<p>
Разумеется,  список,  представленный в  этом  файле,  неполон, но  это
хорошее приближение для начала - остальное придет с практикой.
</p>

</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ovldremark">
	    </a>Замечание о перегружаемых операторах</h2>
<p>
Всерьез  о перегружаемых  операторах (overloaded  operators)  мы будем
говорить не на  этом занятии. Однако мне бы  хотелось уже сейчас время
от времени приводить вам примеры  с подобными операторами. Поэтому я и
вынужден сейчас немного рассказать о них.
</p><p>
Операторы можно перегружать только для пользовательских типов данных -
классов и структур. В  самой перегрузке нет ничего сверхъестественного
- просто  каждый оператор  вызывает соответствующую  ему  функцию, при
этом для таких  функций действуют те же правила  перегрузки, что и для
обычных глобальных функций.
</p><p>
Имена подобных  функций начинаются  со слова operator.  Так, например,
функция 

<div class="incode"> 
  operator-() 
</div>

соответсвует  оператору   вычитания.  О  том,   где  подобные  функции
определяется, какие и сколько у  них аргументов, мы сейчас говорить не
будем  - эти  правила  разные  для различных  операторов,  так что  их
обсуждение мы оставим до лучших  времен. Пока же мне достаточно, чтобы
вы,  увидев в примере  подобную функцию-оператор,  поняли, о  чем идет
речь. Если понадобятся дополнительные  пояснения, я буду давать их при
разборе примеров.
</p><p>

Теперь  давайте продолжим знакомство  с возможностями  С++-классов. На
очереди у нас конструкторы  и деструкторы, отвечающие за инициализацию
и уничтожение объектов.
</p>
</td></tr></table>

<br>
<hr align="center" width="50%">
<h1 align="center"><a name="ctors"></a>Конструкторы и деструкторы</h1>
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2>Основная идея</h2>

<p>

Теперь вы знаете, как можно задавать методы для обработки полей данных
класса. При  должной аккуратности и  продуманном использовании уровней
доступа (<em>public</em> и  <em>private</em>) для методов и полей  
данных вы можете быть
уверены,  что любой  объект, в  котором содержатся  допустимые данные,
будет работать правильно. Взгляните на такой пример класса:

<div class="code">
          class LINE {<br>
          &nbsp;&nbsp;char *l;<br>
          public:<br>
          &nbsp;&nbsp;void set(const char *src);<br>
          &nbsp;&nbsp;void show() { cout &lt;&lt; l &lt;&lt; endl; }<br>
          };<br>
<br>
          void LINE::set(const char *src) {<br>
          &nbsp;&nbsp;if (src==0)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;throw "Zero pointer in LINE::set()";<br>
          &nbsp;&nbsp;delete[] l;<br>
          &nbsp;&nbsp;int len = strlen(src) + 1;<br>
          &nbsp;&nbsp;l = new char[len];<br>
          &nbsp;&nbsp;strcpy(l, src);<br>
          }<br>
</div>

Как    видите,   функция    <em>LINE::set()</em>,   прежде    
чем   скопировать
строку-аргумент  в  поле  l,  проверяет,  не передали  ли  ей  нулевой
указатель. Кроме того, перед  копированием в ней освобождается память,
отведенная  под  старую  строку.  Так  что если  предположить,  что  в
подобном объекте уже содержалась нормальная строка, то написав
<div class="incode">              
          LINE line;<br>
          line.set("Hello, world");<br>
          line.show();<br>
</div>
мы не  заработаем ни ошибки  времени выполнения, ни утечки  памяти.  В
этом случае у нас просто нет возможности сделать что-то неправильное с
объектом.   Мы не  можем вывести  объект  из строя,  поскольку поле  l
личное и транслятор просто не позволит его модифицировать:

<div class="incode">
          // Such attempt will give compile time error<br>
          line.l=0;<br>
</div>

Худшее, что мы можем сделать - передать нулевой указатель функции 
<em>set</em>:
<div class="incode">
          line.set(0);
</div>
но  и при  этом  поведение  объекта будет  вполне  предсказуемым -  он
возбудит исключение и передаст с ним сообщение об ошибке.
</p><p>
Но  я не зря  сделал оговорку:  - "если  предположить, что  в подобном
объекте уже содержалась нормальная  строка". С имеющимся у нас набором
функций первой  нормальной строке в объекте взяться  неоткуда. Так что
при  первом вызове  <em/l.set()</em> поле  l вполне  может  
содержать случайный
мусор, и на операторе  <em>delete[]</em> программа "сломается".  
Иными словами, наш набор функций еще не гарантирует, что объект 
будет инициализирован (то есть, создан) правильно.
</p><p>
Есть и другая проблема с  таким классом. Когда придет время, программа
уничтожит объект
<div class="incode">          
          {<br>
          &nbsp;&nbsp;LINE line;<br>
          &nbsp;&nbsp;line.set("Hello");<br>
          &nbsp;&nbsp;line.show()<br>
          }<br>
          //   At this point, object line already destroyed,<br>
          // but the memory, allocated for line.l, is not freed<br>
</div>
но память,  отведенную под строку, не освободит.  В программе появится
утечка памяти.
</p><p>
Для  решения этих  проблем предусмотрены  специальные  функции-члены -
конструкторы   и   деструкторы.    Первые   отвечают   за   правильную
инициализацию объекта при оздании,  вторые - за выполнение завершающих
операций перед его уничтожением.
</p><p>
Конструкторы - это специальная разновидность функций-членов с таким же
именем, как у своего класса. Например, <em>A::A()</em> - конструктор 
для класса <em>A</em>.   У конструкторов  нет  типа возвращаемого  
значения,  для них  нет
самого понятия  "возвращаемое значение".  Но  у них может  быть список
аргументов,  и  к  ним  применяются  обычные  правила  для  перегрузки
функций. Из того, что  они отвечают за инициализацию вновь создаваемых
объектов, вытекает  одна их важная  особенность - в тот  момент, когда
работает конструктор,  объект еще не создан, под  него только выделена
память. В  практическом смысле это  означает, что в  коде конструктора
можно не  беспокоиться о предыстории  объекта (освобождать захваченную
ранее память, закрывать открытые ранее файлы, и т.п.).
</p><p>
Деструктор  - это  тоже специальная  функция-член, ее  имя формируется
добавлением перед именем класса значка ~ (тильда), например, 
<em>A::~A()</em> -
деструктор для  класса <em>A</em>.   Как и у  конструкторов, 
у  деструктора нет
типа   возвращаемого  значения.    В  отличие   от   конструкторов,  у
деструктора не может быть  параметров, поэтому не бывает перегружаемых
деструкторов.     Обычно    деструкторы    вызываются    автоматически
непосредственно перед тем,  как программа освободит память, отведенную
под объект  (например, когда автоматический объект  выходит из области
видимости).   Но при  необходимости можно  вызвать деструктор  и явным
образом.

</p><p>

У  класса  могут  быть  определенные пользователем  конструкторы,  или
деструктор, или и  те и другие, или, наоборот, ни  тех ни других. Если
вы не  определяете в классе конструкторы и  деструкторы, то транслятор
автоматически создаст деструктор и несколько вариантов конструкторов с
поведением  по умолчанию  (о том,  какое это  поведение,  мы поговорим
позже).   Деструктор  и  конструкторы   можно  реализовывать   в  виде
встраиваемых (inline) функций, но это не обязательное условие.
</p>
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorexample"></a>Пример</h2>

<p>
Теперь давайте  посмотрим на пример,  который поможет вам  понять, как
пишутся конструкторы и деструкторы.
<div class="code">
          // Example program with constructors and destructor<br>
          #include &lt;iostream><br>
          using namespace std;<br>
<br>
          class TEST {<br>
<br>
          &nbsp;&nbsp;// private member function for use in constructors <br>
          &nbsp;&nbsp;// and in a destructor<br>
          &nbsp;&nbsp;void message(const char*);<br>
          public:<br>
<br>
          &nbsp;&nbsp;// // All constructors have no return type<br>
          &nbsp;&nbsp;// // but differ in number and type of arguments <br>
<br>
          &nbsp;&nbsp;// Constructor without arguments (default constructor)<br>
          &nbsp;&nbsp;// Implemented inline<br>
          &nbsp;&nbsp;TEST() { message("TEST()"); }<br>
<br>
          &nbsp;&nbsp;// Constructor with one int argument<br>
          &nbsp;&nbsp;TEST(int);<br>
<br>
          &nbsp;&nbsp;// Constructor with two int arguments<br>
          &nbsp;&nbsp;TEST(int,int);<br>
<br>
          &nbsp;&nbsp;// Constructor with const char* argument<br>
          &nbsp;&nbsp;TEST(const char*);<br>
<br>
          &nbsp;&nbsp;// Destructor - no return type, no arguments<br>
          &nbsp;&nbsp;~TEST();<br>
          };  // END of ckass TEST definition<br>
<br>
          // Definitions for non-inline member-functions<br>
<br>
          void TEST::message(const char *msg) {<br>
          &nbsp;&nbsp;cout &lt;&lt; "TEST::" &lt;&lt; msg &lt;&lt; " called." &lt;&lt; endl;<br>
          }<br>
<br>
          TEST::~TEST() { message("~TEST()"); }       <br>
          TEST::TEST(int) { message("TEST(int)"); }<br>
          TEST::TEST(int,int) { message("TEST(int,int)"); }<br>
          TEST::TEST(const char*) { <br>
          &nbsp;&nbsp;message("TEST(const char*)"); <br>
          }<br>
</div>
Итак,  сам  класс мы  написали.  Теперь  давайте  посмотрим, какие  из
функций   и   когда  вызываются   при   разных  формах   инициализации
объектов. Нам в этом поможет небольшая тестовая программа:
<div class="code">
          ... // Class TEST definition<br>
<br>
          // Sample program<br>
          main() {<br>
          &nbsp;&nbsp;TEST a;<br>
          &nbsp;&nbsp;TEST b(1);<br>
          &nbsp;&nbsp;TEST c(1.5);<br>
          &nbsp;&nbsp;TEST d("hello");<br>
          &nbsp;&nbsp;TEST e(1,2);<br>
          &nbsp;&nbsp;TEST f=TEST(1.5,'c');<br>
<br>
          &nbsp;&nbsp;cout &lt;&lt; endl; // for more readable output<br>
          }<br>
</div>
Если  такую  программу оттранслировать  и  запустить,  то она  выведет
следующее:
<div class="session">
          TEST::TEST() called.<br>
          TEST::TEST(int) called.<br>
          TEST::TEST(int) called.<br>
          TEST::TEST(const char*) called.<br>
          TEST::TEST(int,int) called.<br>
          TEST::TEST(int,int) called.<br>
<br>
          TEST::~TEST() called.<br>
          TEST::~TEST() called.<br>
          TEST::~TEST() called.<br>
          TEST::~TEST() called.<br>
          TEST::~TEST() called.<br>
          TEST::~TEST() called.<br>
</div>
О чем говорит  такой вывод программы? В примере  мы определяли объекты
класса <em>TEST</em>  и инициализировали их. Причем  инициализация 
задавалась в одном из трех видов:
<div class="incode">
          Type a(i);<br>
          Type a=i;<br>
          Type a=Type(i);<br>
</div>
При  этом  при  создании  объекта вызывался  подходящий  по  сигнатуре
конструктор. Например, для
<div class="incode">       
          TEST f(1.5,'c');
</div>
подходящим оказался конструктор <em>TEST(int,int)</em>, и так далее.
</p><p>
Когда же  объекты класса выходят из области  видимости и уничтожаются,
для  каждого  из  них   вызывается  деструктор.  В  нашем  случае  это
происходит при  окончании функции <em>main()</em>, так что  в последних 
строках вывода мы видим шесть вызовов деструктора <em>~TEST()</em>.
</p>
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctordefault"></a>
	    Конструктор по умолчанию (default constructor)</h2>

<p>

Объект  <em>a</em>,  который мы  не  инициализировали  явно,  
тоже не  оказался
забытым  - для его  инициализации был  вызван конструктор  <em>TEST()</em>, 
так
называемый  конструктор  по  умолчанию (default  constructor).   Такой
конструктор вызывается во всех случаях, когда требуется создать объект
без явной инициализации.  В том  числе, при создании массива с помощью
<em>new[]</em> он будет вызван для  каждого элемента массива. Именно это 
я имел
в виду,  когда на прошлом  занятии говорил, что при  создании массивов
все элементы инициализируются одним  и тем же значением, которое задал
разработчик  класса. Теперь вы  знаете, что  это значение  заносится в
объект в конструкторе по умолчанию.
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorfields"></a>
	    Поля данных в конструкторах и деструкторах</h2>

<p>

В конструкторах и деструкторах  можно пользоваться полями данных (data
members)  класса так  же, как  и  в обычных  методах класса.   Память,
необходимая для полей данных,  захватывается до вызова конструктора, а
освобождается после  вызова деструктора. Благодаря этому,  в то время,
когда конструкторы и деструкторы  работают, поля данных уже существуют
и еще не уничтожены.

</p><p>

Более того,  если у  класса есть поле  данных, которое в  свою очередь
тоже  является объектом класса,  то конструктор  для этого  поля будет
вызван  до, а деструктор  - после  конструктора и  деструктора первого
класса. Для того,  чтобы это стало понятнее, давайте  напишем еще одну
тестовую программу:
<div class="code">
          #include &lt;iostream><br>
          using namespace std;<br>
<br>
          class A {<br>
          public:<br>
          &nbsp;&nbsp;A() { cout &lt;&lt; "A::A() called." &lt;&lt; endl };<br>
          &nbsp;&nbsp;~A() { cout &lt;&lt; "A::~A() called." &lt;&lt; endl };<br>
          };<br>
<br>
          class B {<br>
          &nbsp;&nbsp;A a;<br>
          public:<br>
          &nbsp;&nbsp;B() { cout &lt;&lt; "B::B() called." &lt;&lt; endl };<br>
          &nbsp;&nbsp;~B() { cout &lt;&lt; "B::~B() called." &lt;&lt; endl };<br>
          };<br>
<br>
          main() {<br>
<br>
          &nbsp;&nbsp;cout &lt;&lt; "Creating object of class B" &lt;&lt; endl &lt;&lt; endl; <br>
          &nbsp;&nbsp;B x;<br>
            <br>
          &nbsp;&nbsp;cout &lt;&lt; endl <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "Object of class B goes out of scope"  <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; endl;<br>
          }<br>
</div>
Как видите, класс  B содержит объект класса A  в качестве поля данных.
Такая программа напечатает нам следующее:
<div class="session">
          Creating object of class B<br>
          A::A() called.<br>
          B::B() called.<br>
<br>
          Object of class B goes out of scope<br>
          B::~B() called.<br>
          A::~A() called.<br>
</div>

В таком  поведении (конструкторы поля  вызываются до, а  деструкторы -
после  конструкторов  и  деструкторов  самого объекта)  есть  глубокая
объектно-ориентированная  правда. В самом  деле, раз  уж конструкторам
дозволено  работать с  полями данных  объекта, то  эти поля  к моменту
вызова   конструктора   уже    должны   быть   правильно   созданы   и
инициализированы. А  в случае полей, которые  сами являются объектами,
этим как  раз и занимаются  конструкторы этих полей.   С деструкторами
такая  же картина  - им  для работы  могут потребоваться  поля данных,
поэтому  деструкторы  этих  полей  вызываются только  после  основного
деструктора.
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorfieldinit"></a>
	      Инициализация полей в конструкторе</h2>

<p>

Задача  конструктора  -  правильно  инициализировать объект,  все  его
поля. Как только  что было сказано, к моменту  вызова конструктора все
поля объекта уже созданы.  Но вывод последнего примера показывает, что
для    создания     поля    был    вызван     его    конструктор    по
умолчанию. Естественно, такой вариант не годится на все случаи жизни -
зачастую  желатеоьно  явно  инициализировать  поле  данных  каким-либо
значением.  Можно пытаться  воспользоваться оператором  присваивания в
теле конструктора, например
<div class="code">
          class BUFFER {<br>
          &nbsp;&nbsp;size_t size;<br>
          &nbsp;&nbsp;char *buf;<br>
          public:<br>
          &nbsp;&nbsp;BUFFER(size_t sz) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;size = sz;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;buf = new char[sz];<br>
          &nbsp;&nbsp;}<br>
          &nbsp;&nbsp;...<br>
          };<br>
</div>
Так нередко и делают. Но у подобного способа есть два недостатка.
</p><p>
Во-первых, в теле конструктора  поля данных уже созданы. Это означает,
что   будь  у   нас   какое-нибудь  поле   не   встроенного  типа,   а
пользовательского,  то  для него  уже  был  бы  вызван конструктор  по
умолчанию. И лишь  после этого мы бы с  помощью присваивания занесли в
него нужное значение. Два вызова  вместо одного, и в результате потеря
эффективности.
</p><p>
Во-вторых,  для  некоторых  полей  вообще  нельзя  применять  оператор
присваивания,  это запрещено  правилами языка.   Ведь поле  может быть
константой или ссылкой:
<div class="code">
          class TRICKY {<br>
          &nbsp;&nbsp;const int a;<br>
          &nbsp;&nbsp;int&  b;<br>
          public:<br>
<br>
          &nbsp;&nbsp;// Would like to set a=i and to bind b with j;<br>
          &nbsp;&nbsp;TRICKY(int i, int &j) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// a already created, we can not change const<br>
          &nbsp;&nbsp;&nbsp;&nbsp;???<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// b already created, we can not rebind reference<br>
          &nbsp;&nbsp;&nbsp;&nbsp;???<br>
          &nbsp;&nbsp;};<br>
          &nbsp;&nbsp;...<br>
          }<br>
</div>
Как  видно  из   этого  примера,  поля  <em>a</em>  и   <em>b</em>  
должны  быть  именно
инициализированы, присваивание здесь не годится.
</p><p>
Для решения подобных  проблем в конструкторе после его  имени и списка
аргументов можно поставить двоеточие  и указать явную инициализацию для
полей -  список инициализаторов.
<div class="code">
          class TRICKY {<br>
          &nbsp;&nbsp;const int a;<br>
          &nbsp;&nbsp;int&  b;<br>
          public:<br>
<br>
          &nbsp;&nbsp;// Would like to set a=i and to bind b with j;<br>
          &nbsp;&nbsp;TRICKY(int i, int &j) : a(i), b(j) <br>
          &nbsp;&nbsp;{<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// Now ok, a initialized with i, b bound with j<br>
          &nbsp;&nbsp;};<br>
          &nbsp;&nbsp;...<br>
          };<br>
</div>
Такая запись означает именно инициализацию, а не присваивание, так что
обе проблемы оказываются  решены. Инициализировать таким образом можно
и  поля  встроенных  типов,  и   объекты  -  в  последнем  случае  для
поля-объекта   будет  вызван  конструктор   с  подходящими   типами  и
количеством аргументов.
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorcast"></a>
	      Конструкторы в качестве операторов приведения типа</h2>

<p>

Напомню, если  в программе требуется заслать в  переменную одного типа
значение  другого  типа,   используется  (явно  или  неявно)  оператор
приведения:
<div class="code">
        int i = 1;<br>
        double d;<br>
        <br>
        d = i;   // Неявное приведение int->double<br>
        d = (double)i; // Явное приведение int->double, С-стиль<br>
        d = double(i); // То же, С++-стиль (функциональная нотация)<br>
</div>
Такая  же  возможность  предусмотрена  и  для  пользовательских  типов
данных.  Делается  это двумя способами.  При первом способе  в классах
для  того, чтобы  сделать возможным  преобразование от  одного  типа к
другому,  задают  специальные  функции  - операторы  приведения  типа.
Например, в классе
<div class="code">
        class Integer {<br>
        &nbsp;&nbsp;int i;<br>
        public:<br>
<br>
        &nbsp;&nbsp;Integer(int val) : i(val) {};<br>
        &nbsp;&nbsp;operator int() { return i; }<br>
<br>
        };<br>
</div>
вторая  функция, <em>"operator  int"</em>  - это  оператор  приведения 
от  типа
<em>Integer</em>  к типу  <em>int</em>. Именно  эта  функция 
будет  вызвана при  неявном
приведении типа в показанном ниже фрагменте кода
<div class="incode">
        Integer a1(10); <br>
        int a2;<br>
<br>
        a2 = a1; // Неявный вызов Integer::operator int();<br>
</div>
и ее возвращаемое значение будет заслано в переменную a2.  Этот способ
позволяет  выполнять   преобразование  от  пользовательского   типа  к
встроенному или  пользовательскому.  Однако  с его помошью  не удастся
преобразовать  встроенный  тип  в  пользовательский -  набор  подобных
функций приведения для встроенных типов жестко зашит в транслятор.
</p><p>
Эту прореху закрывает второй способ. Посмотрите внимательнее на первую
строку, в  которой инициализируется объект  типа <em>Integer</em>.  
Разумеется,
<em>a1(10)</em> - это  обращение к конструктору, но по  записи оно очень 
похоже
на приведение типа в функциональной нотации.  Да и по смыслу тоже - мы
создаем объект,  содержимое которого соответсвует  целому значению 10,
то есть переходим от типа <em>int</em> к типу <em>Integer</em>.
</p><p>
Так оно  и есть  на самом деле  - конструкторы могут  использоваться в
качестве операторов приведения типа. Если вы напишете
<div class="incode">
         Integer a1;<br>
         int a2=10;<br>
<br>
         a1=Integer(10);<br>
</div>
то  в третьей строке  будет вызван  конструктор 
<em>Integer::Integer(int)</em>,
который  создаст  безымянный  объект,  а потом  оператор  присваивания
зашлет этот объект в переменную  a1. Причем это не кулибинский рецепт,
подобное   использование   конструкторов   для  приведения   типов   -
стандартный  и  единственный способ  перехода  от  встроенного типа  к
пользовательскому.  Разумеется, у  приведения с  помощью конструкторов
тоже есть ограничения. Если с помощью операторов приведения невозможно
перейти от  встроенного типа к пользовательскому,  то с конструкторами
противоположная   ситуация   -    они   не   позволяют   преобразовать
пользовательский тип во встроенный. Но,  имея и те и другие, вы можете
выполнять любые преобразования.
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorunusual"></a>
	      Использование конструкторов и деструкторов  
	      "не по назначению"</h2>

<p>

Хотя   конструкторы   и   дестуркторы   придуманы  для   того,   чтобы
гарантировать целостность  и правильное функционирование  объектов, их
вполне можно использовать не по назначению, эксплуатируя тот факт, что
они автоматически вызываются  при создании/уничтожении объектов. Порой
это  оказывается  весьма удобным.   Приведу  лишь  один пример,  чтобы
пояснить идею
<div class="code">
          class TIMER {<br>
          &nbsp;&nbsp;time_t tstart;<br>
          public:<br>
          &nbsp;&nbsp;TIMER() {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;time(&tstart);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; "timer started " &lt;&lt; endl;<br>
          &nbsp;&nbsp;}<br>
<br>
          &nbsp;&nbsp;~TIMER()  {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;time_t tstop;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;time(&tstop);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; "timer stopped, elapsed " <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; difftime(tstop,tstart) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; " seconds"&lt;&lt; endl;<br>
          &nbsp;&nbsp;}<br>
          };<br>
<br>
          main() {<br>
          &nbsp;&nbsp;TIMER dummy;<br>
          &nbsp;&nbsp;...;<br>
          }<br>
</div>

Как видите, здесь в  начале функции <em>main()</em> создается 
переменная <em>dummy</em>,
после  чего мы  ее больше  никак не  используем. При  этом конструктор
<em>TIMER()</em> выводит  сообщение <em>"timer  started"</em> и 
запоминает  время своего
вызова (то есть,  тот момент, когда начала работать  <em>main()</em>.  
Когда же
программа  закончится,  будет   вызван  деструктор  <em>~TIMER()</em>,  
который сообщит, сколько  времени заняло выполнение  программы 
(именно столько времени и просуществовал объект dummy).
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorexotic"></a>
	      Экзотика - личные конструкторы и деструкторы</h2>

<p>

До сих  пор в примерах я  помещал конструкторы и  деструкторы только в
public-секцию. Оно и неудивительно -  чтобы та же функция main() могла
создавать  и  уничтожать  объекты  класса,  ей  нужен  доступ  к  этим
функциям.
</p><p>
Однако ничто  не запрещает  делать конструкторы личными  (private). На
первый взгляд  подобная идея может  показаться диковатой -  кому нужен
класс, если нельзя создавать его объекты? Однако не торопитесь.
</p><p>
Поместив дестурктор  в личную  секцию, вы запретите  создание объектов
везде,  кроме  дружественных  функций  -  поскольку  созданный  объект
невозможно   уничтожить,  транслятор   будет  выдавать   сообщение  об
ошибке.  Однако в  дружественных  функциях такие  объекты можно  будет
использовать.  Например, объекты приводимого  ниже класса  можно будет
создавать только в функции main():
<div class="incode">
      class TEST {<br>
      &nbsp;&nbsp;friend int main();<br>
      &nbsp;&nbsp;~TEST() {};<br>
      };<br>
</div>
С личными  конструкторами класса ситуация  аналогичная.  Но, поскольку
конструкторов в  классе может быть несколько  (деструктор, если вообще
есть, то  только один), то  и область применения  личных конструкторов
немного шире. Поместив часть  конструкторов в личную секцию класса, вы
запретите для внешнего  мира соответсвующие им варианты инициализации,
поскольку  программист, использующий  подобный  класс, будет  вынужден
пользоваться только публичными конструкторами. Например, в классе
<div class="code">
      class TEST {<br>
      private:<br>
      &nbsp;&nbsp;TEST() {};<br>
      &nbsp;&nbsp;int value;<br>
<br>
      public:<br>
      &nbsp;&nbsp;TEST(int val) : value(val) {};<br>
      };<br>
<br>
      main() {<br>
      &nbsp;&nbsp;TEST a;   // Compiler error - can not use private TEST();<br>
      &nbsp;&nbsp;TEST b(1); // OK, public TEST(int) used<br>
      }<br>
</div>
личным сделан  конструктор по умолчанию, так что  в программе придется
все  объекты этого  класса  инициализировать явно.  Между прочим,  это
означает, что  и создать массив подобных объектов  с помощью оператора
<em>new[]</em> не удастся.
</p><p>
Не  могу сказать, чтобы  я часто  пользовался этими  возможностями, но
иногда подобная гибкость оказывается полезной при разработке классов.
</td></tr></table>

<br>
<hr align="center" width="50%">
<br>

   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="ctorfuncenhanced"></a>
	      Усовершенствование класса FUNCTION</h2>

<p>

И в  завершение сегодняшнего  занятия давайте с  помощью конструкторов
усовершенствуем  тот класс  <em>FUNCTION</em>,  который я  показывал в  
прошлый раз. Напомню сначала, как он выглядел и использовался:

<div class="code">
         class FUNCTION {<br>
         &nbsp;&nbsp;double coeff1,coeff2; // private fields - coefficients<br>
         public:<br>
         &nbsp;&nbsp;// Inline member functions for setting coefficients<br>
         &nbsp;&nbsp;void set(double a) {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;coeff1 = a;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;coeff2 = 0;<br>
         &nbsp;&nbsp;}<br>
<br>
         &nbsp;&nbsp;void set(double a, double b) {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;coeff1 = a;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;coeff2 = b;<br>
         &nbsp;&nbsp;}<br>
<br>
         &nbsp;&nbsp;// function declaration for calcullating ax+b<br>
         &nbsp;&nbsp;double f(double x);<br>
         };<br>
<br>
         main() {<br>
         &nbsp;&nbsp;FUNCTION f1, f2;<br>
         &nbsp;&nbsp;f1.set(-1);      // y=-x<br>
         &nbsp;&nbsp;f2.set(2,1);     // y=2x+1<br>
<br>
         &nbsp;&nbsp;// Calcullate and print both functions for x=10<br>
         &nbsp;&nbsp;cout &lt;&lt; f1.f(10) &lt;&lt; endl;<br>
         &nbsp;&nbsp;cout &lt;&lt; f2.f(10) &lt;&lt; endl;<br>
         }<br>
</div>

Как  вы  понимаете, вместо  методов  <em>set()</em>  вполне можно  
использовать
конструкторы.   Впрочем,  еще  удобнее просто  дописать  конструкторы,
вызвав  из них  подходящую  фунцию <em>set()</em>  -  тогда мы  
сможем и  сразу
создавать нужные объекты, и менять коэффициенты в уже существующих, да
и интерфейс класса останется  совместимым со старой программой.  А еще
я для  драматического эффекта перепишу  для класса оператор  <em>()</em> 
вызова функции -  при этом использование объектов станет  выглядеть как вызов
обычных функций. Итак, вот  новый, расширенный вариант класса 
<em>FUNCTION</em>
(для краткости  я привожу только  дополнения к классу и  новую функцию
main):
<div class="code">
         class FUNCTION {<br>
         &nbsp;&nbsp;...<br>
         public:<br>
         &nbsp;&nbsp;FUNCTION(double a) { set(a); }<br>
         &nbsp;&nbsp;FUNCTION(double a, double b) { set(a,b); }<br>
         &nbsp;&nbsp;double operator ()(double x) { return f(x); }<br>
         &nbsp;&nbsp;...<br>
         };<br>
<br>
         main() {<br>
         &nbsp;&nbsp;// f1=-x  , f2=2x+1<br>
         &nbsp;&nbsp;FUNCTION f1(-1), f2(2,1);<br>
<br>
         &nbsp;&nbsp;// Calcullate and print both functions for x=10<br>
         &nbsp;&nbsp;cout &lt;&lt; f1(10) &lt;&lt; endl;<br>
         &nbsp;&nbsp;cout &lt;&lt; f2(10) &lt;&lt; endl;<br>
         }<br>
</div>
Как видите, функция  main стала короче, проще и  понятнее. Правда само
описание класса <em>FUNCTION</em> несколько  распухло - но это неизбежная плата
за новые возможности.
</p><p>
Давайте закончим на этом сегодняшнее занятие. В следующий раз мы снова
будем говорить  про классы  (и про конструкторы,  в том  числе), более
подробно  посмотрим,  как надо  перегружать  различные операторы.   И,
надеюсь,  через  пару  занятий  дойдем  до  очень  интересной  темы  -
наследования.

</p>
    </td>
  </tr>
</table>


</div>
</body>
</html>
