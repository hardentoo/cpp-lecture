<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 8</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 8</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
        <ul>
`         <li>С++-стиль ввода-вывода
	  <ul>
	    <li><a href="p2-8.html#cppio-main">Основные факты</a>
	    <li><a href="p2-8.html#cppio-exc">Работа над ошибками</a>
	    <li><a href="p2-8.html#cppio-altin">Альтернативные функции ввода</a>
	    <li><a href="p2-8.html#cppio-altout">Альтернативные функции вывода</a>
	    <li><a href="p2-8.html#cppio-virt">Виртуальные 
	       friend-функции для операторов ввода-вывода</a>
	    <li><a href="p2-8.html#cppio-fmt">Управление форматным выводом</a>
	    <li><a href="p2-8.html#cppio-fmtfuncs">
	      Функции-не флаги для управления форматом</a>
	    <li><a href="p2-8.html#cppio-iomanip">Манипуляторы</a>
	    <li><a href="p2-8.html#cppio-sfstreams">Файловые и строковые потоки</a>
	  </ul>
       </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-main"></a>Основные факты</h2>
<p>
Вы уже немного знакомы с потоками ввода-вывода в С++. Напомню основные
факты.
<ol>
<li>Каждой программе сразу после старта доступны несколько стандартных
потоков:
<br>
<div align="center">
<table width="80%">
 <tr>
   <td width="20%" valign="top"><em>cin</em></td>
   <td>стандартный ввод, аналог <em>stdin</em> в C.</td>
 </tr>
 <tr>
   <td width="20%" valign="top"><em>cout</em></td>
   <td>стандартный буферизованный вывод (аналог <em>stdout</em>).</td>
 </tr>
 <tr>
   <td width="20%" valign="top"><em>cerr</em></td>
   <td>стандартный небуферизованный поток для сообщений об
		  ошибках (аналог <em>stderr</em>).</td>
 </tr>
 <tr>
   <td width="20%" valign="top"><em>clog</em></td>
   <td>то же, что и <em>cerr</em>, но с буферизацией.</td>
 </tr>
</table>
</div>
<br>
   По умолчанию эти потоки связаны с управляющим терминалом, но
   командами оболочки могут быть перенаправлены на другие устройства
   или файлы.
   <br>&nbsp;
<li>Для того, чтобы пользоваться средствами C++ ввода-вывода, задача
   должна включить файл заголовков &lt;iostream>:
<div class="code">
      #include &lt;iostream&gt;<br>
      using namespace std;<br>
      ...<br>
</div>
   <br>&nbsp;
<li>Для ввода-вывода используются операторы сдвига &lt;&lt; и &gt;&gt;:
<div class="code">
      main() {<br>
      &nbsp;&nbsp;int i;<br>
      &nbsp;&nbsp;double f;<br>
      &nbsp;&nbsp;// прочесть два числа из cin<br>
      &nbsp;&nbsp;cin &gt;&gt; i &gt;&gt; f;<br>
      &nbsp;&nbsp;// вывести в cout<br>
      &nbsp;&nbsp;cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; " f=" &lt;&lt; f &lt;&lt; endl;<br>
      }<br>
</div>
   Несмотря на "одинаковость" формы записи для ввода-вывода значений
   разных типов, в каждом случае вызывается своя, соответствующая типу
   функция ввода-вывода. Такое возможно благодаря перегруженным для
   разных типов аргументов операторам  &lt;&lt; и &gt;&gt; в классах
   потоков ввода-вывода.
   <br>&nbsp;
<li> Вы можете расширять возможности C++ ввода-вывода, определяя
   операторы &lt;&lt; и &gt;&gt; для разрабатываемых вами классов. При этом
   операторы должны быть реализованы в виде дружественных функций, с
   первым аругментом - ссылкой на поток. Например, определив класс
<div class="code">
       class Complex {<br>
       public:<br>
       &nbsp;&nbsp;double re, im;<br>
       &nbsp;&nbsp;friend ostream&<br>
       &nbsp;&nbsp;&nbsp;&nbsp;operator&lt;&lt;(ostream&amp; 
                 os, Complex&amp; v);<br>
       &nbsp;&nbsp;friend istream&<br>
       &nbsp;&nbsp;&nbsp;&nbsp;operator&gt;&gt;(istream&amp; 
                 is, Complex&amp; v);<br>
       };<br>
</div>
   и сами функции
<div class="code">
       ostream&amp;<br>
       &nbsp;&nbsp;operator&lt;&lt;(ostream& os, Complex& v)<br>
       {
       &nbsp;&nbsp;os &lt;&lt; v.re &lt;&lt; v.im;<br>
       &nbsp;&nbsp;return os;<br>
       }<br>
       <br>
       istream&amp;<br>
       &nbsp;&nbsp;operator&gt;&gt;(istream&amp; is, Complex&amp; v)<br>
       {<br>
       &nbsp;&nbsp;is &gt;&gt; v.re &gt;&gt; v.im;<br>
       &nbsp;&nbsp;return is;<br>
       }<br>
</div>
   вы тем самым определите операторы ввода-вывода для комплексных
   чисел, и сможете считывать и выводить такие числа наравне со
   значениями других типов (с точностью до обработки ошибок):
<div class="code">
       main() {<br>
       &nbsp;&nbsp;Complex c;<br>
       &nbsp;&nbsp;// считываем комплексное число<br>
       &nbsp;&nbsp;cin >> c;<br>
       &nbsp;&nbsp;// печатаем комплексное число.<br>
       &nbsp;&nbsp;cout &lt;&lt; c &lt;&lt; endl;<br>
       }<br>
</div>
</ol>
Но все перечисленное выше - лишь тот минимальный набор, которого может
хватить только  самым простым  программам. Мы за весь курс ни  разу не
затрагивали  такие  вопросы,  как  можно  подстраивать  формат  вывода
(например,  для печати  таблиц), как  проверять, не  произошла  ли при
вводе  ошибка,  как открывать  потоки  для  работы  с файлами.   Да  и
операторами    >>    и   &lt;&lt;    возможности    потоков    в   С++    не
исчерпываются.   Сегодня   я   постараюсь   немного   расширить   ваши
представления о возможностях потоков в С++.
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-exc"></a>Работа над ошибками</h2>
<p>
Давайте  для  начала  посмотрим,  как управляться  с  ошибками. На
выводе ошибки  - вещь довольно  редкая (хотя  тоже случаются),  
так что  разбирать обработку ошибок мы будем на примере работы 
с входными потоками.
</p><p>
Итак, какие вообще могут возникать ошибки при вводе?
</p><p>
Прежде всего, входной поток может завершиться (это, строго говоря, не
ошибка - просто программа достигла конца входного файла). Вторая
причина - формат вводимых данных не соответсвует тому, что ожидает
программа. Например, при вводе восьмеричного числа встретилась цифра
9. И, наконец, это ошибки входного устройства (например, при чтении
диск дал сбой).
</p><p>
Для того, чтобы программа могла определить, как прошла операция
ввода-вывода, каждый поток имеет связанное с ним состояние. Мы неявно
уже пользовались проверкой состояния потока, когда писали ввод
значений в цикле:
<div class="code">
	 while (cin >> i)<br> 
	 &nbsp;&nbsp;cout &lt;&lt; i &lt;&lt; endl;<br>
</div>
Здесь в заголовке цикла неявно вызывается оператор проверки состояния
потока, который возвращает true только в том случае, если операция
ввода прошла успешно.
</p><p>
Состояние потока  определяется набором из 4 флагов  - <em>badbit</em>, 
<em>failbit</em>, <em>eofbit</em>, <em>goodbit</em>.  Все эти флаги 
определены в  классе <em>ios_base</em>, который
является  базовым  для  всех  классов  потоков.  Первые  два  означают
возникновение ошибки  на последней операции  ввода-вывода (причем, как
пишет  сам  создатель  языка,  различие между  ними  незначительное  и
интересно в основном тем, кто создает операторы ввода-вывода для новых
классов).  Третий означает  достижение конца  файла. Четвертый  флаг -
<em>goodbit</em>  - означает  отсутствие  трех первых,  это признак  
безупречно прошедшей операции ввода-вывода.
</p><p>
Для считывания флагов состояния в классах потоков определены
специальные функции:
<div class="code">
	    bool bad();<br>
	    bool fail();<br>
	    bool eof();<br>
	    bool good();<br>
</div>
Приведенную выше проверку в заголовке цикла можно было бы переписать
(точнее, записать в явном виде) с помощью этих функций следующим образом:
<div class="code">
	  while ( (cin >> i), cin.good() )<br>
	  &nbsp;&nbsp;cout &lt;&lt; i &lt;&lt; endl;<br>
</div>
К тому же, по выходу из цикла можно попытаться разобраться в причине ошибки:
<div class="code">
          if (cin.bad())<br> 
	  &nbsp;&nbsp;cout &lt;&lt; "badbit set" &lt;&lt; endl;<br>
	  else if (cin.fail())<br>
	  &nbsp;&nbsp;cout &lt;&lt; "failbit set" &lt;&lt; endl;<br>
          else if (cin.eof())<br>
	  &nbsp;&nbsp;cout &lt;&lt; "End of file" &lt;&lt; endl;<br>
</div>
Разумеется, таким образом, "поштучно", проверять флаги не совсем
удобно. Поэтому наряду с приведенными функциями в классах ввода-вывода
есть и функция <em>rdstate</em>, которая возвращает все состояние потока. 
С ее помощью можно переписать только что приведенную проверку следующим
образом (в приведенном ниже фрагменте <em>ios_base::iostate</em> - это тип 
переменной, которая хранит состояние потока): 
<div class="code">
	  ios_base::iostate s = cin.rdstate();<br>
          if (s & ios_base::badbit)<br>
	  &nbsp;&nbsp;cout &lt;&lt; "badbit set" &lt;&lt; endl;<br>
	  else (s & ios_base::failbit)<br>
	  &nbsp;&nbsp;cout &lt;&lt; "failbit set" &lt;&lt; endl;<br>
          else (s & ios_base::eofbit)<br>
	  &nbsp;&nbsp;cout &lt;&lt; "End of file" &lt;&lt; endl;<br>
</div>
У  состояния потока есть  одна особенность  - если  уж в  нем поднялся
какой-то из нехороших  битов, сам по себе он не  сбросится, и при этом
любая операция  ввода-вывода (разумеется, только с этим потоком) будет 
проигнорирована. Так  что, если вам после анализа ошибки хочется  попытаться 
продолжить ввод, надо сначала очистить флаги - для этого у потока есть 
специальная функция <em>clear()</em>:
<div class="code">
         if (cin.bad()) {<br>
	 &nbsp;&nbsp;cin.clear(); // Очищаем флаги<br>
	 &nbsp;&nbsp;cin >> i ;  // Пытаемся повторить ввод<br>
         }<br>
</div>
На  самом деле  функция  <em>clear()</em> не  очищает  флаги, а  
устанавливает состояние  в  заданное. Просто  ее  аргументом  по 
умолчанию  является <em>goodbit</em>.    Но с тем же    успехом,    
написав,    к    примеру,
<em>cin.clear(ios_base::eofbit)</em>, вы можете выставить с ее помощью 
состояние конца файла.
</p><p>
Все,   сказанное  выше,   касалось  в   основном   проверки  состояния
потока.  Однако,  если  вы  разрабатываете операции  ввода-вывода  для
класса, у вас может возникнуть необходимость не только проверять, но и
взводить биты  состояния. Например, если при  вводе значения программе
встретилось недопустимое значение, вполне разумно установить флаг <em>fail</em>
или <em>bad</em>. Для этого  в классе потоков предусмотрена специальная функция
<em>setstate()</em>.  При  ее  использовании  флаг ошибки  именно  взводится  в
дополнение  к  уже  установленным,  а не  замещает  прежнее  состояние
потока. Скажем, если при вводе комплексного числа оператор >> после
считывания вещественной части заметил конец файла, он, не сбрасывая
флаг <em>eof</em>, должен установить флаг <em>bad</em> или <em>fail</em> 
(можно сразу оба):
<div class="code">
     istream& operator>>(istream& is, Complex& c) {<br>
     &nbsp;&nbsp;is>>c.re;<br>
     &nbsp;&nbsp;if (is.eof())<br>
     &nbsp;&nbsp;&nbsp;&nbsp;is.setstate(ios_base::badbit|ios_base::failbit);<br>
     &nbsp;&nbsp;...;<br>
     &nbsp;&nbsp;return is;<br>
     }<br>
</div>
При этом у потока сохранится состояние <em>eof</em>, являющееся первопричиной
ошибки, но дополнительно будут подняты флаги <em>fail</em> и <em>bad</em>, 
означающие, что последняя операция ввода не привела к успеху.
</p><p>
Как видите, до сих пор мы напрямую работали с состоянием потока. Гуру
от С++ считают, что это - наиболее правильный и предпочтительный
способ, и по возможности нужно обрабатывать ошибки именно так. Однако
есть способ и "для ленивых", основанный на использовании механизма
исключений. Идея состоит в том, что поток можно попросить, чтобы он
возбуждал исключение всякий раз, когда в его состоянии взводится тот
или иной бит. Делается это с помощью член-функции <em>exceptions()</em>,
ей передается набор битов состояния, любой из которых должен
приводить к исключению. Например:
<div class="code">
  // Исключение по достижении конца файла в cin<br>
  cin.exceptions(ios_base::eofbit);<br>
  <br>
  // Исключение по любому из указанных битов в cout<br>
  cout.exceptions(<br>
  &nbsp;&nbsp;ios_base::eofbit|ios_base::badbit|ios_base::failbit<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
</div>
Дальше все идет по накатанной для исключений колее. Вы можете
поставить код ввода-вывода в try-блок и задать обработчик catch  (тип
исключения <em>ios_base::failure</em>):
<div class="code">
	   try {<br>
	   &nbsp;&nbsp;cin >> i;<br>
	   }<br>
	   catch (ios_base::failure) {<br>
	   &nbsp;&nbsp;cerr &lt;&lt; "I/O error" &lt;&lt; endl;<br>
           }<br>
</div>
а можете и не делать этого - тогда неперехваченное исключение приведет
к тому, что ваша программа аварийно завершится.
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-altin"></a>Альтернативные функции ввода</h2>
<p>
Операторы >> хороши,  когда вы имеете дело с  форматным вводом. Однако
частенько  задача  принуждает программиста  работать  на более  низком
уровне.   Например, если  вы хотите  принимать из  входного  потока не
слова, а  строки, то обычный оператор  >> не подойдет  (он в состоянии
считать слово  в символьный массив,  но признак конца строки  для него
ничем  не отличается  от  пробела).  Поэтому  помимо различных  версий
оператора  >>, входные  потоки  определяют еще  несколько функций  для
работы с "сырой" информацией (то же касается и выходных потоков, но об
этом -  чуть позже).  Не пытаясь детально  рассмотреть (и  даже просто
назвать)  все эти  функции,  покажу  вам лишь  самые,  на мой  взгляд,
важные.
</p><p>
Разумеется, среди этих "альтернативных" функций есть функция
считывания одиночного символа - <em>get()</em>. Она очень напоминает 
<em>getchar()</em> из С - так же возвращает код введенного символа, 
или EOF по достижении конца ввода. Вот как можно было бы с ее помощью 
скопировать входной поток в выходной:
<div class="code">
      int c;<br>
      while ( (c=cin.get()) != EOF)</br>
      &nbsp;&nbsp;cout.put(c);<br>
</div>
(<em>put()</em>, как вы наверное догадались - партнер <em>get</em>, выполняющий
посимвольный вывод).
</p><p>
Следующая полезная функция - <em>getline()</em> - позволяет считать в
символьный буфер целую строку:
<div class="code">
	   char s[100];<br>
	   cin.getline(s, sizeof(s));<br>
</div>
При этом символ перевода строки  '\n' из входного потока будет удален,
но в массив  не попадет. Таким образом, в  массиве окажется С-строка с
завершающим '\0'. Не очень  удобно, правда, определять, хватило ли вам
массива  на  чтение  всей  строки  (если  завершающий  \0  оказался  в
последнем  элементе  массива,  это  может означать  либо  что  строка
слишком длинная. либо  что длина строки в точности  совпала с размером
массива). Однако  если вы зададите размер входного  массива с запасом,
такой вопрос попросту не будет возникать.
</p><p>
Если  же вы  хотите  просто считать  в  буфер определенное  количество
символов,  не разбираясь,  есть  ли  там переводы  строк  или нет,  то
следует  воспольоваться  функцией <em>read()</em>,  а  затем  с помощью  другой
функции,  <em>gcount()</em>,   определить,  сколько  именно   символов  удалось
прочесть:
<div class="code">
	char buf[1024];<br>
	int chars_read;<br>
	<br>
	cin.read(buf, sizeof(buf));<br>
	chars_read = cin.gcount();<br>
</div>
Есть еще  одна интересная и  весьма полезная функция в  классе входных
потоков  - <em>putback()</em>.  Она  возвращает во  входной  поток тот  символ,
который    указан    в    ее    аргументе.   Поясню,    зачем    такое
понадобилось. Взгляните на такой фрагмент программы:
<div class="code">
	int i;<br>
	string s;<br>
	cin >> i >> s;<br>
	cout &lt;&lt; i &lt;&lt; " " &lt;&lt; s &lt;&lt; endl;<br>
</div>
если вы введете по запросу такой программы строку

      <em>123hello</em>

(без пробела между двуям значениями), она тем не менее правильно
считает и число, и строку, и напечатает

      <em>123&nbsp;hello</em>
</p><p>
А как, собственно, удалось такого добиться? Дело в том, что первый
оператор ввода считывал символы по одному до тех пор, пока ему
встречались цифры. Когда же он добрался до символа 'h', то с помощью
функции <em>putback()</em> положил его обратно и закончил работу. 
То есть, код считывания целого числа выглядит примерно так:
<div class="code">
      int ch;<br>
      <br>
      while ((ch=cin.get())!=EOF) {<br>
      &nbsp;&nbsp;// Если не цифра, надо закончить ввод<br>
      &nbsp;&nbsp;if (! isdigit(ch)) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;cin.putback(ch);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;break;<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;// Обработать очередную цифру<br>
      &nbsp;&nbsp;...<br>
      }<br>
      ...<br>
</div>
Разумеется, ввод  целого числа я привел  только для примера  - об этом
уже позаботились  разработчики класса потоков. Однако  похожий прием с
возвратом  в  поток  неподходящего  символа часто  применяется  и  при
разработке операций ввода для пользовательских типов.
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-altout"></a>Альтернативные функции вывода</h2>
<p>
С выводом дело иметь всегда проще, чем со вводом, поскольку не
возникает вопроса о соответствии реального формата ожидаемому. Поэтому
и функций для неформатированного вывода меньше. В этом примере
<div class="code">
	 char ch;<br>
	 char buf[1024];<br>
	 ...<br>
	 // Вывести один символ<br>
	 cout.put(ch);<br>
	 // Вывести весь буфер<br>
	 cout.write(buf, sizeof(buf));<br>
</div>
с помощью функции <em>put()</em> мы выведем одиночный символ, а <em>write()</em> 
запишет в поток сразу sizeof(buf) символов.
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-virt"></a>Виртуальные 
	       friend-функции для операторов ввода-вывода</h2>
<p>
С точки зрения языка, виртуальных friend-функций не бывает,
виртуальными могут быть только функции-члены. Но, как и в случае с
виртуальными конструкторами - "Если нельзя, но очень хочется, значит,
можно". Но сначала поясню, зачем такая экзотика может
понадобиться. Давайте напишем два класса с операторами вывода:
<div class="code">
	class Base {<br>
	&nbsp;&nbsp;friend ostream& operator&lt;&lt;(ostream& os, Base& b);<br>
	};<br>
	<br>
	ostream&  operator&lt;&lt;(ostream& os, Base& b) {<br> 
	&nbsp;&nbsp;return os &lt;&lt; "Base" &lt;&lt; endl;<br>
	}<br>
	<br>
	class Derived: public Base {<br>
	&nbsp;&nbsp;friend ostream& operator&lt;&lt;(ostream& os, Derived& d);<br>
	};<br>
	<br>
	ostream&  operator&lt;&lt;(ostream& os, Derived& d) {<br>
	&nbsp;&nbsp;return os &lt;&lt; "Derived" &lt;&lt; endl;<br>
	}<br>
</div>
и попробуем ими попользоваться. До тех пор, пока не задействован
полиморфизм, все будет работать правильно, и такая программа
<div class="code">
	main() {<br>
	&nbsp;&nbsp;Base b;<br>
	&nbsp;&nbsp;Derived d;<br>
	<br>
	&nbsp;&nbsp;cout &lt;&lt; b &lt;&lt; d;<br>
	<br>
	}<br>
</div>
напечатает нам
<div class="session">
	   Base<br>
	   Derived<br>
</div>
Но если нам придется работать со ссылками или указателями на базовый
класс 
<div class="code">
        main() {<br>
	&nbsp;&nbsp;Base b;<br>
	&nbsp;&nbsp;Derived d;<br>
	&nbsp;&nbsp;Base *pb[2] = { &b, &d };<br>
	<br>
	&nbsp;&nbsp;cout &lt;&lt; *pb[0] &lt;&lt; *pb[1];<br>
	<br>
	}<br>
</div>
случится неприятность - программа воспользуется базовым >> для вывода
производного класса, и мы получим в выводе
<div class="session">
	 Base<br>
	 Base<br>
</div>
Именно для решения таких проблем предназначены виртуальные функции. Но
оператор >> по правилам игры не может быть функцией-членом, стало
быть, его нельзя объявить виртуальным. Выход, тем не менее, есть. Давайте
немного изменим определения наших классов, введя в них виртуальные
член-функции вывода, а в функции-операторе &lt;&lt; воспользуемся ими: 
<div class="code">
	class Base {<br>
	public:<br>
	&nbsp;&nbsp;virtual ostream& put(ostream& os) {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;return os &lt;&lt; "Base" &lt;&lt; endl;<br>
        &nbsp;&nbsp;}<br>
	&nbsp;&nbsp;friend ostream& operator&lt;&lt;(ostream& os, Base& b);<br>
	};<br>
	<br>
	ostream&  operator&lt;&lt;(ostream& os, Base& b) {<br>
	&nbsp;&nbsp;return b.put(os);<br>
	}<br>
	<br>
	class Derived: public Base {<br>
	public:<br>
	&nbsp;&nbsp;ostream& put(ostream& os) {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;return os &lt;&lt; "Derived" &lt;&lt; endl;<br>
	&nbsp;&nbsp;}<br>
	};<br>
</div>
С такими определениями поcледний, полиморфный вариант функции  main()
сработает правильно:
<div class="session">
	 Base<br>
	 Base<br>
</div>
Как видите, нам без особых  усилий удалось добиться того, что оператор
&lt;&lt; стал вести себя, как виртуальная функция и смог работать в условиях
полиморфизма.
</p>
    </td>
  </tr>
</table>

<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-fmt"></a>Управление форматным выводом</h2>
<p>
Тот вывод,  который мы  использовали до сих  пор, пригоден,  по правде
говоря,  лишь  для  самых  простых  задач. Красивую  табличку  так  не
напечатаешь, точность, с которой надо выводить числа, не задашь, и так
далее.  В С-стиле мы  настраивали внешний  вид выводимой  информации в
форматной  строке <em>printf()</em> с  помощью специальных  флагов. Разумеется,
подобные возможности  есть и в  С++-стиле ввода-вывода, и вы  сейчас с
ними познакомитесь.
</p><p>
Операции по настройке "внешнего вида" вывода основаны на использовании
флагов. В зависимости от того, какие флаги установлены, вы можете
выводить числа в разных системах счисления, задавать точность,
выравнивание, и так далее. Всего флагов, управляющих выводам, довольно
много:
<pre>
	skipws

	left
	right
	internal

	boolalpha
	
	dec
	hex
	oct

	scientific
	fixed
	
	showbase
	showpoint
	showpos
	uppercase
	
	adjustfield
	basefield
	floatfield
</pre>
</p><p>
Большинство из приведенных символических имен соответсвуют одному биту
в  поле флагов.  Но,  как вы,  возможно,  заметили, не  все эти  флаги
независимы - есть среди них и взаимоисключающие. Например, целое число
можно  выводить   либо  в  16-ричном,   либо  в  десятичном,   либо  в
восьмеричном виде. Установка же одновременно более, чем одного из этих
трех  флагов бессмысленна.  Поэтому, помимо  одиночных  битов пришлось
определить еще и маски  для работы с такими группами взаимоисключающих
флагов - это <em>adjustfield</em>, <em>basefield</em> и <em>floatfield</em>.
</p><p>
Естественно, для работы с флагами предусмотрены специальные
функции. Если вы просто хотите задать какой-то бит или группу
битов-флагов, вам надо воспользоваться функцией <em>flags()</em>. Например, для
вывода целых чисел в восьмеричном виде и задания
выравнивания по левому краю надо написать :
<div class="code">
       cout.flags(ios_base::oct|ios_base::left);
</div>
Помимо  установки ваших  флагов,  функция setf  еще  и вернет  прежние
значения  флагов  (правильный тип  переменной  для  хранения флагов  -
ios_base::fmtflags), что особенно полезно, если вы хотите после вывода
своих данных восстановить прежнее состояние:
<div class="code">
      void my_io_function() {<br>
      &nbsp;&nbsp;int i;<br>
      &nbsp;&nbsp;// Сохраняем старые настройки в old, задаем свои<br>
      &nbsp;&nbsp;ios_base::fmtflags old <br>
      &nbsp;&nbsp;&nbsp;&nbsp;= cout.flags(ios_base::oct|ios_base::left);<br>
      <br>
      &nbsp;&nbsp;cout &lt;&lt; i ;<br>
      <br>
      &nbsp;&nbsp;// Восстанавливаем старые настройки<br>
      &nbsp;&nbsp;cout.flags(old);<br>
      }<br>
</div>
Вместо того, чтобы задавать весь набор флагов, вы можете добавлять
флаги к уже имеющемуся набору с помощью функции setf. Так, например,
<div class="code">
      cout.setf(ios_base::boolalpha)
</div>
задаст режим символического вывода для логических значений, не меняя
остальных настроек. Однако функция setf() с одним аргументом
предназначена для работы только с независимыми флагами. Если же вам
надо выставить один из взаимоисключающих флагов, нужно воспользоваться
вариантом setf() с двумя аргументами, указав во втором соответсвующую
маску. Например, для вывода вещественных чисел в "научном" формате
(1.1127e-03) придется написать
<div class="code">
      cout.setf(ios_base::scientific, ios_base::floatfield);
</div>
</p>
    </td>
  </tr>
</table>



<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-fmtfuncs"></a>
	      Функции-не флаги для управления форматом</h2>
<p>
Вы, наверное, обратили внимание - самих по себе флагов недостаточно
для настройки формата. Среди них отсутсвуют такие важные вещи, как
ширина поля, точность (число выводимых цифр), символ-заполнитель. Эти
три задачи решаются с помощью функций <em>width()</em>, <em>precision()</em>  и
<em>fill()</em>. Так, написав <em>соut.fill('_') </em>
вы зададите символ-заполнитель '_' вместо используемого по умолчанию пробела, а
вызвав <em>cout.precision(10)</em> потребуете, чтобы у вещественных чисел 
печаталось 10 цифр.
</p><p>
Эти две функции, будучи вызваны, сохранят свое действие до тех пор,
пока другие вызовы fill и precision не отменят их действие. Третья
функция - width(), которая задает ширину поля, действует только на
одну следующую операцию вывода строки или числа. Так, например, если
вы напишете
<div class="code">
       cout.width(10);<br>
       cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; 1 &lt;&lt; endl; <br>
</div>
то получите в выводе
<div class="session">
	    '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1'<br>
	    '1'<br>
</div>
(апострофы добавлены мной, чтобы лучше была видна разница между
выводом двух чисел).
</p>
    </td>
  </tr>
</table>



<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-iomanip"></a>Манипуляторы</h2>
<p>
Давайте попробуем решить простенькую задачу - вывести четыре слова в
виде таблицы 2х2 с полями шириной 10 символов:
<div class="code">
     #include &lt;iostream&gt;<br>
     using namespace std;<br>
     <br>
     main() {<br>
     <br>
     &nbsp;&nbsp;string s[4] = <br>
     &nbsp;&nbsp;&nbsp;&nbsp;{ "One", "Two", "Three", "Four" };<br>
     <br>
     &nbsp;&nbsp;cout.width(10);<br>
     &nbsp;&nbsp;cout &lt;&lt; s[0];<br>
     &nbsp;&nbsp;cout.width(10);<br>
     &nbsp;&nbsp;cout &lt;&lt; s[1] &lt;&lt; endl;<br>
     &nbsp;&nbsp;cout.width(10);<br>
     &nbsp;&nbsp;cout &lt;&lt; s[2];<br>
     &nbsp;&nbsp;cout.width(10);<br>
     &nbsp;&nbsp;cout &lt;&lt; s[3] &lt;&lt; endl;<br>
     }<br>
</div>
Разумеется, эта программа с задачей справится. Только уж очень
многословный и длинный код получился. А самое плохое, что он плохо
читаем - операции настройки вывода и самого вывода стоят в отдельных
строках, и надо напрягаться, чтобы осознать их взаимосвязь. 
</p><p>
С++ предлагает более изящное решение этой (и многих других задач) -
манипуляторы вывода. Идея, используемая в манипуляторах проста -
давайте создадим объект, получив который от оператора &lt;&lt;, поток ничего
не выведет, но ищменит свое состояние. Например, установит ширину поля
для следующей операции вывода. С использованием этой идеи код печати
таблицы станет короче и яснее
<div class="code">
     #include &lt;iostream&gt;<br>
     #include &lt;iomanip&gt;<br>
     using namespace std;<br>
     <br>
     main() {<br>
     <br>
     &nbsp;&nbsp;string s[4] = <br>
     &nbsp;&nbsp;&nbsp;&nbsp;{ "One", "Two", "Three", "Four" };<br>
     <br>
     &nbsp;&nbsp;cout &lt;&lt; setw(10) &lt;&lt; s[0]<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; setw(10) &lt;&lt; s[1] &lt;&lt; endl<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; setw(10) &lt;&lt; s[2]<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; setw(10) &lt;&lt; s[3] &lt;&lt; endl;<br>
     }<br>
</div>		
а напечатает в  точности то же, что и раньше. setw()  в этом примере -
стандартный манипулятор,  задающий ширину  поля (не вдаваясь  в детали
внутреннего устройства  манипуляторов, замечу, что  setw() вызывает ту
же функцию width(), что и  в первом варианте печати таблицы, но делает
это незаметно для нас).
</p><p>
В С++  системе ввода-вывода довольно  много стандартных манипуляторов,
как с  аргументами, так  и без. Манипуляторы  существуют для  всех тех
настроек, которые можно выполнить  с помощью флагов и функций width(),
fill(), precision(). Есть и еще несколько манипуляторов без аргументов
(кстати, одним из них - endl  - вы уже давно пользуетесь, но просто не
знали, что он из себя представляет). Приведу для справки список
стандартных манипуляторов:
<pre>
	    boolalpha
	    noboolalpha

	    showbase
	    noshowbase
	    
	    showpoint
	    noshowpoint

	    showpos
	    noshowpos
	    
	    skipws
	    noskipws
	    
	    uppercase
	    nouppercase

	    internal
	    left
	    right

	    dec
	    hex
	    oct

	    fixed
	    scientific
	    
	    endl		- вывод '\n', очистка буфера
	    ends		- вывод '\0', очистка буфера
	    flush		- просто очистка буфера

	    ws			- пропустить все isspace() на вводе

	    resetiosflags(flags)
	    setiosflags(flags)
	    
	    setbase(base)
	    setprecision(prec)
	    setfill(Ch)
	    setw(w)
</pre>
В дополнение к этому есть возможность создавать свои манипуляторы (но
если вы захотите это проделать, придется сначала разобраться, как они
устроены). 
</p>
    </td>
  </tr>
</table>


<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="cppio-sfstreams"></a>Файловые и строковые потоки</h2>
<p>
Подсистема С++-ввода-вывода - хороший пример того, как наследование
может сэкономить время и силы (и не только разработчикам, но и
пользователям классов). Мы сегодня довольно долго говорили о том, как
работать с потоками вообще (напомню, поток это некое обобщенное
понятие, не связанное с каким-то конкретным типом устройства
ввода-вывода).   Так вот, оказывается, что все, что вы сегодня узнали,
можно использовать не только со стандартными потоками, но и
для работы с файлами и даже с массивами символов. И дополнительных
усилий, чтобы это проделать (как и дополнительного знания деталей
реализации файловых и строковых потоков), требуется совсем немного.
</p><p>
Классы  потоков  ввода-вывода   (они  называются  istream,  ostream  и
iostream   для   входных,    выходных   и   комбинированных   потоков,
соответственно)  служат  базовыми  для  создания  файловых  (ifstream,
ofstream, fstream) и  строковых потоков (istringstream, ostringstream,
stringstream).  И для  того,  чтобы начать  пользоваться этими  новыми
видами потоков,  достаточно освоить  всего несколько новых  операций -
открытие и закрытие, и,  в случае ostringstream, преобразование потока
в строку.
</p><p>
Если помните, в начале занятия класс Complex с операторами
ввода-вывода. Так вот, эти же операторы прекрасно будут работать и с
файлами 
<div class="code">
	ifstream ifs("my_numbers.dat");<br>
	ofstream ofs("my_results.out");<br>
	Complex c;<br>
	ifs >> c;<br>
	<br>
	ofs &lt;&lt; c &lt;&lt; endl;<br>
	<br>
	// Явное закрытие потоков нужно лишь на случай<br>
	// аварийного завершения программы.<br>
	// При нормальном завершении файлы закроются <br>
	// при вызове деструкторов<br>
	ifs.close();<br>
	ofs.close();<br>
</div>        
и с символьными массивами
<div class="code">
        char buf[1024];<br>
	...;<br>
	<br>
	// Связываем входной строковый поток с массивом buf<br>
	istringstream is(buf);<br>
	<br>
	ostringstream os;<br>
	<br>
	Complex c;<br>
	<nr>
	// Считываем  значение<br>
	is >> c;<br>
	<br>
	// Выводим значение в строковый поток<br>
	os &lt;&lt; c &lt;&lt; ends;<br>
	<br>
	// Выводим накопленное содержимое строкового потока<br>
	// в cout<br>
	// Функция str() возвращает содержимое строкового потока<br>
	// в виде строки<br>
	cout &lt;&lt; os.str();<br>
</div>
Разумеется, в  этом примере не приведены  некоторые детали реализации,
специфичные  для работы  с файлами  и строками  (например,  файл можно
открывать   в   разных   режимах,  можно   позиционировать   указатель
записи-чтения в файле и т.п.). Но для многих задач эти детали попросту
не   нужны  -   потоки,  открываемые   с  параметрами   по  умолчанию,
обеспечивают вполне  разумное поведение, и,  раз открыв поток,  вы уже
можете не особенно задумываться, с чем именно вы работаете - с файлом,
массивом или чем-то еще.
</p>
    </td>
  </tr>
</table>
</div>
<!--

		   Стандартная библиотека шаблонов.


			 Потоки ввода-вывода
			       iostream
			       fstream
			      strstream

			Функции помимо >> и <<

		     Обработка ошибок на потоках.

			Синхронизация с stdio
			 
			 Модификаторы потоков
			 
			       Часовые



		    Обзор Standard library (brief)

			Вопросы проектирования

	 Соглашения об именовании полей, методов и переменных

		   Демонстрация возможностей root'а

Донести основную мысль - изучить сам язык легче всего. Однако основная
идея языка - избежать дублирования кода. И гораздо больше времени
уходит на изучение возможностей и особенностей той или иной
библиотеки. Это - самое трудное, но и самое выгодное решение
проблемы. Как в мультике - лучше полдня поучиться, а потом за полчаса
долететь.  А изучать практически заново приходится каждую новую
библиотеку. 

			     What's next?

Видимо, на очереди  - распространение объектно-ориентированного
подхода с одной машины на несколько машин в сети - когда объекты
хранятся и выполняются на разных машинах. CORBA - последыш RPC.

С чем вам легче будет осваиваться, имея представление о С, С++ (список
далеко не полный, я наверняка о многих похожих языках вообще не
слышал).

  1. Java (JavaScript?)
  2. PHP
  3. Maybe PERL
  4. Различные реализации CORBA
  5. Технологии com и net?

  6. С точки зрения идеологии - любые OO-языки.

		    Достойные внимания библиотеки

Прежде всего - стандартная (она должна быть всегда)

Для научников - root - среда с интерпретатором, могучими классами,
устойчивыми объектами, удобным интерфейсом, графикой презентационного
качества. Кривовата и тяжеловата, правда, но все-таки полегче paw.

Для графики достойный выбор - amulet.

-->




</body>
</html>
