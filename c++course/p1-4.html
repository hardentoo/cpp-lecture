<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 4</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 4</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Функции
	<ul>
          <li><a href="p1-4.html#usage">Создание и использование функций.</a>
          <li><a href="p1-4.html#vars">Параметры и переменные.</a>
          <li><a href="p1-4.html#passbyvalue">Передача по значению.</a>
          <li><a href="p1-4.html#pointers">Адреса и указатели.</a>
          <li><a href="p1-4.html#ptr_safety">
	     Как избежать неприятностей с указателями?</a>
          <li><a href="p1-4.html#scanf">scanf() - чтение данных из потока.</a>
          <li><a href="p1-4.html#defdecl">Объявление и определение функции.</a>
	</ul>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="usage"></a>Функции</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	 <h2>Создание и использование функций.</h2>
<p>


Прошлое  занятие мы  закончили  знакомством с  простыми типами  данных
(char, int,  float, double) и модификаторами  типов (signed, unsigned,
short, long).

</p><p>

Это занятие я посвящу знакомству с функциями. И по ходу
рассказа  о  функциях  вы  узнаете  о таких  вещах,  как  параметры  и
локальные переменные, узнаете, чем объявления функций отличаются от их
определений,  впервые услышите о  типе (точнее  даже, о  группе типов)
указатель, и  познакомитесь с операторами  взятия адреса и  доступа по
указателю. Кроме  того я, наконец,  смогу вам показать, как  в С-стиле
ввода-вывода можно считывать значения.

</p><p>

Вызов функции  - это оператор, хотя,  в общем-то, пока  вы работаете в
рамках С,  об этом даже  и думать не  приходится (но мы то  в конечном
итоге  пытаемся С++  выучить).  Тем  не менее,  у вызова  функции есть
приоритет - один  из самых высоких. Есть и  операнды, хотя догадаться,
сколько их, непросто - число  аргументов то может быть разным.  Список
аргументов  функции   считают  за  один  операнд,   так  что  оператор
оказывается бинарным  (первый операнд - сама функция,  второй - список
ее аргументов).

</p><p>

Вы уже не раз видели, как функции вызываются - я говорю о printf() и о
тех фрагментах кода, которые  я показывал, иллюстрируя действие разных
операторов.  Но вот  с тем,  как  функции определяются,  вы пока  мало
знакомы  -  только  на  примере  функции  main(), да  и  то  мы  в  ее
определении не использовали параметры. Ну что же, давайте учиться.

</p><p>

Для того, чтобы  определить функцию, с именем, скажем,  func, нужно на
файловом уровне написать что-нибудь в таком духе:

<div class="incode">
	 double func(double param1, int param2) {<br>
	 &nbsp;&nbsp;return param1-0.1*param2;<br>
	 }<br>
</div>

Что  мы  тут имеем?   Сначала  указан  тип  значения, которое  функция
возвращает - в  данном случае это <em>double</em>. Затем  после пробела следует
имя функции  - идентификатор, составленный  по тем же правилам,  что и
для имен переменных. После имени функции в круглых скобках перечислены
формальные  параметры  с  указанием  их типов.   Формальные  параметры
разделены запятыми.  В  нашей функции это <em>param1</em> типа  
<em>double</em> и <em>param2</em>
типа  <em>int</em>.   После круглых  скобок  со  списком формальных  параметров
следует блок с телом функции - тот, который в фигурных скобках, причем
в теле функции мы  можем использовать формальные параметры как обычные
переменные.

</p><p>

Почему параметры в определении функции называются формальными?  Видимо
для того,  чтобы в разговоре  отличать их от фактических  параметров -
того, что  стоит на самом  деле при вызове  функции (а при  вызове там
могут стоять другие имена переменных, выражения или просто числа).

</p><p>

Определив  функцию,  мы  можем  ее неоднократно  вызывать,  задавая  в
качестве   фактических   параметров    нужные   нам   переменные   или
значения.  При этом  мы можем  использовать то  значение,  которое она
возвращает,  а можем  его игнорировать  (если нам  просто  надо, чтобы
выполнились операторы в теле функции). Примерно так:

<div class="incode">
	  int i;<br>
	  double x, result;<br>
<br>
	  ...<br>
<br>
	  /* два вызова функции в выражении */<br>
	  result =  func(x,i) * func( i+x, 100 );<br>
<br>
	  /* Вызываем еще раз, но игнорируем возвращаемое значение */<br>
	  func(x, i);<br>
</div>

На первый взгляд  возможность игнорировать возвращаемое значение может
показаться странной и даже бессмысленной  - особенно если вы при слове
"функция" в первую очередь думаете о функциях в математическом смысле,
например, о  синусе или экспоненте. Но  в программах на  С очень часто
встречаются  такие  функции,  возвращаемое значение  которых  содержит
некоторую "не всегда нужную"  программисту информацию. И очень хороший
пример такой функции - уже знакомая  вам <em>printf()</em>. Мы с вами с успехом
этой функцией  пользовались, и вы, наверное, даже  не подозревали, что
эта функция к тому же  возвращает какой-то результат. А она возвращает
значение типа  <em>int</em>. Если число,  которое она вернула,  отрицательное -
функции  "что-то не  понравилось". Если  0  или больше,  то это  длина
напечатанной ей строки в символах.

</p><p>

А  как  же  все-таки быть,  если  из  функции  вообще не  надо  ничего
возвращать? Кстати,  в некоторых языках  для такого типа  функций даже
есть  отдельные  названия,   например,  в  Фортране  это  подпрограмма
(subroutine), в  Паскале -  процедура. Можно, конечно,  просто вернуть
первое пришедшее на ум число - все равно использоваться не будет, лишь
бы  правила языка  соблюсти. Но  для  того, чтобы  вернуть из  функции
значение,  компьютеру требуется  выполнить какую-то  работу,  в данном
случае ненужную.  А это означает, что подобная  функция будет работать
медленнее, чем могла бы.

</p><p>

Вот  тут-то  и  находится применение  -  для вас  пока  первое. но  не
единственное  -  загадочному типу  <em>void</em>.  Как  я  упоминал на  прошлом
занятии, тип <em>void</em> не  может хранить никакого значения, даже переменных
этого типа создать нельзя. Переменную нельзя, а функцию можно:

<div class="incode">
      /* У этой функции нет возвращаемого значения */<br>
      void f() {<br>
      &nbsp;&nbsp;...<br>
      &nbsp;&nbsp;return;<br>
      }<br>
</div>

Как  видите, в операторе  <em>return</em> нет  
никакого значения.  просто сразу
после ключевого слова стоит точка  с запятой. Его (<em>return</em>) 
и писать-то
в  этом  случае не  обязательно,  его  пишут  только тогда,  когда  он
действительно  зачем-то  нужен. Кстати,  хороший  вопрос  - вы  можете
придумать ситуацию, когда оператор  return без значения все-таки может
пригодиться?

</p><p>
      
Также  можно  написать <em>void</em>  вместо  
списка  параметров, если  функции
параметры  не нужны:

<div class="incode">
     int f(void) {<br>
     &nbsp;&nbsp;...<br>
     &nbsp;&nbsp;return 0;<br>
     }<br>
</div>

В  С++ это все  равно, что  написать пустой  список параметров,  но в
обычном С <em>f()</em> и <em>f(void)</em> - разные вещи.

</p><p>

Функции в  С могут  быть рекурсивными. То  есть, в теле  функции можно
вызывать  ее саму.  Вот  пример рекурсивного  вычисления факториала  с
использованием троичного оператора:

<div class="code">
        #include &lt;stdio.h><br>
<br>
	unsigned factorial(unsigned arg) {<br>
	&nbsp;&nbsp;return arg==0 ? 1 : arg*factorial(arg-1);<br>
	}  <br>
<br>
	int main() {<br>
<br>
	&nbsp;&nbsp;printf("Факториал 3 равен %d\n", factorial(3));<br>
	&nbsp;&nbsp;return 0;<br>
        }<br>
</div>

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="vars"></a>
	    Параметры и переменные</h2>
<p>

Параметры позволяют передавать функции какую-то информацию. 
В теле функции ими пользуются так же, как обычными переменными.

</p><p>

Но при  написании  тела  функции  вы  не  ограничены  только  формальными
параметрами, При необходимости можно использовать переменные файлового
уровня видимости,  либо заводить локальные, видимые  только в функции.
Естественно, прежде, чем  использовать переменную файлового уровня, вы
должны ее определить. Вот вам  пример аж с четырьмя функциями, которые
используют    как   параметры,    так   и    файловые    и   локальные
переменные. Фантазии  у меня не  хватает писать подобные  примеры так,
чтобы они  одновременно были и осмысленными, и  короткими и понятными.
Так что  не спрашивайте, зачем именно эти  функции нужны.  Необходимые
пояснения я вставил в код в виде комментариев.

<div class="code">
	...<br>
<br>
	int i, j;<br>
<br>
	/* <br>
	&nbsp;&nbsp;Первой функции видны i, j файлового уровня<br>
	&nbsp;&nbsp;Кроме того, у нее есть формальный параметр k<br>
	&nbsp;&nbsp;и локальная переменная result<br>
	&nbsp;&nbsp;В процессе работы эта функция изменяет значение<br>
	&nbsp;&nbsp;файловой переменной i<br>
	*/<br>
	int f1(int k) {<br>
	&nbsp;&nbsp;int result;<br>
	&nbsp;&nbsp;result = i*j + k;<br>
	&nbsp;&nbsp;i += 100;<br>
	&nbsp;&nbsp;return result;<br>
	}<br>
<br>
	/* <br>
	&nbsp;&nbsp;Во второй функции имя формального параметра совпадает <br>
	&nbsp;&nbsp;с именем переменной i файлового уровня, при работе <br>
	&nbsp;&nbsp;используется параметр, а не файловая переменная.<br>
	*/<br>
	int f2(int i) {<br>
	&nbsp;&nbsp;/* i - параметр, j - файловая */	    <br>
	&nbsp;&nbsp;return  i*j;<br>
	}<br>
<br>
	/* <br>
	&nbsp;&nbsp;С третьей функцией та же история, что и со второй.<br>
	&nbsp;&nbsp;Только на этот раз маскируется файловая переменная j, <br>
	&nbsp;&nbsp;и не формальным параметром, а локальной переменной.<br>
	*/<br>
	int f3(int k) {<br>
	&nbsp;&nbsp;int j;<br>
	&nbsp;&nbsp;j=100;<br>
	&nbsp;&nbsp;/* i - файловая, j - локальная */	    <br>
	&nbsp;&nbsp;return  i*j + k;<br>
	}<br>
<br>
	/* <br>
	&nbsp;&nbsp;Здесь еще смешнее - переменная j самого внутреннего блока<br>
	&nbsp;&nbsp;маскирует не только файловую, но и локальную переменную из<br>
	&nbsp;&nbsp;внешнего блока.<br>
	*/<br>
	int f4(int k) {<br>
	&nbsp;&nbsp;/* Заводим переменную и сразу инициализируем */<br>
	&nbsp;&nbsp;int j=100;<br>
<br>
        &nbsp;&nbsp;{<br>
  	&nbsp;&nbsp;&nbsp;&nbsp;/* <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Заводим еще одну локальную с тем же именем,<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;что у файловой и локальной из внешнего блока<br>
	&nbsp;&nbsp;&nbsp;&nbsp;*/<br>
	&nbsp;&nbsp;&nbsp;&nbsp;int j=10;<br>
       	&nbsp;&nbsp;&nbsp;&nbsp;/* <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i - файловая, j - локальная, причем из <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;внутреннего блока <br>
	&nbsp;&nbsp;&nbsp;&nbsp;*/<br>
<br>
	&nbsp;&nbsp;&nbsp;&nbsp;return  i*j + k;<br>
	&nbsp;&nbsp;}<br>
	}<br>
<br>
	...<br>
</div>

Как видите, при  создании функций у вас есть  большая свобода по части
использования  параметров  и  переменных.  Не  забывайте  только,  что
локальная  переменная или  параметр замаскируют  (сделают недоступной)
одноименную  переменную  файлового уровня,  как  впрочем, и  локальную
переменную во внешних блоках.

</p><p>

Еще кое-что  о создании переменных. Обратите внимание  - в приведенном
примере  определения  всех  локальных  переменных в  блоках  стоят  до
первого исполняемого  оператора. Таковы правила  языка С. Если  вам уж
очень  понадобилось  посреди  исполняемых операторов  функции  завести
переменную -  создайте еще один блок,  как это 
сделано  в <em>f4()</em>. Кстати
сказать, в  С++ это правило  сделали не таким жестким,  чтобы улучшить
читаемость программ. Но для этого пришлось вводить другие ограничения.
Так что и там мы постараемся не использовать бездумно эту возможность.

</p><p>

Между  прочим,  этот  пример  иллюстрирует  в  том  числе  и  основное
применение файловых  переменных в функциях. Они нужны  для того, чтобы
разные функции  могли обмениваться  между собой информацией.   Если мы
вызовем функцию  <em>f1()</em>, она изменит  значение 
файловой переменной  <em>i</em>, и
последующие  вызовы функций  <em>f3()</em> и  <em>f4()</em>, и,  
разумеется,  самой <em>f1()</em>
будут  работать  с этим  измененным  значением  (про <em>f2()</em>  
я не  упоминаю,
поскольку файловая  <em>i</em> в ней замаскирована 
формальным  параметром с тем
же именем).

</p><p>

Разумеется, в  С это не  единственный способ обмена  информацией между
функциями.   Но он  часто  используется, причем  не только  новичками,
которым такой  путь кажется  самым простым, но  и во  вполне серьезных
программах и библиотеках.  Его  выгода - сокращение накладных расходов
при  вызове  функций  и,  следовательно, ускорение  работы  программы.
Расплата за него - больший  риск сделать ошибку из-за неизвестного или
просто  забытого  вами side-effect  -  побочного  эффекта от  вызова
функции (изменение файловой переменой i в нашем примере как раз и есть
образчик  побочного эффекта).  Читабельность  программы я  не упоминаю
потому,  что такой  способ может  ее с  равным успехом  и  улучшить, и
ухудшить.

</p><p>

В примере,  который мы только что смотрели,  всем локальным переменным
задавались значения - либо инициализацией (прямо при создании), либо с
помощью оператора присваивания. Это  не просто "правило хорошего тона"
- это совершенно обязательная вещь.  Если вы определяете переменную на
файловом уровне и  не инициализируете ее, то в  ней окажется 0, причем
эту работу сделает  транслятор, точнее, linker (связывающий загрузчик)
еще  до старта  программы. Это  сделать просто  -  файловые переменные
создаются  один раз  на все  время  работы программы.   Но с  обычными
локальными  - теми,  которые  вы  видели в  примере,  дело обстоит  по
другому.   Эти  создаются  каждый  раз при  вызове  функции.   Поэтому
инициализировать их "про запас",  то есть, если эта инициализация явно
не  прописана  -  слишком  дорогое  удовольствие.  И  под  них  просто
отводится  память, прямо  с тем  содержимым,  которое в  ней было.   В
результате  в  неинициализированных  локальных переменных  оказывается
"мусор" -  непредсказуемые значения, которые к тому  же могут меняться
от  вызова   к  вызову,   поскольку  зависят  от   предистории  работы
программы. Повторю еще раз то же самое, но в фрагменте кода:

<div class="code">
	   /* Файловая без инициализации, будет равна 0 */<br>
	   int s;  <br>
<br>
	   int f() {<br>
	   &nbsp;&nbsp;/* Локальная без инициализации, содержит "мусор" */<br>
	   &nbsp;&nbsp;int k;<br>
	   &nbsp;&nbsp;return k;<br>
           }<br>
<br>
	   int main()  {<br>
<br>
	   &nbsp;&nbsp;printf("%d\n", s); /* Всегда печатает 0 */<br>
<br>
	   &nbsp;&nbsp;/* Невозможно предсказать, что увидим */<br>
	   &nbsp;&nbsp;/* К тому же числа могут быть разными */<br>
	   &nbsp;&nbsp;printf("%d\n", f());<br>
	   &nbsp;&nbsp;...;<br>
	   &nbsp;&nbsp;printf("%d=n", f());<br>
	   &nbsp;&nbsp;return 0;<br>
	   }<br>
</div>

Разумеется, то  же происходит и с подобными  локальными переменными во
вложенных  блоках.  Такие  "обычные" локальные  переменные  называются
автоматическими.

</p><p>

Вы, наверное, уже догадались - раз я все время приговариваю "обычные",
автоматические  - значит, бывают  еще какие-то.   В самом  деле, есть.
Называются они - статические локальные. Появляться могут там же, где и
автоматические - в телах функций и во вложенных блоках.  И вот как они
определяются :

<div class="incode">
	   int f() {<br>
	   &nbsp;&nbsp;static int i;<br>
	   &nbsp;&nbsp;return i;<br>
	   }<br>
</div>

Как  видите, я  просто добавил  перед обычным  определением переменной
модификатор типа  - ключевое слово <em>static</em>. Теперь  наша функция всегда
возвращала бы  нам 0  - локальные статические  также, как  и файловые,
создаются один раз и инициализируются  нулем, если вы не задали другую
инициализацию.

</p><p>

Подобные  переменные  крайне  полезны  и  необходимы.   Но  только  не
расценивайте  это как  призыв для  подстраховки  добавлять модификатор
static  ко всем локальным  переменным.  Вы  этим только  добавите себе
проблем.  Программа  не просто  будет  работать  медленнее, она  будет
работать вовсе не так, как вы ожидаете.

</p><p>

В  чем тут  дело?  И  для чего  все-таки  такие переменные  придуманы?
Давайте  разбираться.   Эти переменные  создаются  один  раз за  время
работы программы, и  один раз инициализируются - либо  нулем, либо тем
значением, которое вы  задали. А раз они живут  независимо от функции,
значит  в  одном  вызове  функции  в  такую  переменную  можно  что-то
положить, а  в следующем  - это что-то  использовать. Вот  вам пример,
который  и  полезен  (его  часто  используют на  практике),  и  хорошо
объясняет суть дела.

<div class="incode">
	  int f() {<br>
	  &nbsp;&nbsp;static int ncalls=1;<br>
<br>
	  &nbsp;&nbsp;/* Который раз мы эту функцию вызвали? */<br>
	  &nbsp;&nbsp;printf("number of calls %d\n", ncalls++);<br>
<br>
	  &nbsp;&nbsp;...<br>
	  }<br>
</div>

Такая функция помимо другой работы будет сообщать нам, который раз она
вызвана. В  первый раз  напечатает 1, потом  2, и так  далее. Подобная
информация бывает порой бесценной при отладке программы.

</p><p>

Другой полезный трюк, основанный на статических локальных переменных -
возможность   выполнять   какие-то  дорогостоящие   "подготовительные"
операции только один раз. Примерно так:

<div class="code">
	 int func() {<br>
	 &nbsp;&nbsp;/* <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;Неявная инициализация тоже дала бы 0,<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;но правила хорошего тона требуют ... <br>
	 &nbsp;&nbsp;*/<br>
	 &nbsp;&nbsp;static int init_done=0; <br>
<br>
	 &nbsp;&nbsp;if (!init_done) {<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;/* <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Тут мы выполняем какую-то "дорогостоящую",<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;но разовую работу - например, считываем <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;таблицу значений из файла. А потом указываем, <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;что таблица прочитана и при следующих вызовах <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;этого делать уже не нужно.<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;*/<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;read_table();<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;init_done = 1;<br>
	 &nbsp;&nbsp;}<br>
<br>
	 &nbsp;&nbsp;/*<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;А в этом месте мы пользуемся табличными данными.<br>
	 &nbsp;&nbsp;*/<br>
<br>
	 &nbsp;&nbsp;...<br>
	 }<br>
</div>

Подобным образом написанная функция  при каждом вызове будет выполнять
свою основную  работу, но  при первом вызове  ей еще  придется считать
необходимую для  этой "основной" работы таблицу. Поэтому  в первый раз
она сработает  несколько медленнее. Зато  хоть не надо  читать таблицу
при каждом вызове.

</p><p>

Примеры  полезного применения  статических локальных  переменных можно
приводить  до бесконечности,  так что  давайте пока  ограничимся этими
двумя и пойдем дальше.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="passbyvalue"></a>
	    Передача по значению</h2>
<p>


А  дальше у  нас  пойдет разговор  о том,  как  себя в  языке С  ведут
фактические параметры, передаваемые  функциям. Посмотрите вот на такую
программу. Что, по вашему, она напечатает - единицу или минус единицу?

<div class="code">
	 #include &lt;stdio.h><br>
<br>
	 void f(int k) {<br>
	 k = -k;<br>
	 }<br>
<br>
	 int main() {<br>
	 &nbsp;&nbsp;int i = 1;<br>
	 &nbsp;&nbsp;f(i);<br>
	 &nbsp;&nbsp;printf("%d\n", i);<br>
	 &nbsp;&nbsp;return 0;<br>
	 }<br>
</div>

Есть у  программистов два специальных  термина для подобных  случаев -
"передача параметра по значению" и "передача параметра по ссылке".

</p><p>

Передача по  значению подразумевает, что  функция работает не  с самой
переменной, а с какой-то другой  - со своей копией, которая при вызове
функции  получает  то  же  значение,  что и  переменная  в  вызывающей
функции.  Так что код, который вызывал функцию, никогда не узнает, что
эта  функция  с переменной  делала  -  он-то  работает с  "оригиналом"
переменной или, по крайней мере, со своей "личной" копией.

</p><p>

Если же передача параметра идет  по ссылке, то и вызывающая функция, и
вызываемая  работают с  одной и  той же  переменной, и  все изменения,
сделанные вызванной функцией, оказываются видны в вызывающей.

</p><p>

Так вот, в С передачи параметров по ссылке нет (в С++ есть, но об этом
разговор впереди). Так что пример выше напечатает нам единицу. Кстати,
именно  благодаря  этому, функции  из  последнего  примера в  качестве
параметра можно при вызове  подсунуть не переменную, а число, например,
написать f(5). 

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="pointers"></a>
	    Адреса и указатели</h2>
<p>

Но  как же  быть, если  хочется  из функции  передать информацию  туда,
откуда ее вызвали?  Можно воспользоваться возвращаемым значением (тем,
что в операторе  <em>return</em>), если речь идет об одном  числе. А если чисел
несколько? Есть, конечно переменные файлового уровня - они с успехом с
этой  задачей справятся.  И порой  такой способ  очень удобен.  Но его
минус - повышение шансов  ошибиться из-за неучтенных побочных эффектов
при вызове функций. 

</p><p>

Есть  в С  еще  один  способ, пожалуй,  самый  распространенный. И  он
использует именно параметры функции. Как же нам совместить передачу по
значению с  передачей информации "наверх", вызывающей  функции?  А для
этого всего навсего надо в вызов функции поставить не саму переменную,
а ее адрес.  Этот адрес передастся по значению.  И функция при желании
может его изменять  - адрес в вызывающем коде  от этого не поменяется.
Но если  вызванная функция, не изменяя переданного  ей адреса, запишет
по  нему  новое значение,  то  вызвавший  ее  код "увидит"  это  новое
значение -  ведь по этому адресу  как-раз его переменная  и лежит. Вот
такая простая  идея. Но  для того, чтобы  от идеи дойти  до работающей
программы, нам придется  познакомиться с новым типом данных  и с двумя
новыми операторами.

</p><p>

Итак,  прежде всего  нам нужно  уметь получать  адрес  переменной. Для
этого в  С есть специальный  унарный оператор взятия адреса  & (значок
такой  же, как  и  у бинарного  битового  И). Вот  как выглядит  вызов
функции с адресом в качестве параметра:

<div class="incode">
	int i;<br>
	double d;<br>
	/*<br>
	&nbsp;&nbsp;Функции передаются адреса переменных i и d.<br>
	&nbsp;&nbsp;После вызова функции адреса останутся прежними<br>
        &nbsp;&nbsp;(pass-by-value), но значения могут измениться <br>
	*/<br>
	func( &i, &d );<br>
	...<br>
</div>

Но это  только вызов.  А какой тип  параметра мы должны  задать, когда
определяем функцию? Для этого  в С есть указатели (pointers). Выглядит
создание переменной типа "указатель" так:

<div class="incode">
	   char *s;	    /* указатель на char */<br><br>
	   int *pi;	    /* указатель на int */<br>
	   void *pv;	    /* указатель на void  */<br>
	   char **av	    /* указатель на указатель на char */<br>
<br>
	   /* <br>
	   &nbsp;&nbsp;А это указатель на функцию, которая возвращает<br>
	   &nbsp;&nbsp;int, а в качестве параметра ожидает char<br>
	   */<br>
	   int (*pf)(char) <br>
</div>

Как видите, указатели в С  можно написать для любого типа данных, даже
для void и для функций. По смыслу, да и по реакции транслятора это все
разные типы. Но тем не менее  все их называют указателями. И для того,
чтобы  создать указатель на  какой-то простой  тип, надо  указать этот
тип,  а  затем  перед  идентификатором (именем  переменной)  поставить
звездочку,  как в  строках  1-3.  Немногим  сложнее выглядит  создание
указателя на  указатель (четвертая строка) -  здесь придется поставить
не одну  звездочку, а  две. Труднее всего  привыкнуть к  указателям на
функции  (пятая  строка).  Но  пока   что  я  привел  его  просто  для
иллюстрации и  постараюсь по возможности  избегать его в  будущем, так
что не торопитесь пугаться.

</p><p>

Хочу обратить ваше внимание на интересный факт - хотя переменных типа
void не бывает, указатели на такие переменные (точнее, на этот тип)
есть. Для чего они нужны, мы узнаем чуть позднее.

</p><p>

После  того, что  я  вам  рассказал, становится  ясно,  как же  должен
выглядеть  список  формальных параметров  функции  <em>func()</em>, 
которую  мы
вызывали с адресами переменных:

<div class="incode">
	 void func(int *p1, double *p2)
</div>

Последнее, чего нам не хватает  для того, чтобы написать такую функцию
- это способа  добираться через адрес до самой  переменной.  Здесь нам
снова пригодится звездочка - на этот не как часть описания типа, а как
унарный  оператор доступа  по  адресу (pointer  dereference). Его  еще
называют разыменованием указателя, но  такой термин в русском варианте
не самый  удобопроизносимый (по  мне, так язык  сломать можно).  Термин я
назвал просто потому, что он встречается в книгах.

<div class="incode">
	 void func(int *p1, double *p2) {<br>
<br>
	 &nbsp;&nbsp;/* <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;Засылаем в целую переменную, на которую <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;указывает p1, значение 1<br>
         &nbsp;&nbsp;*/<br>
	 &nbsp;&nbsp;*p1 = 1;<br>
<br>
	 &nbsp;&nbsp;/* <br>
	 &nbsp;&nbsp;&nbsp;&nbsp;Добавляем 10.5 к переменной типа double,<br>
	 &nbsp;&nbsp;&nbsp;&nbsp;на которую указывает p2.<br>
         &nbsp;&nbsp;*/<br>
	 &nbsp;&nbsp;*p2 += 10.5;<br>
	 }<br>
</div>

Вот мы и написали функцию, которая через параметры передает информацию
"наверх",  изменяя  не  свои  локальные  переменные,  а  переменные  в
вызвавшем ее коде.

</p><p>

При  вызове  подобной  функции  не обязательно  указывать  в  качестве
параметра адрес какой то  переменной, можно вместо этого поставить все
тот  же указатель, в  котором такой  адрес содержится.  Так, например,
следующие два  вызова нашей функции func  приведут к одному  и тому же
результату:

<div class="incode">
	    int i, *pi;<br>
	    double d, *pd;<br>
<br>
	    /* Указываем непосредственно адреса */<br>
	    func(&i, &d); <br>
<br>
	    /* То же. но с использованием указателей */<br>
	    pi = &i;<br>
	    pd = &d;<br>
	    func(pi, pd);<br>
<br>
</div>

Как видите, здесь мы работаем с указателями как с обычными переменными
- засылаем в  них значения с  помощью оператора присваивания,  а потом
передаем  функции. 

</p><p>

Указатели можно использовать не только для параметров, но и в качестве
возвращаемого   значения   функции.   Вот  как,   например,   выглядит
определение и вызов функции, возвращающей указатель на тип char (такой
тип исользуется для передачи текстовых строк).

<div class="incode">
    char *genstr() {<br>
    &nbsp;&nbsp;char *p;<br>
    &nbsp;&nbsp;...<br>
    &nbsp;&nbsp;return p;<br>
    }<br>
<br>
    char *s;<br>
<br>
    s = genstr();<br>
</div>

"Начинку" самой  функции я  сейчас не привожу  - вы пока  маловато для
этого знаете. Но что касается принципа работы с возвращаемым значением
- он такой же, как и для простых типов.

</p><p>

Сразу должен предупредить, что указатели  в С - очень мощное средство,
и их применяют не только для работы с функциями, так что мы с ними еще
не  раз встретимся. Одна  из таких  встреч совсем  близко -  вскоре мы
будем  говорить об арифметике  указателей  и  о  родстве указателей  и
массивов.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="ptr_safety"></a>
	     Как избежать неприятностей с указателями?</h2>
<p>

Вместе с тем,  указатели (а с ними и массивы) -  это, по моему мнению,
самый большой источник неприятностей в С. Неаккуратная работа с ними -
самая частая причина возникновения ошибок  и сбоев в программе. К тому
же такого  рода ошибки могут быть настолько  хорошо замаскированы, что
программа может работать месяцами, а вы даже не заподозрите, что в ней
что-то  не так.  А  когда, наконец,  заподозрите, можете  еще месяцами
безуспешно  искать причину  своих  неприятностей. Проявления  подобных
ошибок могут  быть самыми разными: - программа  правильно работает, но
потихоньку  "распухает"  в памяти;  программа  почти всегда  правильно
работает, но  при некотором наборе входных  данных выдает неправильный
результат  или ломается;  программа  вроде бы  правильно работает,  но
после  ее работы  портится  операционная система  (это,  правда, и  от
системы  зависит) и  так  далее.  Но  при  всем многообразии  подобных
проявлений  суть ошибки  одна  - работа  с  "неправильным" адресом,  с
"неправильным" значением указателя. И  хотя у нас сейчас основная тема
- знакомство с  функциями, а  к указателям мы  еще не раз  вернемся, я
хочу не откладывая дать вам  хоть какое-то понятие об этих проблемах и
о тех приемах, которые помогают их избегать.

</p><p>

Чем же так опасны указатели? Посмотрите на такую программу - это один
из стандартных сюжетов, приводящих к неприятностям:

<div class="incode">
        void f(int *p) {<br>
	&nbsp;&nbsp;*p=1;<br>
        }<br>
<br>
        int main() {<br>
	&nbsp;&nbsp;int i;<br>
	&nbsp;&nbsp;int *ptr;<br>
<br>
	&nbsp;&nbsp;f(ptr);<br>
<br>
	&nbsp;&nbsp;...<br>
	&nbsp;&nbsp;return 0;<br>
	}<br>
</div>

Ничего  странного  не  замечаете?  Автор программы  забыл  записать  в
указатель <em>ptr</em> значение. Возможно,  было желание передать 
функции адрес
переменной  i, может  - какой-то  другой, но  так или  иначе  этого не
сделано, в вызове используется неинициализированный указатель.

</p><p>

Поскольку  <em>ptr</em>  -  это  самая обычная  автоматическая  переменная,  то
содержать она будет "мусор" - непредсказуемое значение.  А функция <em>f()</em>
расценит его как адрес целой переменной и запишет туда единицу. Думаю,
дальше все ясно. Если вам  повезет, вы испортите таким образом кусочек
памяти, который  программе уже  не нужен. Но  везет редко,  и портится
обычно  что-то нужное. И  программа может  успешно работать  еще очень
долго, вызывая  другие функции сотни и  тысячи раз, пока  не дойдет до
кода, который  это "что-то нужное" использует. И  вы будете размышлять
над вопросом "почему я делю на два, а сообщение об ошибке - деление на
ноль?". Или программа посчитает вам тангенс вместо экспоненты.

</p><p>

Надеюсь, вы прониклись пониманием проблемы.

</p><p>

Сам язык С практически  не сожержит специальных средств, страхующих от
подобных  вещей  (хорошо  это   или  плохо,  мы  сейчас  обсуждать  не
будем).  Поэтому  основная  работа  тут  ложится  на  тех,  кто  пишет
программы. И  за долгое время работы с  языком программисты выработали
набор  приемов, правил  и  соглашений -  правила  "хорошего тона"  при
работе с указателями, которые помогают избегать подобных ошибок. Часть
этих правил я сейчас вам расскажу:

</p><p>

Во-первых,  указатели   всегда  должны  содержать   какой-то  разумный
адрес. Так что засылайте в них значение сразу, как только создали. Или
инициализируйте прямо в момент создания:

<div class="incode">
		int i;<br>
<br>
		int *p1=&i;<br>
		int *p2;<br>
		p2=&i;<br>
</div>

А  что делать, если  указатель вы  создали, но  пока не  знаете, какой
адрес в него записать? Для этого есть специальное значение указателя -
в C  это символьная  константа <em>NULL</em>,  в C++ -  0. Считается,  что если
указатель  содержит такой адрес,  то он  никуда не  указывает. Правда,
чтобы  использовать  в  С  эту  константу,  вам  придется  включить  в
программу файл-заголовок - stdlib.h:

<div class="incode">
	  #include &lt;stdlib.h><br>
<br>
	  main() {<br>
<br>
	  &nbsp;&nbsp;char *p=NULL;<br>
<br>
	  &nbsp;&nbsp;...<br>
<br>
	  }<br>
</div>

Ну, и  разумеется, не худо  бы перед использованием проверить  - вдруг
вам  отдали  указатель,  который  никуда  не указывает.  Вот  один  из
вариантов:

<div class="incode">
        void f(int *p) {<br>
	&nbsp;&nbsp;if (p != NULL)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;*p=1;<br>
	&nbsp;&nbsp;else {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;printf("Help!!! NULL pointer in f()\n");<br>
	&nbsp;&nbsp;&nbsp;&nbsp;abort();<br>
	&nbsp;&nbsp;}<br>
        }<br>
</div>

(<em>abort()</em> - это специальная  функция из стандартной библиотеки, которая
немедленно  прекращает выполнение  программы).   

</p><p>

Примерно так поступают многие  функции стандартной библиотеки, и вам я
советую по возможности использовать  подобные проверки в вашем коде. А
теперь давайте  соберем все эти советы вместе,  и перепишем программу,
которой я вас пугал, с учетом "правил хорошего тона".

<div class="incode">
	#include &lt;stdlib.h><br>
	#include &lt;stdio.h><br>
<br>
        void f(int *p) {<br>
	&nbsp;&nbsp;if (p != NULL)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;*p=1;<br>
	&nbsp;&nbsp;else {<br>
	&nbsp;&nbsp;&nbsp;&nbsp;printf("Help!!! NULL pointer in f()\n");<br>
	&nbsp;&nbsp;&nbsp;&nbsp;abort();<br>
	&nbsp;&nbsp;}<br>
        }<br>
<br>
        int main() {<br>
	&nbsp;&nbsp;int i;<br>
	&nbsp;&nbsp;int *ptr=NULL;<br>
<br>
	&nbsp;&nbsp;f(ptr);<br>
<br>
	&nbsp;&nbsp;...<br>
	&nbsp;&nbsp;return 0;<br>
	}<br>
</div>

Как  видите,  здесь мы  снова  "забыли"  присвоить указателю  значение
переменной.   Но  теперь  это  приведет  к  гораздо  менее  неприятным
последствиям.  Программа  просто напечатает  сообщение  -  то, что  мы
поставили  в  <em>f()</em>,  а  затем  вызовет  функцию  <em>abort()</em>  
и  немедленно прекратит работу.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="scanf"></a>scanf() - чтение данных из потока.</h2>
<p>


Теперь,  когда мы разобрались  с механизмом  передачи параметров  и (в
первом приближении)  с указателями,  я могу, наконец,  представить вам
"собрата" <em>printf()</em>  - функцию из стандартной 
библиотеки  C, которая не
выводит, а считывет значения.

</p><p>

Функция эта  <em>scanf()</em>. Ее  использование очень похоже  
на использование
<em>printf()</em>. В частности,  в качестве первого параметра у  нее тоже стоит
строка  формата, в  которой могут  встречаться  специальные комбинации
символов, и даже многие комбинации  совпадают по смыслу для <em>printf()</em> и
<em>scanf()</em>  (например,  <em>%d</em> для  обеих  функций  означает  
знаковое целое  в
десятичной системе). Но  поскольку <em>scanf()</em> используется для считывания
значений (то есть, для изменения  переменных в вызывающем коде, то и в
качестве  параметров  ей  вы  должны  указывать  не  сами  нужные  вам
переменные,  а либо  их  адреса,  либо указатели  на  них. Так,  чтобы
считать два целых числа, разделенные  пробелом, в переменные <em>i</em> 
и <em>j</em>, вы
должны написать примерно следующее:

<div class="incode">
	 int i, j;<br>
	 scanf("%d %d", &i, &j);<br>
</div>

или (более длинно, но результат будет такой же):

<div class="incode">
	int i, j;<br>
	int *p1,*p2;<br>
	p1=&i;<br>
	p2=&j;<br>
	scanf("%d %d", p1, p2);<br>
</div>


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="defdecl"></a>
	    Объявление и определение функции.</h2>
<p>


И,  наконец, в  завершение  разговора  о функциях,  а  заодно и  этого
занятия,  я хочу рассказать  вам о  том, чем  определение (definition)
функции отличается от ее объявления (declaration).

</p><p>

Итак,  определение функции -  это ее  полное описание,  включающее тип
возвращаемого значения, количество и  типы самих параметров, и ее тело
- тот код,  который стоит внутри фигурных скобок  после имени функции.
Когда  я  показывал вам,  как  пишутся  (создаются,  а не  вызываются)
функции, вы видели именно определения функций. Что же такое объявление
функции, и зачем оно понадобилось?

</p><p>

Взгляните на такие строчки кода.

<div class="incode">
	int main() {<br>
	&nbsp;&nbsp;int i;<br>
<br>
	&nbsp;&nbsp;i = 1;<br>
<br>
	&nbsp;&nbsp;f(i);<br>
	&nbsp;&nbsp;...<br>
	&nbsp;&nbsp;return 0;<br>
        }<br>
</div>

Что по ним можно сказать о функции <em>f()</em>? На первый взгляд, это функция,
которой нужен один аргумент типа <em>int</em>. С возвращаемым значением ясности
нет  -  либо  <em>void</em>,  либо   любой  другой  тип,  но  значение  в  коде
игнорируется.

</p><p>

А теперь поглядите на определение этой функции:

<div class="incode">
	   void f(double x) {<br>
	   &nbsp;&nbsp;...<br>
           }<br>
</div>

Тип параметра, оказывается, не <em>int</em>, а <em>double</em>. 
И размеры у них разные -
<em>int</em> занимает 4 байта, а <em>double</em> - 8. Хорошо, 
если определение функции
стоит до ее вызова в том же файле

<div class="incode">
	   void f(double x) {<br>
	   &nbsp;&nbsp;...<br>
           }<br>
<br>
  	  int main() {<br>
	  &nbsp;&nbsp;int i;<br>
<br>
	  &nbsp;&nbsp;i = 1;<br>
<br>
	  &nbsp;&nbsp;f(i);<br>
	  &nbsp;&nbsp;...<br>
	  &nbsp;&nbsp;return 0;<br>
          }<br>
</div>

Тогда  транслятор, уже  зная о  функции, сообразит,  что  надо сначала
привести значение <em>i</em> к типу <em>double</em>, 
а уж потом подсовывать его функции.

</p><p>

Но  если такая  функция  хранится  в библиотеке  или  в другом  файле,
который транслируется  отдельно (раздельной трансляции  мы со временем
тоже будем  учиться), то тогда результат  будет плачевный. Обрабатывая
файл с вызовом функции, транслятор решит, что ей надо передать 4 байта
со значением int. И тот же транслятор, обрабатывая файл с определением
функции,  создаст код,  который использует  для параметра  8  байтов -
размер  переменной double.  В результате  вызванная функция  получит 4
байта от  целого, и еще 4  байта "мусора", и попытается  с этой смесью
работать, как с нормальным числом типа double.

</p><p>

Именно для того чтобы  избегать подобных неприятностей, в С/С++ помимо
определений сушествуют еще  и объявления (и это относится  не только к
функциям).

</p><p>

Если  определение -  это  полное описание  чего-либо  (в нашем  случае
функции, но это может быть  и тип данных, и переменная), то объявление
содержит  лишь ту  информацию, которая  необходима  транслятору, чтобы
избегать  ошибок  вроде  показанной  выше.  Так,  например,  мы  можем
преодолеть наши трудности с функцией  <em>f()</em>, 
добавив всего одну строку с ее объявлением перед <em>main()</em>:

<div class="incode">
	  void f(double x);<br>
  	  int main() {<br>
	  &nbsp;&nbsp;...<br>
</div>

Как  видите, такое  объявление не  содержит  тела функции  - сразу  за
списком параметров стоит точка  с запятой. Но транслятору этого вполне
достаточно -  он теперь  будет знать, что  где-то (возможно,  в другом
файле или  в библиотеке)  есть такая функция,  и он теперь  сможет или
преобразовать фактический  параметр к правильному  типу перед вызовом,
или хотя бы  (в тяжелых случаях) уведомить вас  о том, что переменная,
которую вы используете, не подходит для вызова.

</p><p>

Ну, а поскольку объявления  содержат "неполную" информацию - у функций
нет тела,  под переменные  не резервируется память,  и так далее  - их
можно включать хоть в каждый  файл программы, на ее размере и скорости
работы  это   не  скажется  (лишь   бы  объявления  в   разных  файлах
соответсвовали друг другу). И  чтобы не писать, рискуя ошибиться, одно
и   то   же   многократно,   такие  объявления   обычно   собирают   в
файл-заголовок, а потом этот  файл при необходимости включают в другие
с помощью  директивы #include. Так,  например, файл-заголовок <em>stdio.h</em>,
который  мы   включали  в  наши  программы,   среди  прочего  содержит
объявления <em>printf()</em> и <em>scanf()</em>, 
в то время как сами эти функции лежат в другом месте - в библиотеке.

</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>
