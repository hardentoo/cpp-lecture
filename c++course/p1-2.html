<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 1, lesson 2</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 1, занятие 2</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Основы языка (1)
	<ul>
          <li><a href="p1-2.html#scope">Области видимости</a>
          <li><a href="p1-2.html#identifiers">
	        Тип int. Создание переменных. Идентификаторы</a>
          <li><a href="p1-2.html#op_prog">
	        Программа для знакомства с операторами</a>
          <li><a href="p1-2.html#countops">Сколько всего операторов?</a>
          <li><a href="p1-2.html#assignment">Оператор присваивания</a>
          <li><a href="p1-2.html#math">
	    Арифметические операторы. Гибриды с присваиванием. ++ и --</a>
          <li><a href="p1-2.html#numbers">
	    Необходимое отступление: - представление чисел в компьютере</a>
          <li><a href="p1-2.html#bitops">Битовые операции</a>
          <li><a href="p1-2.html#sizeof">Оператор sizeof</a>
	</ul>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center"><a name="scope"></a>Основы языка (1)</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
	 <h2>Области видимости</h2>
<p>


На прошлом занятии  мы с вами написали аж  3 программы, посмотрели, из
чего они  состоят, и даже  успели познакомиться с <em>printf()</em>  
- функцией вывода из стандартной  библиотеки языка С.  
На этом  занятии, я, как и
собирался,  начну  рассказывать  вам  о переменных  (точнее,  о  типах
данных)  и  об  операторах   языка.   Поскольку  сначала  мы  пытаемся
познакомиться  с тем общим,  что есть  и в  С, и  в С++,  я постараюсь
больше  не приговаривать "это  одинаково хорошо  работает и  в С,  и в
С++". И буду использовать имена файлов с расширением .c (язык С).

</p><p>

Но  прежде,   чем  перейти  к  типам  данных  и   переменным,  давайте
познакомимся с  понятием области (или  уровня) видимости. А  для этого
еще раз взглянем на программу, которая печатает приветствие:

<div class="code">
	     /* Программа, печатающая приветствие - hello.c */<br>
	     #include &lt;stdio.h><br>
<br>
	     int main()<br>
	     {<br>
	     &nbsp;&nbsp;printf("Hello, world\n");<br>
	     &nbsp;&nbsp;return 0;<br>
	     }<br>
</div>

В ней у нас есть  комментарий, директива <em>#include</em>, и 
функция <em>main()</em>, в теле  которой  (то  есть,   в  выделенном  
фигурными  скобками  блоке,
следующем  сразу за именем  функции) стоят  вызов <em>printf()</em>  
и оператор <em>return</em>.

</p><p>

Все  то,  что в  этой  программе  располагается  вне фигурных  скобок,
относится к так называемому файловому уровню видимости - file scope (я
его часто называю глобальным -  не удивляйтесь, если оговорюсь, но это
не совсем одно и то же).

</p><p>

Что означают слова "файловый уровень видимости" (или "файловая область
видимости")? Очень  простую вещь -  все, что написано на  этом уровне,
видимо   (или,  если  угодно,   известно)  всем   остальным  элементам
программы,  которые записаны  дальше в  этом  же файле.  Объяви мы  на
файловом уровне  переменную перед функцией  <em>main()</em>, мы смогли 
бы  ее в этой функции использовать. 

</p><p>

У  нас  в  программе  на  файловом уровне  сейчас  стоят  комментарий,
директива  <em>#include</em> и  функция <em>main()</em>.   Как я  
уже  проговорился, там
могут появляться и  переменные. А что еще можно  поместить на файловый
уровень?

</p><p>

Ну,  во первых,  там (а  в  случае С  - только  там) могут  появляться
определения   других  функций.  Еще   там  могут   определяться  типы,
задаваться  константы.  И,  наконец,  там могут  появляться  директивы
транслятора (одну из них - <em>#include</em> - вы уже видели).

</p><p>

Если  же переменная  (или что-то  еше)  появляется в  блоке (то  есть,
внутри фигурных  скобок), то  про нее говорят,  что она  определена на
локальном  уровне (local  scope).   А чаще  просто называют  локальной
переменной. И видна такая  переменная будет только внутри этого блока.
На  локальном уровне не  могут появляться  функции (я  имею в  виду не
вызов, а определение), зато там  и только там могут стоять исполняемые
операторы.

</p><p>

Ну вот, а теперь, после этого небольшого отступления займемся наконец
типами и операторами.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="identifiers"></a>
	   Тип int. Создание переменных. Идентификаторы</h2>
<p>

На самом деле, по крайней мере один тип вы уже знаете. Это <em>int</em> 
- встроенный тип для целого числа со знаком. Именно такой тип возврашали
наши функции <em>main()</em> во всех примерах. Но у нас была определена
функция, а мы хотим переменную. Переменные определяются очень похожим
способом:

<div class="incode">
	int m; /* целая переменная m */<br>
<br>
	int product, M; /* две целых переменных product, M    */<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Еще не забыли? m и M - разные вещи */<br>
<br>
	int s=300, k=0; /* А здесь мы не только создаем переменные */<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* но и задаем их начальные значения       */<br>
</div>

Итак, чтобы  создать переменную или несколько  переменных одного типа,
надо сначала написать тип (пока мы ограничимся типом <em>int</em>), 
затем после пробела указать разделенный  запятыми список идентификаторов, 
то есть, имен создаваемых переменных. Переменным в списке (не обязательно всем)
можно сразу  присвоить начальные значения при помощи  знака = (равно),
или,  как  принято  говорить,  можно  инициализировать  их  начальными
значениями.  И наконец, надо  завершить всю  эту конструкцию  точкой с
запятой.

</p><p>

Относительно идентификаторов - какие на них ограничения и как разумно
их выбирать? Идентификатор в С (это относится не только к переменным,
но и к функциям, именам типов и т.п.) должен начинаться с буквы, может
содержать буквы, цифры и символ подчеркивания. Большие и маленькие
буквы различаются. 

</p><p>

Еще  одно  правило -  идентификатор  не  должен  совпадать с  ключевым
(зарезервированным) словом  языка.  Ну, например,  нехорошо, объявлять
переменную с  именем return или  int. Впрочем, таких ключевых  слов не
слишком  много, так  что  это ограничение  не  такое страшное.   Хотел
привести  вам  полный   список  ключевых  слов  C  и   С++,  но  потом
раздумал. Начать работать на этих языках можно и без этого знания, так
зачем вас путать - когда понадобится, посмотрите в справочнике.

</p><p>

Относительно  длины -  ограничений  нет, но  уникальными по  стандарту
считаются те, у  которых есть различия в первых  31 символах. То есть,
если вы объявите две переменных:

<div class="incode">   
	int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1;<br>
	int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa2;<br>
</div>

у вас  могут (хотя и  не обязательно) возникнуть проблемы.  Впрочем, у
меня как то ни разу не возникало нужды в столь длинных именах.

</p><p>

Как правильно выбирать имена? Универсального рецепта я не знаю.

</p><p>

Чем  имена  короче, тем  быстрее  пишется  программа (просто  набирать
приходится  меньше). С  другой стороны,  тем легче  пропустить ошибку,
происпользовав какую-нибудь уже созданную переменную не по назначению.

</p><p>

Более длинные имена можно сделать и более осмысленными. Ясно, что для
функции деления имя <em>divide</em> подойдет больше, чем <em>d</em>. 
Но и тут есть свои неприятности. Сравните две строчки:

<div class="incode">
     printf("%d %d\n",i, j);<br>
<br>
     printf("%d %d\n", my_precious_variable, anotherPreciousVariable);<br>
</div>

Вторую строку  и набирать  замучишься, и описку  сделать легче.   Да и
вспомнить со временем непросто бывает, как именно вы разделили слова -
символом подчеркивания  или заглавными буквами -  приходится лазить по
программе, искать где эти переменные определяются.

</p><p>

Ну  а золотую  середину каждый  находит себе  сам -  в  соответствии с
темпераментом и опытом.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="op_prog"></a>
	   Программа для знакомства с операторами</h2>
<p>

Итак, мы теперь умеем создавать переменные типа int. Давайте для
начала этим типом  и ограничимся - будем, работая с целыми числами,
наблюдать, что делают с ними различные операторы. А чтобы наблюдать
было легче, напишем заготовку тестовой программки:

<div class="code">
     /* testop.c - программа для знакомства с операторами */<br>
     #include &lt;stdio.h><br>
<br>
     int op1, op2, op3;<br>
     int result;<br>
<br>
     int main() <br>
     {<br>
     &nbsp;&nbsp;/* <br>
     &nbsp;&nbsp;&nbsp;&nbsp;Сюда мы будем вставлять разные операторы<br>
     &nbsp;&nbsp;*/<br>
<br>
<br>
     &nbsp;&nbsp;/* А printf() поможет нам понять, что из этого вышло */<br>
     &nbsp;&nbsp;printf("%s, op1=%d, op2=%d, op3=%d, result=%d\n",<br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Nothing", op1, op2, op3, result);<br>
<br>
     &nbsp;&nbsp;return 0;<br>
     }<br>
</div>

Теперь, как обычно, <em>make&nbsp;testop;&nbsp;./testop</em>

<div class="session">
	Nothing, op1=0, op2=0, op3=0, result=0
</div>

Ну  вот, теперь  нам  останется только  вставлять  разные операторы  в
программу  и   менять  соответственно  сообщение   (которое  сейчас  -
Nothing). Дальше я не буду каждый раз приводить текст этой программы -
только  те  операторы,  которые   мы  будем  испытывать.  Надеюсь,  вы
запомнили, как она выглядит.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="countops"></a>Сколько всего операторов?</h2>
<p>

       
Добрались,  наконец, до  операторов.  Для  начала  попробуем сосчитать,
сколько операторов вы уже знаете?

</p><p>

Итак, прежде всего - оператор <em>return</em> - он 
есть во всех наших программах.
Затем - оператор вызова функции <em>()</em>.
И, наконец - пустой оператор ; (точка с запятой).

</p><p>

Кстати, вот  еще одно  необходимое замечание. В  английской литературе
есть  два слова -  <em>operator</em> и  <em>statement</em>.  
И  если первое  относится к
чему-нибудь  вроде  деления  (у   которого  есть  два  операнда,  есть
результат  операции), то  под вторым  подразумевают нечто  иное  - или
строку  программы (которая может  содержать несколько  operators), или
конструкцию языка, содержащую ключевые слова и, возможно, еще что-то).
В  русских же  текстах по  программированию  и тех  и других  называют
операторами, что  порой вносит изрядную  путаницу. Но что  поделаешь -
издавна длину  програм на Руси  измеряли в операторах. А  про оператор
<em>goto</em> так  вообще анекдоты  ходят. 

</p><p>

Некоторые переводчики стараются для ясности слово <em>statement</em> 
перевести, как "инструкция",  но на мой  взгляд, 
такой перевод, если  и добавляет
где-то ясности, то убавляет ее в других местах (а как тогда переводить
instruction?).  Так  что  я  буду  придерживаться  старой  сложившейся
терминологии -  привыкайте, со временем начнете различать,  о чем идет
речь.  Между  прочим, именно из-за  подобных "капканов", ну  и конечно
из-за неизбежных  опечаток, я предпочитаю (и вам  советую, если знание
языка  позволяет) по  возможности читать  книги по  программированию в
оригинале.

</p><p>

Теперь, после  этого отступления, могу  сказать - из  трех операторов,
которые мы  насчитали, только вызов функции  <em>()</em> - operator,  
а точка с запятой и <em>return</em> - statements. И сейчас мы с 
вами будем знакомиться с теми операторами, которые operators.

</p><p>

А сколько их всего? Я (по книжке, не по памяти) насчитал 68. Из них 48
есть и в С, и в С++, а еще 20 - только в С++.

</p><p>

Довольно  много, на  первый взгляд.   Но не  торопитесь  пугаться.  Во
первых,  часть  операторов   носит  вполне  понятный,  можно  сказать,
естественный смысл - их будет  нетрудно запомнить. Во вторых, есть в С
и С++ группы  операторов, которые в чем-то друг на  друга похожи - это
тоже помогает с ними освоиться: - запомнил один, считай, всю группу знаешь. 
И в третьих, восе не обязательно сразу
начинать  использовать всю  эту коллекцию  - во  многих  случаях можно
прекрасно обойтись только частью из них.


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="assignment"></a>
	   Оператор присваивания</h2>
<p>

Для того,  чтобы что-то делать  с переменными, нужно уметь  заносить в
них значения. Как это делается при создании переменных с помощью знака
= (инициализация), вы уже видели. Но частенько переменная уже создана,
а ее значение  хочется поменять. Так что наш  первый пример - оператор
"=" (знак равно, а оператор присваивания):

<div class="incode">
	op1=5;
</div>

или

<div class="incode">
	op2=op1;
</div>


Вполне понятно, что эти операторы делают - первый заносит в переменную
op1 значение  5. Второй заносит в  op2 значение из  op1. Однако, кроме
этого  оператор присваивания  еще и  возвращает результат  -  то самое
значение, которое он занес в переменную. Зачем? Ну, например для того,
чтобы мы могли написать вот такую конструкцию:

<div class="incode">
	result=op3=7;
</div>

Непривычно  для других языков  программирования, но  в С/С++  вы такое
встретите сплошь и рядом. Операторы присваивания обрабатываются справа
налево, читать  эту строку следует так:  - "занести в  op3 значение 7,
затем занести в  result значение из op3".

</p><p>

Поставив  три приведенные выше  строчки в  нашу тестовую  программку и
заменив сообщение на Assignment, мы увидим вполне ожидаемый результат:

<div class="session">
	Assignment, op1=5, op2=5, op3=7, result=7
</div>

Засылать  значение   при  помощи   присваивания  можно  не   только  в
переменную. Приведу, не объясняя пока, несколько примеров:

<div class="incode">
	a[i]=1;<br>
	*(p+i) = a[i];<br>
	p->link = 0;<br>
</div>

При этом, если попытаться написать что-то вроде

<div class="incode">
	1=i;
</div>

транслятор выдаст вам сообщение об ошибке.

</p><p>

Есть даже специальные термины для  того, чтобы пояснять, куда можно, а
куда  нельзя засылать  значения с  помощью оператора  присваивания. По
английски они звучат <em>lvalue</em> и <em>rvalue</em> 
(сокращения от left value и right
value, дословный  перевод - левое и правое  значения). Названия вполне
отражают смысл: lvalue - это  то, что можно поставить слева в оператор
присваивания, то  есть, куда можно засылать значение;  rvalue же можно
ставить в операторе присваивания только справа.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="math"></a>
	   Арифметические операторы. Гибриды с присваиванием. ++ и --</h2>
<p>


Как вы понимаете, в переменную можно засылать не только значения, но и
результаты каких то операций - например, арифметических вычислений:

<div class="incode">
	op1=8; op2=2; op3=-4;<br>
	result=( op1 + op2 * 4 ) / (op3 - 4);<br>
</div>

(пробелы во второй строке я добавлял для большей читаемости, выражение
<em>(op1+op2*4)/op3</em>  сработает точно так же).

</p><p>

Здесь мы  видим сразу  несколько арифметических операторов  - сложить,
вычесть,   умножить,  разделить.  Приоритеты   (последовательность,  в
которой в выражении выполняются операторы), соответствуют человеческим
умолчаниям.  Где необходимо,  эту  последовательность можно  изменить,
заключив часть выражения в круглые скобки.

</p><p>

Поставив  эти две  строки и  сообщение  "result=(op1+op2*4)/(op3-4)" в
тестовую программку, увидим:

<div class="session">
	result=(op1+op2*4)/(op3-4), op1=8, op2=2, op3=-4, result=-2
</div>

Для удобства  программистов в С  есть гибрид оператора  присваивания и
арифметических  (а  также еще  некоторых)  операторов.  Если  у вас  в
программе возникла потребность написать что-то вроде

<div class="incode">
	op1 = op1 + op2;<br>
	result = result * (op2+op3);<br>
</div>

вы вполне можете заменить это на

<div class="incode">
	op1 += op2;<br>
	result *= op2+op3;<br>
</div>

Так приходится меньше  писать - и быстрее получается,  и меньше шансов
внести опечатку, поскольку не надо одно  и то же писать два раза. Да и
читать потом такую программу будет легче.

</p><p>

Все такие гибридные операторы (а они все основаны на бинарных, то есть
работающих с двумя операндами, операторах - вроде оператора умножения)
работают по одной и той же схеме.  Сначала вычисляется то, что стоит в
правой части -  это будет второй операнд. Затем  берется переменная из
левой части и используется в качестве первого операнда.  С этими двуям
операндами  выполняется  та   операция,  которая  стоит  перед  знаком
равенства.  И,  наконец, полученный результат  заносится в переменную,
стоящую  в  левой части.  Подобные  операторы  очень  удобны, если  вы
накапливаете  сумму, или хотите  отнормировать значение  переменной, и
еще во множестве других случаев.


</p><p>

Следующий оператор, окотором я хочу рассказать - % (процент), оператор
деления по модулю. Если мы работаем с целыми числами, то вполне
естественно, что написав

<div class="incode">
	op1=9;<br>
	op2=4;<br>
	result = op1 / op2;<br>
</div>

мы получим в результате 2 - делим то нацело. А можно ли узнать остаток
от деления? Можно - именно это и делает %.

<div class="incode">
	op1=9;<br>
	op2=4;<br>
	result = op1 % op2;  /* получим 1 */ <br>
</div>

Есть и "гибрид" присваивания с этим оператором 

<div class="incode">
	result=13;<br>
	result %= 10;  /* получим 3 */ <br>
</div>

Где % облегчаeт жизнь? Применений у него масса. Так, например,

<div class="incode">
	odd = a % 2;
</div>

это простой  способ узнать, четное у  нас число или  нет, а что-нибудь
вроде

<div class="incode">
	angle %= (2*pi);
</div>

поможет убрать из значения угла полные обороты.

</p><p>

Есть еше то  ли два, то ли четыре оператора, которые  в общем то можно
отнести   к  арифметическим,   хотя  у   них  есть   масса   и  других
применений. Речь идет о  специальных операторах добавления и вычитания
единицы к/из переменной  - операторах ++ и --. Почему  я сказал "то ли
два, то  ли четыре"? Потому что и  ++, и -- можно  поставить или перед
переменной,  или после  нее  -  и при  этом  операторы будут  работать
немного по разному. Но давайте посмотрим, как это выглядит:

<div class="incode">
	op1=5;<br>
<br>
	op1++; /* Добавили единичку, теперь в op1 6 */<br>
<br>
	++op1; /* А теперь 7 */<br>
<br>
	op1--; /* Вычли единичку, в op1  6 */<br>
<br>
	--op1; /* В op1 снова 5 */<br>
</div>

Если ++ или  -- стоят перед переменной, их  называют префиксными, если
после переменной - постфиксными.

</p><p>

Ну, зачем  понадобился новый способ добавить(или  отнять) к переменной
единичку, еще хоть  как-то можно понять.  Но зачем  при этом у каждого
оператора по  две разновидности?  В  таком примере, как  показан выше,
разницы  не  различить.  Но  эти  операторы  не  только добавляют  или
вычитают единичку  из переменной, они  еще и возвращают  значение этой
переменной.   Причем  префиксные сначала  меняют  переменную, а  потом
возвращают  значение.   А   постфиксные  сначала  возвращают  значение
переменной, а  потом меняют ее. Не очень  понятно? Давайте разбираться
на примере двух разновидностей оператора ++.

<div class="incode">
	op1 = 1;<br>
	op2 = ++op1;<br>
<br>
	op3 = 1;<br>
	result = op3++;<br>
</div>

Поставив это  вместе с сообщением "Prefix/postfix ++"  в нашу тестовую
программку, увидим следующее:

<div class="session">
	Prefix/postfix ++, op1=2, op2=2, op3=2, result=1
</div>

И op1, и op2 равны 2. Мы  добавили единичку к op1, а потом занесли то,
что получилось в op2. Смотрим  дальше.  op3 тоже равен 2, поскольку мы
тоже добавили  к нему единичку.  А вот  result у нас равен  1, ведь на
этот раз мы использовали постфиксный оператор.

</p><p>

Итак, конструкция 

<div class="incode">
	i = ++j;
</div>

делает то же, что и

<div class="incode">
	j = j + 1;<br>
	i = j;<br>
</div>

А вот конструкция 

<div class="incode">
	i = j++;
</div>

работает следующим образом

<div class="incode">
	i = j;<br>
	j = j + 1;<br>
</div>


Операторы --  работают точно так  же, только единичку не  добавляют, а
вычитают.

</p><p>

Собственно,   на    этом   арифметические   операторы    в   C/C++   и
заканчиваются.  Оператора возведения  в  степень (как  в фортране  или
алголе) не предусмотрено - степени считаются с помощью функций. Да это
и понятно  - С,  да и С++  по замыслу  языки, "близкие и  понятные" не
только людям, но  и компьютерам. А я как то  не встречал компьютера, у
которого в списке инструкций было бы возведение в степень.

</p><p>

Между прочим, помните, я говорил в начале занятия, что насчитал в С 48
операторов? Так вот, мы с вами уже познакомились с 17 из них.
Давайте еще раз их вспомним.

<ol>
  <li>=  (присваивание)
  <li>-  (унарный, например op2 = -op1; )
  <li>+  (унарный, например op2 = +op1; практически не используется)
  <li>+  (бинарный, сложение)
  <li>-  (бинарный, вычитание)
  <li>*  (бинарный, умножение)
  <li>/  (бинарный, деление)
  <li>%  (бинарный, деление по модулю - вычисление остатка от деления)
  <li>+= (сложение с присваиванием)
  <li>-= (вычитание с присваиванием)
  <li>*= (умножение с присваиванием)
  <li>/= (деление с присваиванием)
  <li>%= (деление по можулю с присваиванием)
  <li>++var (добавить единичку, префиксный)
  <li>var++ (добавить единичку, постфиксный)
  <li>--var (отнять единичку, префиксный)
  <li>var-- (отнять единичку, постфиксный)
</ol>


</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="numbers"></a>
            Необходимое отступление: - представление чисел в компьютере</h2>
<p>

Следующим нашим шагом будет изучение битовых операторов. Но перед этим
я  хочу немного  напомнить о  том,  как устроены  числа в  компьютере.
Приношу свои извинения за это отступление. Как вы заметили, я стараюсь
по возможности не грузить вас  ненужными деталями. Но если уж мы хотим
понять,  как  работают  битовые  операции, нужно  иметь  хоть  немного
представления о битах и кодах.

</p><p>

Итак, та  информация, которую мы заносим в  компьютер, преобразуется в
соответствии с  принятым для  нее кодом и  заносится в байты  памяти в
виде   чисел.    Так,  например,   латинская   буква   A  в   наиболее
распространенной кодировке ASCII выглядит в компьютере, как десятичное
число  65. Байт  - это  минимальная самостоятельно  адресуемая единица
памяти (слово  "самостоятельно" означает, что вы  можете прочитать или
записать один  байт, не затрагивая других).  Переменные могут состоять
из  одного  или  из   нескольких  байтов.  Так,  например,  символьные
переменные состоят из одного байта, а в целых может быть 2, 4 или даже
больше байтов.

</p><p>

Естественно,  число,  которое  заносится  в память  компьютера,  можно
представить в разных  системах счисления. Десятичная наиболее привычна
человеку, восьмеричная, шестнадцатиричная  и двоичная особенно удобны,
если  вы  имеете  дело  с  компьютером. Причина  проста  -  устройство
компьютера  таково, что  в конечном  итоге мы  имеем дело  с понятиями
"есть  сигнал" или "нет  сигнала", то  есть, с  двумя состояниями  - и
лучше  всего для  этого подходит  двоичная система,  в  которой каждый
разряд как  раз и может иметь  всего 2 состояния  - 0 или 1.   И такой
разряд называется битом. В байте - 8 битов (раньше были компьютеры и с
другим  числом битов в  байте, но  сейчас я,  честно говоря,  не знаю,
остались ли еще такие).

</p><p>

Что касается  восьмеричной или  шестнадцатиричной систем -  эти хороши
тем, что они  основаны на степени двойки, то есть  каждый разряд в них
содержит целое число битов.  И в  то же время числа, записанные в них,
получаются покороче, чем в двоичной.

</p><p>

Но поскольку цель у нас сугубо прагматичная - познакомиться с битовыми
операциями, то мы  сейчас будем говорить о двоичной  системе, точнее о
том, как в ней представляются целые числа.

</p><p>

Перевести  десятичное число  в двоичное  довольно просто  -  вы просто
делите  его на  два, остаток  от  деления записываете  в самый  правый
разряд,  затем делите результат  еще раз  на два,  остаток записываете
слева от предыдущей цифры, и так пока число не кончится. Для примера,
переведем в двоичную систему число 9:

<div align="center">
   <table width="50%">
     <tr><td align="center">шаг</td>
         <td align="center">&nbsp;&nbsp;что делим&nbsp;&nbsp;</td>
         <td align="right">остаток</td>
     </tr>

     <tr>
         <td align="center">1</td>
         <td align="center">9</td>
         <td align="right">1</td>
     </tr>
     <tr>
	 <td align="center">2</td>
	 <td align="center">4</td>
	 <td align="right">01</td>
     </tr>
     <tr>
         <td align="center">3</td>
	 <td align="center">2</td>
	 <td align="right">001</td>
     </tr>
     <tr>
         <td align="center">4</td>
	 <td align="center">1</td>
	 <td align="right">1001</td>
     </tr>
   </table>
</div>

</p>

Итак, число 9 в двоичной  системе занимает четыре бита и выглядит, как
1001. А  сколько чисел  можно записать  в четыре  бита? И  какое самое
большое число в этих четырех битах можно выразить? Всего в четыре бита
можно записать 2 в четвертой степени, то есть 16 чисел. Что касается
самого большого числа ...

</p><p>

Если  вы  имеете  дело  с  беззнаковыми  (то  есть,  неотрицательными)
числами, то ответ прост - мы можем  записать туда 16 чисел от 0 до 15,
стало быть, самое большое число - 15.

</p><p>

Если же мы говорим о числах со знаком, то ситуация меняется - ясно что
число  будет примерно  вдвое меньше,  но для  точного ответа  нам надо
знать,  как именно (в  каком коде)  в нашем  компьютере представляются
отрицательные числа. Код этот  у разных компьютеров может быть разным,
но на  практике чаще  всего встречается так  называемый дополнительный
код. Попробую объяснить вам, что это такое.

</p><p>

Чтобы двоичные числа были покороче, а объяснять и понимать было проще,
давайте,  как  математики  любят  говорить "без  ограничения  общности
положим",  что  в  целом  числе  у  нас 4  бита.  Этого  будет  вполне
достаточно, чтобы понять закономерность.

</p><p>

Итак, работая с  беззнаковыми числами, мы можем в  эти 4 бита записать
числа от  0 до 15. Чтобы  перейти к знаковым числам,  нам прежде всего
надо  придумать,   как  мы  будем  указывать   знак  числа.   Придется
пожертвовать для этого одним битом  - выделим под знак "самый большой"
бит  -  тот, который  обозначает  беззнаковую  восьмерку. Кстати,  для
понятий  "самый  большой" и  "самый  маленький"  у программистов  есть
специальные термины  - most significant и least  significant. Итак, мы
выделили под знак MSb - most  significant bit. Этот бит так и называют
- знаковый бит или знаковый разряд.  Причем, если в этом бите 0, число
считается  положительным,  а  если  1 -  отрицательным.   Дальше  надо
придумать,  как  именно   записывать  значение  отрицательного  числа.
Казалось бы, если мы хотим  записать -2, проще всего взять значение 2,
и взвести в нем знаковый бит. К сожалению, не для компьютера. Смотрите
сами, что будет, если сложить в такой кодировке 2 и -2:

<div class="incode">
   &nbsp;&nbsp;&nbsp;2 	=	0010<br>
   +<br>
   &nbsp;&nbsp;-2	=	1010<br>
	-----------------------<br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1100&nbsp;&nbsp;- хотелось 
   0, а получили -4<br>
</div>

Для того,  чтобы избежать этой  неприятности, придумали дополнительный
код - в нем, чтобы сделать из положительного числа отрицательное, надо
сначала проинвертировать в нем все  биты (поменять 1 на 0 и наоборот),
а потом к полученному  результату добавить единичку. Попробуем сделать
из 2 -2 в дополнительном коде:

<div class="incode">
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 = 0010<br>
	инвертируем	1101<br>
	добавляем 1	1110 - это и есть -2 в дополнительном коде.<br>
</div>

Теперь со сложением все правильно:

<div class="incode">
   &nbsp;&nbsp;&nbsp;2 	=	0010<br>
   +<br>
   &nbsp;&nbsp;-2	=	1110<br>
	-----------------------<br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000<br>
</div>

На самом  деле, должно бы получиться,  10000, но поскольку  бита у нас
всего 4,  мы эту единицу потеряли.  

</p><p>

Между прочим, в этом  коде можно с
одинаковым  успехом  складывать  и  знаковые, и  беззнаковые  числа  -
результат останется правильным. Сложим, для примера, такие числа:

<div class="incode">
   &nbsp;&nbsp;&nbsp;2 	=	0001<br>
   +<br>
   &nbsp;&nbsp;-2	=	1000<br>
	-----------------------<br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1001<br>
</div>

Если мы считаем,  что числа у нас со  знаком, то мы сложили 1  и -8, и
получили  в результате  -7.  Если же  мы  хотим думать  о  них, как  о
беззнаковых, то и тут все правильно - 1+8=9.

</p><p>

Вот  теперь  можно  ответить  на  вопрос  о  самом  большом  (и  самом
маленьком) числе, разумеется, применительно к дополнительному коду.

</p><p>

На отрицательные  числа у нас  отведены 3 бита,  стало быть, в  них мы
можем записать числа от -8 до -1. При этом, если знаковый бит равен 0,
то в те же три бита  мы должны умещать не только натуральные числа, но
и 0. Так  что диапазон нашего 4-битового числа  -8..+7 - отрицательных
чисел в дополнительном коде всегда на одно больше, чем положительных.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="bitops"></a>
            Битовые операции</h2>
<p>

Ну вот, а  теперь перейдем к битовым операциям. Я  уже упоминал о том,
что байт - это минимальная самостоятельно адресуемая область памяти. В
частности,  отсюда  следует, что  отдельный  бит обработать  (взвести,
сбросить, проверить состояние)  нельзя - мы всегда будем  иметь дело с
группой минимум из  8 битов. А тем не  менее нередко хочется проверить
или изменить  только один бит  в переменной. Или обработать  байт так,
как будто это  набор из 8 независимых битовых  переменных. Вот как раз
для решения подобных задач и служат битовые операции. Их, в общем то,
совсем немного:

<div align="center">
<table width="70%">

 <tr><td>&amp;<br>&nbsp;</td>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>битовое И (bitwise AND)</td></tr>

 <tr><td>| (не восклицательный знак!)</td><td></td>
     <td>битовое ИЛИ (bitwise OR)</td></tr>

 <tr><td>^</td><td></td><td>битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (bitwise XOR)</td></tr>

 <tr><td>~ (тильда)</td><td></td><td>битовое дополнение (complement)<br>
			  то есть, инвертирование всех битов</td></tr>

 <tr><td>&gt;&gt;</td><td></td><td>сдвиг вправо (right shift)</td></tr>

 <tr><td>&lt;&lt;</td><td></td><td>сдвиг влево  (left shift)</td></tr>

</table>
</div>
</p>

Вдобавок к  этому, для всех  этих операторов, кроме  унарного битового
дополнения, есть гибриды с оператором присваивания:

<div class="incode">
	&amp;=&nbsp;&nbsp;|=&nbsp;&nbsp;^=&nbsp;&nbsp;&gt;&gt;=&nbsp;&nbsp;&lt;&lt;=
</div>

Давайте  теперь  смотреть, что  эти  операторы  делают.   Начнем мы  с
оператора  битового  дополнения  -   ~.   Просто  потому,  что  это  -
единственный из битовых унарынй оператор, то есть, он работает с одним
числом, а не с двумя. В  принципе, его название говорит само за себя -
он  просто   инвертирует  все  биты   своего  операнда.  То   есть  (в
предположении, что в нашем целом числе только 4 бита), проинвертировав
беззнаковое число 9, мы получим 6:

<div class="incode">
       &nbsp;9 = 1001<br>
       ~9 =	0110	= 6<br>
</div>

Напомню,  чтобы   уберечь  вас   от  частой  ошибки   начинающих,  что
проинвертировать  биты с  помощью унарного  минуса не  удается  даже в
дополнительном коде:

<div class="incode">
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-7 = 1001<br>
	-(-7)=7	= 0111<br>
</div>

А ведь к тому же не все копьютеры используют дополнительный код.

</p><p>

Теперь займемся бинарными операторами.

</p><p>

Логическая операция <em>AND</em> дает значение <em>TRUE</em>, 
если оба ее операнда равны
<em>TRUE</em>, и <em>FALSE</em>  во всех остальных случаях. 
В С за  <em>FALSE</em> считается 0, а
все ненулевое - <em>TRUE</em>. В случае отдельных битов, если бит очищен (равен
0),  он содержит  <em>FALSE</em>, если  взведен -  <em>TRUE</em>. 
А  битовый  оператор &
выполняет операцию <em>AND</em> над отдельными  битами - нулевой по счету бит с
нулевым, первый  с первым,  второй со вторым,  и так  далее. Например,
если мы выполним операцию 9 & 8, то в результате получим 8:

<div class="incode">
  &nbsp;&nbsp;9&nbsp;&nbsp;= 1001<br>
  &amp;<br>
  &nbsp;&nbsp;8&nbsp;&nbsp;= 1000<br>
  ---------------------<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000 = 8<br>
</div>


Этот оператор часто используется для проверки состояния индивидуальных
битов, или  для выделения из  переменной нужной группы битов.   Вот, к
примеру, еще один способ узнать, четное ли число - <em>i&nbsp;&1&nbsp;</em>. 
Если результат
ненулевой,   число   нечетное.    Похожим   способом   можно   узнать,
отрицательное у нас число в переменной или нет. Правда, для этого надо
знать, какой бит у переменной знаковый:

<div class="incode">
	negative = i & SIGNED_BIT;
</div>

Логическая операция  <em>OR</em> дает результат  <em>TRUE</em>, если 
ЛЮБОЙ  из операндов
имеет  значение  <em>TRUE</em>.  И  только  если оба  операнда  
<em>FALSE</em>,  мы и  в
результате  получим  <em>FALSE</em>.  Применительно  к  битовым  операциям  это
означает, что  оператор | взведет бит  результата, если соответсвующий
бит взведен  у любого  из операндов. И  только если у  обоих операндов
этот  бит  равен нулю,  он  будет равным  нулю  и  в результате.  Так,
например, 9&nbsp;|&nbsp;8 даст в результате 9:

<div class="incode">
  &nbsp;&nbsp;9&nbsp;&nbsp;= 1001<br>
  |<br>
  &nbsp;&nbsp;8&nbsp;&nbsp;= 1000<br>
  ---------------------<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1001 = 9<br>
</div>



Этот  оператор  незаменим тогда,  когда  вы  хотите  взвести один  или
несколько  битов,  не затрагивая  при  этом  остальных. 

</p><p>

Следующий в нашем  списке ^ - оператор исключающего  ИЛИ, XOR. Что это
за логическая  операция? Она  очень похожа на  обычное ИЛИ,  но только
если  оба операнда  равны TRUE,  она в  отличие от  обычного  ИЛИ даст
FALSE. Применительно к битам это  означает, что бит в результате будет
взведен   только  тогда,   когда   он  взведен   РОВНО   В  ОДНОМ   из
операндов. Так, например, 9^8 даст в результате 1:

<div class="incode">
  &nbsp;&nbsp;9&nbsp;&nbsp;= 1001<br>
  ^<br>
  &nbsp;&nbsp;8&nbsp;&nbsp;= 1000<br>
  ---------------------<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0001 = 1<br>
</div>

Нам      осталось      разобраться      с      операторами      сдвига
влево/вправо. Конструкция в коде программы выглядит примерно так:

<div class="incode">
	result = op1 &lt;&lt; 2;
</div>

или (что то же самое):

<div class="incode">
	op2=2;<br>
	result = op1 &lt;&lt; op2;<br>
</div>

Обе эти конструкции  сдвинут то, что содержится в  op1, на два разряда
влево.

</p><p>

Оператор сдвига влево работает следующим образом: - самые старший биты
(most  significant  bits), которые  оказались  выдвинутыми за  пределы
переменной, уходят в  небытие, на их место ставятся  предыдущие, и так
далее.  В те же биты, для которых понятия "предыдущий" нет (при сдвиге
на два разряда это - два самых младших бита), записываются нули.  Так,
например, 9<<2 дало бы нам в нашем 4-битовом целом ответ 4:

<div class="incode">
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 = 1001<br>
     9 &lt;&lt; 2 = 0100 = 4<br>
</div>

Что  касается оператора  сдвига вправо,  он работает  похожим образом,
только биты сдвигаются не из  младших разрядов в старшие, а из старших
в младшие. Правда, тут есть один нюанс. Язык С позволяет, хотя я еще и
не  объяснил   вам,  как  именно,   указывать,  со  знаковыми   или  с
беззнаковыми  числами   вы  работаете.   Так  вот,  если   работать  с
беззнаковыми числами, то сдвиг вправо  - полный аналог сдвига влево (с
поправкой на направление).  Так, сдвинув ту же девятку  на два разряда
вправо, вы получили бы вполне ожидаемую двойку:

<div class="incode">
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 = 1001<br>
     9 &gt;&gt; 2 = 0010 = 2<br>
</div>

Ситуация несколько иная, если вы  работаете со знаковыми числами - при
этом самый правый разряд (тот, который знаковый) будет содержать не 0,
а прежнее свое  содержимое. То есть, при сдвиге  вправо знаковое число
свой  знак  сохранит.  Этот  нюанс (лучше  сказать  "это  безобразие")
называется  "расширение  знакового   бита".   То  есть,  попытайся  мы
сдвинуть те же биты, что и прежде, как будто это знаковое число, мы бы
получили несколько иной результат:

<div class="incode">
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-7 = 1001<br>
     -7 &gt;&gt; 2 = 1110 = -2<br>
</div>

Ситуация  усугубляется еще  и  тем, что  такого "расширения  знакового
бита"  может  и  не   происходить  (в  зависимости  от  архитектуры  и
транслятора, с которыми  вы работаете) - стандарт языка  относит это к
"особенностям  реализации".  Так  что мой  вам совет  -  если придется
сдвигать  биты вправо, пользуйтесь  беззнаковыми числами  - там  все 
предсказуемо.   Или хотя  бы  не рассчитывайте  на  то, что  освободившиеся
старщие биты очистятся.


</p><p>

Последнее,  что  хотелось  бы  сказать  про  операторы  сдвига  -  они
рассчитаны на то, что вы  будете сдвигать переменную на число разрядов
МЕНЬШЕЕ,  чем в  ней  содержится. Так,  например,  если вы  попробуете
сдвинуть  целое число, в  котором 32  бита на  32 или  больше  разряда
влево/вправо,  вы  вместо  переменной,  равной  нулю,  можете  увидеть
сообщение вроде такого

<div class="incode">
	warning: left shift count &gt;= width of type
</div>

а в переменной результата окажется неизмененный левый операнд.

</p><p>

Ну, про гибриды  с присваиванием я даже говорить ничего  не буду - они
по   смыслу   ничем  не   отличаются   от   гибридов  присваивания   с
арифметическими    операциями,    только    операции   выполняют    не
арифметические,  а  битовые.

</p><p>

Зачем нужны все эти операции  битовой логики? Казалось бы, в расчетной
задаче  их  нечасто встретишь.  В  расчетной -  да.   Но  напомню -  С
изначально  задумывался  как  язык,   близкий  и  понятный  не  только
человеку,  но  и  компьютеру.   На  нем  операционные  системы  пишут,
оборудование  программируют. А если  вы работаете  с "железом",  у вас
очень  и очень  часто возникает  необходимость  проверить какой-нибудь
битик в регистре,  или взвести его, не трогая  остальных, или выделить
из слова интересующий вас набор битов.  Есть, конечно, в С для этого и
другие   средства,  но   зачастую  именно   операции   битовой  логики
оказываются самыми удобными.

</p><p>

Ну  что  же, будем  считать,  с  операторами  битовой логики  мы  тоже
разобрались.

</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="sizeof"></a>Оператор sizeof</h2>
<p>

Прежде чем закончить  сегодняшнее занятие, хочу рассказать вам еще
об одном  весьма полезном  операторе.  Я вот  только что  заметил, что
нехорошо  сдвигать 32-битное  число  на 32  разряда  - можно  получить
неожиданный результат.  А  можно ли из программы узнать,  какого у нас
размера переменная или тип данных? Оказывается, можно - для этого есть
прекрасный оператор  <em>sizeof()</em> (по использованию он  похож на функцию).
Он возвращает количество байтов,  которое занимает его операнд, причем
в качестве  операнда можно  использовать и переменную,  и имя  типа, и
даже выражение. Так, если мы в нашу тестовую программку поставим:

<div class="incode">
	op2=sizeof(op1);<br>
	op3=sizeof(int);<br>
 	result=sizeof(7+op1);<br>
</div>

то получим следующую строчку:

<div class="session">
	sizeof(), op1=0, op2=4, op3=4, result=4
</div>

что означает, что мы с вами имеем дело с 4-байтовыми целыми числами.

</p><p>

Ну вот, давайте на этом сегодняшнее занятие и закончим.


</p>
    </td>
  </tr>
</table>

</div>
</body>
</html>

 