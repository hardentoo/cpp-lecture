<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
  <meta name="Author" content="Владимир Ольшевский">
  <title>C++, part 2, lesson 6</title>
  <link rel="stylesheet" href="../styles/lectures.css" type="text/css">

</head>

<body bgcolor="#ffffff">

<div align="center">
<table width="700" cols=1 border=0>
   <tr>
      <td>
	<h1 align="center">
	 <a href="../c++course.1">C++</a>
	</h1>
        <h3 align="center">часть 2, занятие 6</h3>
        <div align="center"> Владимир Ольшевский </div>
      </td>
   </tr>
</table>
<br><br><br>
<table width="50%" border="0" cellspacing="1" cellpadding="3" align="Center">
  <caption>В этой лекции</caption>
  <tr>
    <td>
      <ul>
        <li>Перегружаемые операторы
	  <ul>
	    <li><a href="p2-6.html#op-incdec">Перегрузка инкремента ++ и декремента --
	        </a>
	    <li><a href="p2-6.html#op-assign">Операторы группы присваивания
	        </a>
	    <li><a href="p2-6.html#op-array">Оператор выбора элемента массива []
	        </a>
	    <li><a href="p2-6.html#op-ptr">Перегрузка -> и унарных *, &
	        </a>
	  </ul>
        <li>Наследование</li>
	  <ul>
	    <li><a href="p2-6.html#inh">Основная идея</a>
	        </a>
	    <li><a href="p2-6.html#inh-baseaccess">Уровни доступа к базовому классу
	        </a>
	    <li><a href="p2-6.html#inh-dupnames">Одноименные поля в производном и базовых 
	         классах
	        </a>
	    <li><a href="p2-6.html#inh-virtfun">Виртуальные функции</a>
	        </a>
	    <li><a href="p2-6.html#inh-abstr">Абстрактные классы. 
	           Чистые виртуальные функции.
	        </a>
	  </ul>
      </ul>
    </td>
  </tr>
</table>

<hr align="center" width="50%">
<h1 align="center">Перегружаемые операторы</h1>
<br>
   <table width="700" border="0" cellspacing="0" cellpadding="0">
      <tr>
         <td align="justify">
            <h2><a name="op-incdec"></a>Перегрузка инкремента ++ и декремента --
	    </h2>

<p>
По сравнению с другими операторами у этих есть особенность - вы можете
использовать их как в префиксной (++i, --i), так и в постфиксной (i++,
i--) нотации. В первом случае оператор возвращает значение операнда до
изменения, во втором - после:
<div class="code">
           int i, j;<br>
	   <br>
           j=0; i=++j;  // i==1, j==1<br>
	   <br>
           j=0; i=j++;  // i==0, j==1<br>
</div>

Поскольку операторы  эти унарные, то они должны  были бы перегружаться
либо  в виде член-функций  без аргументов,  либо в  виде дружественных
функций  с двумя  аргументами. Так  и было  на старых  трансляторах, и
перегружать  можно было  только префиксную  форму. Но  затем  для этих
операторов сделали исключение -  каждый из них может перегружаться еще
и  функцией  с  дополнительным  аргументом  типа int,  и  эта  функция
соответствует  постфиксной нотации.  В качестве  примера  ниже приведен
класс Int, в  котором  перегружены все  четыре возможных оператора 
инкремента и декремента:

<div class="code">
          class Int {<br>
          public:<br>
          &nbsp;&nbsp;Int(int val) : v(val) {};<br>
          &nbsp;&nbsp;int v;<br>
	    <br>
          &nbsp;&nbsp;// prefix ++ as member-function<br>
          &nbsp;&nbsp;int operator++() { return ++v; }<br>
	    <br>
          &nbsp;&nbsp;// postfix ++ as member-function<br>
          &nbsp;&nbsp;int operator++(int) { return v++; }<br>
	    <br>
	  &nbsp;&nbsp;// Conversion Int -> int <br>
          &nbsp;&nbsp;operator int() { return v; }<br>
	  <br>
          &nbsp;&nbsp;// prefix -- as friend<br>
          &nbsp;&nbsp;friend int operator--(Int& obj);<br>
	  <br>
          &nbsp;&nbsp;// postfix -- as friend<br>
          &nbsp;&nbsp;friend int operator--(Int& obj,int);<br>
	  <br>
          };<br>
	  <br>
	  // Prefix -- implementation<br>
          int operator--(Int& obj) {<br>
          &nbsp;&nbsp;return --obj.v;<br>
          }<br>
	  <br>
	  // Postfix -- implementation<br>
          int operator--(Int& obj, int) {<br>
          &nbsp;&nbsp;return obj.v--;<br>
          }<br>
</div>
Написав короткую программу, можно проверить, как этот класс работает:
<div class="code">	  
          #include &lt;iostream&gt;<br>
	  using namespace std;<br>
	  <br>
	  class Int {<br>
	  &nbsp;&nbsp;...<br>
	  };<br>
	  <br>
          main() {<br>
          &nbsp;&nbsp;Int a=0, b=0, c=0, d=0;<br>
          &nbsp;&nbsp;int plpr, plpo, mipr, mipo;<br>
	  <br>
          &nbsp;&nbsp;plpr=++a; plpo=b++;<br>
          &nbsp;&nbsp;mipr=--c; mipo=d--;<br>
	  <br>
          <br>
          &nbsp;&nbsp;cout &lt;&lt; "Prefix  plus  (return, value): "<br> 
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; plpr &lt;&lt; 
	       " " &lt;&lt; a &lt;&lt; endl; <br>
          &nbsp;&nbsp;cout &lt;&lt; "Postfix  plus  (return, value): "<br> 
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; plpo &lt;&lt; 
	       " " &lt;&lt; a &lt;&lt; endl; <br>
          &nbsp;&nbsp;cout &lt;&lt; "Prefix  minus  (return, value): "<br> 
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mipr &lt;&lt; 
	       " " &lt;&lt; a &lt;&lt; endl; <br>
          &nbsp;&nbsp;cout &lt;&lt; "Postfix  minus  (return, value): "<br> 
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; mipo &lt;&lt; 
	       " " &lt;&lt; a &lt;&lt; endl; <br>
	  }
</div>
Собрав и запустив подобную программу, вы должны увидеть следуюшее
<div class="session">
     Prefix  plus  (return, value): 1 1<br>
     Postfix plus  (return, value): 0 1<br>
     Prefix  minus (return, value): -1 -1<br>
     Postfix minus (return, value): 0 -1<br>
</div>
Как  видите,  результаты  действительно  разные  -  для  префиксной  и
постфиксной форм вызываются различные функции. Обратите внимание еще и
на то, что в дружественных функциях аргумент передается по ссылке. 
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="op-assign"></a>Операторы группы присваивания</h2>
<p>
Рассмотрим их  на примере оператора +=.  По большому счету,  в них нет
ничего специфического
<div class="code">
            #include &lt;iostream&gt;<br>
	    <br>
            class A {<br>
            &nbsp;&nbsp;int v;<br>
            public:<br>
            &nbsp;&nbsp;A(int val=0) : v(val) {};<br>
	    <br>
            &nbsp;&nbsp;A& operator+=(int val) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; " member += called\n";<br>
            &nbsp;&nbsp;&nbsp;&nbsp;v+=val; return *this; <br>
            &nbsp;&nbsp;}<br>
	    <br>
	    &nbsp;&nbsp;friend A& operator+=(A& obj, double val);<br>
	    <br>
	    };<br>
	    <br>
	    A& operator+=(A& obj, double val) {<br>
            &nbsp;&nbsp;cerr &lt;&lt; " friend += called\n";<br>
            &nbsp;&nbsp;return obj+=int(val);<br>
	    }<br>
	    <br>
	    main() {<br>
            &nbsp;&nbsp;A a,b;<br>
            &nbsp;&nbsp;a+=1;<br>
            &nbsp;&nbsp;b+=2.5;<br>
            }<br>
</div>
Часто, чтобы  поменьше дублировать код,  операторы группы присваивания
(op=)  пишут  на основе  соответсвующих  бинарных операций.  Например,
оператор  += можно  было бы  переписать  на основе  оператора +  таким
образом:
<div class="code">
         class A {<br>
         &nbsp;&nbsp;int v;<br>
         public:<br>
         &nbsp;&nbsp;A(int val=0) : v(val) {};<br>
	 <br>
         &nbsp;&nbsp;A operator+(int val) {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;A temp(v+val);<br>
         &nbsp;&nbsp;&nbsp;&nbsp;return A;<br>
         &nbsp;&nbsp;}<br>
	 <br>
         &nbsp;&nbsp;A& operator+=(int val) {<br>
         &nbsp;&nbsp;&nbsp;&nbsp;*this = *this + val;<br>
         &nbsp;&nbsp;&nbsp;&nbsp;return *this; <br>
         &nbsp;&nbsp;}<br>
         };<br>
</div>
Я советую вам поступать именно так. Во-первых, кода при таком подходе приходится 
писать меньше, и во-вторых, вы при этом закладываете в операторы для своего типа 
ту самую эквивалентность, к которой программисты привыкли при работе со 
встроенными типами. К тому же вы страхуетесь от ошибки, когда изменив один из 
операторов, забывают о другом. (Согласитесь, довольно странно,
когда выражения a+=1 и a=a+1 дают разный результат.)
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="op-array"></a>Оператор выбора элемента массива []</h2>
<p>
Оператор []  можно определять только в виде  функции-члена класса, это
гарантирует, что левый операнд будет представителем класса.

<div class="code">
             class A {<br>
             &nbsp;&nbsp;int v[10];<br>
             public:<br>
             &nbsp;&nbsp;int& opeartor[](int index) {<br>
	     &nbsp;&nbsp;&nbsp;&nbsp;return v[index];<br> 
	     &nbsp;&nbsp;}<br>
             };<br>
	     <br>
             main() {<br>
             &nbsp;&nbsp;A a;<br>
             &nbsp;&nbsp;a[5] = 5;<br>
             &nbsp;&nbsp;cerr &lt;&lt; a[5] &lt;&lt; endl;<br>
             }<br>
</div>

Как видите,  этот оператор должен возвращать результат  по ссылке. Это
достаточно очевидно,  ведь его результат  (возвращенный элемент) может
использоваться  как  левое значение  (например,  в  программе выше  мы
написали  a[5]=5;  ), а  это  невозможно  при  возврате результата  по
значению.
</p><p>
Приятная особенность этого оператора - в качестве индекса в массиве вы
можете использовать любой тип, например, строку. Именно так и устроены
ассоциативные массивы (массивы, в качестве индекса в которых
используется не целочисленное значение).
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="op-ptr"></a>Перегрузка -> и унарных *, &</h2>
<p>
Я даже не буду приводить примеры перегрузки таких операторов, а просто
намекну, для чего это делается.
</p><p>
Первые два оператора - это  доступ к объекту через указатель. Третий -
оператор  взятия адреса.  Эти  операторы помогают,  когда в  программе
требуются  так называемые  "умные указатели"  (smart  pointers). Такие
указатели внешне  в конструкциях  программы выглядят, как  обычные (их
можно инкрементировать и декрементировать, можно проверять значение на
допустимость), но  при этом их внутренняя  начинка позволяет выполнять
некую дополнительную  работу - ту,  которую в них  заложил разработчик
класса. Например, если у  вас есть объект, содержащий массив текстовых
строк, то  умный указатель  по оператору ++  может вместо  перехода на
следующую строку  в массиве перейти на следующую  в алфавитном порядке
строку.  Кстати,  именно   так - с помощью умных указателей -  реализованы  
итераторы  в  стандартной библиотеке шаблонов.
</p>
    </td>
  </tr>
</table>

<br><br><br>
<hr align="center" width="50%">
<h1 align="center">Наследование</h1>
<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="inh"></a>Основная идея</h2>
<p>
Вы уже довольно  много знаете об объектно-ориентированных возможностях
С++. Классы в С++ содержат не только данные, но и функции для работы с
ними. Конструкторы и перегружаемые операторы дают возможность работать
с классом примерно так же,  как со встроенным типом данных, исключения
предоставляют довольно логичное и единообразное средство для обработки
ошибок.     Еще     одно     важное    свойство,     присущее     всем
объектно-ориентированным языкам - наследование. Сама суть наследования
проста - некий класс, допустим, child, может объявить себя наследником
другого класса,  скажем, parent. В этом случае  child принято называть
производным классом,  а parent -  базовым. При этом  производный класс
унаследует  от своего  базового класса  все  поля данных  и почти  все
методы. Такой механизм весьма полезен сразу в нескольких смыслах:
</p><p>
Во-первых,  он дает  возможность расширять  функциональность имеющихся
классов без  дублирования кода.  Если  вам понадобилось еще  одно поле
данных  или новый  метод, вам  не  надо ни  изменять уже  существующий
класс,  ни копировать  все  его определение,  создавая  новый класс  с
другим именем.  Достаточно  определить класс-наследник уже имеющегося,
добавив в него новые поля и функции.
</p><p>
Во вторых,  при таком подходе  отсутсвует риск порушить  уже имеющиеся
программы, которые использовали базовый класс. В самом деле, поскольку
вы создаете  новый класс, никак не затрагивая  начинку уже имеющегося,
то для таких программ ничего не меняется.
</p><p>
В  третьих,  это  позволяет  работать  со  всеми  наследниками  одного
базового класса  одинаковым образом (разумеется, до тех  пор, пока вас
не интересуют  их специфические  расширения.  В самом  деле, поскольку
каждый класс-наследник несет в  себе функциональность базового, то все
они  будут содержать  поля  и "отзываться"  на  методы этого  базового
класса.   Или,  как  принято  говорить, будут  поддерживать  интерфейс
базового  класса,  точнее, любого  из  своих  базовых классов.   Такое
свойство,  когда объекты  класса  ведут себя  по  разному в  различных
условиях, называют полиморфизмом.
</p><p>
Теперь  давайте посмотрим  на  примерах, как  наследование выглядит  в
программе  на  С++. В  качестве  иллюстрации  для  этого очень  удобно
работать  с графическими  изображениями, так  что мы  сейчас попробуем
разработать некую весьма ограниченную по возможностям, но полезную для
понимания механизмов наследования, графическую библиотеку.
</p><p>
Для начала  напишем класс,  каждый объект которого  представляет собой
точку на экране.
<div class="code">
      class Point {<br>
      public:<br>
      &nbsp;&nbsp;int x,y;<br>
      &nbsp;&nbsp;Point(int _x, int _y) : x(_x), y(_y) {};<br>
      &nbsp;&nbsp;void show() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// рисуем точку (x,y)<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;void hide() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// стираем точку (x,y)<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;void move(int new_x, new_y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// перемещаем из (x,y) в (new_x, new_y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;hide();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x=new_x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y=new_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;show();<br>
      &nbsp;&nbsp;}<br>
      };<br>
</div>
Как  видите,  каждый объект  такого  класса  -  точка с  координатами,
которую можно "показать" (метод  show), спрятать (метод hide) и задать
ей новые координаты, "передвинуть" (метод move).
</p><p>
Так, например,  в программе, можно нарисовать точку,  а затем изменить
ее положение на экране:
<div class="code">
       Point p(0,0);<br>
       p.show();<br>
       p.move(100,100);<br>
</div>
В  этом   классе  отсутствуют  методы,  которые   позволяли  бы  узнать
координаты точки. Правда, поля x  и y размещены в public-секции класса
и  поэтому доступны  напрямую, но  этот  недочеи мы  со временем  тоже
исправим. А сейчас давайте  с помощью наследования добавим недостающие
функции получения координат x и y.
<div class="code">
        class Point1 : public Point <br>
        {<br>
        public:<br>
        &nbsp;&nbsp;Point1(int _x, int _y) : Point(_x,_y) {};<br>
	<br>
        &nbsp;&nbsp;int get_x() { return x; }<br>
        &nbsp;&nbsp;int get_y() { return y; }<br>
        };<br>
</div>
Вот, собственно,  и все - работа сделана.  Теперь давайте разбираться,
что же мы тут написали.
</p><p>
Прежде всего, в первой строке
<div class="code">
        class Point1 : public Point 
</div>
мы   объявляем,   что  класс   Point1   является  наследником   класса
Point. Причем перед классом  Point стоит ключевое слово public. Всесто
public можно  было также указать  protected или private.  Эти ключевые
слова влияют  на то,  на каком уровне  доступа окажутся поля  данных и
методы базового класса в нашем новом, производном классе.
</p><p>
Затем,  в   самом  определении  класса,  в  секции   public  мы  видим
конструктор
<div class="code">
          Point1(int _x, int _y) : Point(_x,_y) {};
</div>
Обратите  внимание, в списке  инициализации конструктора  Point1 стоит
имя  базового класса,  как  если  бы новый  класс  содержал базовый  в
качестве поля данных (по сути, так оно и есть, новый класс - это Point
и еще что-то).
</p><p>
Конструктор  для  нового  класса,  пусть  и  несложный,  нам  пришлось
написать, никакое наследование не  помогло - в самом деле, конструктор
ведь  должен уметь  правильно создавать  объект своего  типа,  так что
никаие конструкторы других классов для этой цели не годятся.
</p><p>
Следом,  также в  общедоступной  секции, стоят  те  две функции,  ради
которых мы новый класс и определяли:
<div class="code">
          int get_x() { return x; }<br>
          int get_y() { return y; }<br>
</div>
Замечательно то,  что мы пользуемся полями  x и y в  новом классе, как
своими собственными  - они унаследованы из базового  класса. Точно так
же унаследованы и все три метода  базового класса - show, hide и move.
Так что код рисования и перемещения точки
<div class="code">
       Point1 p(0,0);<br>
       p.show();<br>
       p.move(100,100);<br>
</div>
по прежнему  будет работать (мы в  енм заменили только тип  с Point на
Point1), но в дополнение к этому мы теперь можем, написав
<div class="code">
         int x = p.get_x();<br>
         int y = p.get_y();<br>
</div>
получить координаты точки p.
</p><p>
Мы вполне можем продолжить  этот процесс - написать класс, производный
уже от Point1.
<div class="code">
       class Point2 : public Point1 <br>
       {<br>
       public:<br>
       &nbsp;&nbsp;Point2(int _x, int _y) : Point1(_x,_y) {};<br>
       &nbsp;&nbsp;void set_x(int new_x) { x = new_x; }<br>
       &nbsp;&nbsp;void set_y(int new_y) { y = new_x; }<br>
       };<br>
</div>
Естественно, при необходимости в новый класс можно добавлять не только
функции, но и поля данных.
</p><p>
Обратите внимание, последний класс является наследником класса Point1,
а тот в  свою очередь - наследник Point. В  таких случаях говорят, что
Poiint1 -  непосредственный базовый класс для Point2  (direct base), а
Point - косвенный базовый (indirect base).
</p><p>
В С++  у производного класса может  быть несколько базовых  - при этом
такой   объект   будет  наследовать   признаки   всех  своих   базовых
классов.  Например,   если  мы  захотим  объединить   точки  в  список
(например, для  рисования фигур), то такие  объекты вполне естественно
наделить еще и свойствами элементов списка:
<div class="code">
         class LinkedPoint <br>
	 &nbsp;&nbsp;: public Point, public LinkedListItem<br> 
	 {<br>
         &nbsp;&nbsp;...<br>
         };<br>
</div>
Определение базового класса LinkedListItem в данном случае осталось за
кадром,  но ясно,  что  в нем  должны  содержаться поля  и методы  для
объединения элементов в связный список.
</p>
    </td>
  </tr>
</table>

<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="inh-baseaccess"></a>Уровни доступа к базовому классу</h2>
<p>
Теперь давайте  попробуем разобраться, что же  означает ключевое слово
public  (а  также  и   другие  уровни  защиты  -  protected,  private)
применительно  к базовому  классу.  А заодно  исправим недочет  класса
Point, убрав поля x и y из общедоступной секции.
</p><p>
Определение самого первого класса выглядело следующим образом
<div class="code">
      class Point {<br>
      public:<br>
      &nbsp;&nbsp;int x,y;<br>
      &nbsp;&nbsp;...<br>
      };<br>
</div>
По канонам объектно-ориентированного  языка делать общедоступными поля
данных нехорошо.  Однако, если мы  попытаемся разместить x,y  в личной
секции
<div class="code">
      class Point {<br>
      private:<br>
      &nbsp;&nbsp;int x,y;<br>
      public:<br>
      &nbsp;&nbsp;...<br>
      };<br>
</div>
а потом определить производный класс
<div class="code">
      class Point1 : public Point {<br>
      public:<br>
      &nbsp;&nbsp;...<br>
      &nbsp;&nbsp;int get_x()  { return x; }<br>
      &nbsp;&nbsp;int get_y()  { return y; }<br>
      };<br>
</div>
то транслятор выдаст сообщение об  ошибке - нет доступа к личным полям
x и y.
</p><p>
Личные  есть  личные   -  никто  кроме  самого  класса   Point  и  его
friend-функций не  имеет права  их трогать.  Если  же мы  хотим, чтобы
поля  были недоступны внешнему  миру, но  при этом  производные классы
все-таки  могли ими  пользоваться,  в классе  Point надо  использовать
другое ключевое слово - protected (защищенные).
<div class="code">
      class Point {<br>
      protected:<br>
      &nbsp;&nbsp;int x,y;<br>
      public:<br>
      &nbsp;&nbsp;...<br>
      };<br>
</div>
Теперь класс-наследник сможет работать с x и y напрямую.
</p><p>
Однако будут  ли доступны эти поля следующему  классу, производному не
от Point, а от Point1? Это  как раз и определяется тем, какое ключевое
слово вы поставили перед указанием базового класса.
</p><p>
Когда мы пишем
<div class="code">
      class Point1 : public Point
</div>
то  уровни защиты  базовых полей  и  методов в  производном классе  не
меняются -  protected-члены класса Point  становятся protected-членами
Point1, а public-члены так и остаются общедоступными.
</p><p>
Если бы мы написали
<div class="code">
     class Point1 : private Point
</div>
то  все  члены  класса  Point  стали  бы  личными  членами  Point1.  В
частности,  мы  в программе  могли  бы  пользоваться только  функциями
get_x, get_y, а функции show, hide, move стали бы недоступными.
</p><p>
Третий вариант
<div class="code">
     class Point1 : protected Point
</div>
усиливает  защиту  на  одну  ступеньку, превращая  защищенные  поля  в
личные, а общедоступные делая защищенными.
</p><p>
Какой  именно уровень  защиты приписать  базовому  классу, определяет,
исходя из своих нужд, разработчик производного класса.
</p>
    </td>
  </tr>
</table>


<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="inh-dupnames"></a>Одноименные поля в производном и базовых 
	         классах</h2>
<p>
Итак, в классе Point у нас  были поля x, y, которые мы использовали во
всех  производных классах.  А  что бы  случилось,  если в  производном
классе мы бы определили свои поля с такими же именами?
<div class="code">
       class Point {<br>
       public:<br>
       &nbsp;&nbsp;int x, y;<br>
       &nbsp;&nbsp;...<br>
       };<br>
       <br>
       class OtherPoint : public Point {<br>
       public:<br>
       &nbsp;&nbsp;int x, y;<br>
       &nbsp;&nbsp;void set_x(int _x) { x=_x; }<br>
       };<br>
</div>
В  такой ситуации  методы  производного класса  стали  бы работать  со
своими полями, а не с полями базового класса. Однако при необходимости
мы смогли бы добраться и до базовых полей. Вот как бы это выглядело в 
производном классе
<div class="code">
       class OtherPoint : public Point {<br>
       public:<br>
       &nbsp;&nbsp;int x, y;<br>
       &nbsp;&nbsp;void set_x(int _x) { x=_x; }<br>
       &nbsp;&nbsp;void set_base_x(int _x) { Point::x=_x; }<br>
       };<br>
</div>
и в самой программе, содержащей объект OtherPoint:
<div class="code">
      OtherPoint p;<br>
      <br>
      // меняем поле OtherPoint::x<br>
      p.x = 1; <br>
      <br>
      // меняем базовое поле Point::x<br>
      p.Point::x = 1; <br>
</div>
Как видите,  по умолчанию работа  идет со "своими" полями,  но, указав
перед  именем поля  имя  базового  класса, вы  можете  добраться и  до
унаследованных полей.
</p>
    </td>
  </tr>
</table>


<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="inh-virtfun"></a>Виртуальные функции</h2>
<p>
С  полями  данных  мы  более  или менее  разобрались.  Давайте  теперь
посмотрим, как ведут себя наследуемые функции.
</p><p>
Прежде   всего,   мы  можем   в   производном  классе   переопределить
унаследованный   метод  -   написать   другую  функцию   с  такой   же
сигнатурой. При  этом ситуация будет  такая же, как  с унаследованными
полями -  по умолчанию  вызываться будет функция  производного класса,
но,  указав явно  имя базы,  вы  сможете добраться  и до  оригинальной
унаследованной функции:
<div class="code">
          class Point {<br>
          public:<br>
          &nbsp;&nbsp;...<br>
          &nbsp;&nbsp;void show() { ... };<br>
          &nbsp;&nbsp;...<br>
          };<br>
	  <br>
          class OtherPoint : public Point {<br>
          public:<br>
          &nbsp;&nbsp;...<br>
          &nbsp;&nbsp;void show() { <br>
          &nbsp;&nbsp;&nbsp;&nbsp;// Замена для базовой show()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;...<br>
          &nbsp;&nbsp;&nbsp;&nbsp;// вызов базовой show()<br>
          &nbsp;&nbsp;&nbsp;&nbsp;Point::show();<br>
          &nbsp;&nbsp;}<br>
          };<br>
</div>
Но  это  еще  не  самое  интересное.  Гораздо  интереснее  и  полезнее
разобраться с вопросом, как функции ссылаются друг на друга.
</p><p>            
Напомню полное определение класса Point (оно нам сейчас понадобится):
<div class="code">
      class Point {<br>
      public:<br>
      &nbsp;&nbsp;int x,y;<br>
      &nbsp;&nbsp;Point(int _x, int _y) : x(_x), y(_y) {};<br>
      &nbsp;&nbsp;void show() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// рисуем точку (x,y)<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;void hide() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// стираем точку (x,y)<br>
      &nbsp;&nbsp;}<br>
      &nbsp;&nbsp;void move(int new_x, new_y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// перемещаем из (x,y) в (new_x, new_y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;hide();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x=new_x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y=new_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;show();<br>
      &nbsp;&nbsp;}<br>
      };<br>
</div>
Теперь  представьте,  что вам  нужно  написать  класс, который  рисует
окружность.  Что  при этом  мы  можем  унаследовать  от класса  Point?
Координаты  точки  можем. А  вот  функции  нам  придется переписать  -
окружность и рисовать, и стирать надо по другому:
<div class="code">
     class Circle : public Point<br>
     protected:<br>
     &nbsp;&nbsp;int r; <br>
     public:<br>
     &nbsp;&nbsp;Circle(int _x, int _y, int _r) <br>
     &nbsp;&nbsp;&nbsp;&nbsp;: r(_r), Point(_x,_y)<br> 
     &nbsp;&nbsp;{};<br>
     <br>
     &nbsp;&nbsp;void show() {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;// Вариант show для окружности<br>
     &nbsp;&nbsp;}<br>
     &nbsp;&nbsp;void hide() {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;// Вариант hide для окружности<br>
     &nbsp;&nbsp;}<br>
     &nbsp;&nbsp;void move(int new_x, int new_y) {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;hide();<br>
     &nbsp;&nbsp;&nbsp;&nbsp;x = new_x;<br>
     &nbsp;&nbsp;&nbsp;&nbsp;y = new_y;<br>
     &nbsp;&nbsp;&nbsp;&nbsp;show();<br>
     &nbsp;&nbsp;}<br>
     };<br>
</div>
С  функциями  show  и  hide  никуда  не  деться  -  рисуем  не  точку,
окружность. Но обратите  внимание на move - в ней  точно такой же код,
как и  в функции  Point::move.  Однако нам  пришлось переписать  и ее.
Если  бы мы  воспользовались наследуемоей  функцией, она  бы, конечно,
вызвала  hide   и  show   -  но  только   не  новые,  а   из  базового
класса. Соответсвующие вызовы были вставлены в тело Point::move еще на
этапе компиляции - это называется ранним связыванием (early binding).
</p><p>
А нельзя ли  все-таки сделать так, чтобы мы  работали с унаследованной
функцией move,  но она  при этом определяла  в момент вызова,  с каким
именно  классом  работает,  и  вызывала правильные  варианты  функций?
Оказывается, можно. Для этого  надо всего-навсего сделать функции show
и hide виртуальными, поставив в определении базового класса перед ними
ключевое слово virtual:
<div class="code">
      class Point {<br>
      public:<br>
      &nbsp;&nbsp;int x,y;<br>
      &nbsp;&nbsp;Point(int _x, int _y) : x(_x), y(_y) {};<br>
      <br>
      &nbsp;&nbsp;virtual void show() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// рисуем точку (x,y)<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;virtual void hide() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// стираем точку (x,y)<br>
      &nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;void move(int new_x, new_y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// перемещаем из (x,y) в (new_x, new_y)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;hide();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;x=new_x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;y=new_y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;show();<br>
      &nbsp;&nbsp;}<br>
      };<br>
</div>
Теперь мы можем не повторять  код функции move в производном классе, а
воспользоваться наследуемой:
<div class="code">
     class Circle : public Point<br>
     protected:<br>
     &nbsp;&nbsp;int r;<br>
     public:<br>
     &nbsp;&nbsp;Circle(int _x, int _y, int _r)<br>
     &nbsp;&nbsp;&nbsp;&nbsp;: r(_r), Point(_x,_y)<br> 
     &nbsp;&nbsp;{};<br>
     <br>
     &nbsp;&nbsp;void show() {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;// Вариант show для окружности<br>
     &nbsp;&nbsp;}<br>
     &nbsp;&nbsp;void hide() {<br>
     &nbsp;&nbsp;&nbsp;&nbsp;// Вариант hide для окружности<br>
     &nbsp;&nbsp;}<br>
     };<br>
</div>
Теперь, если где-нибудь в программе мы напишем
<div class="code">
     Circle c(10,10);<br>
     Point p(20,20);<br>
     c.move(50,50);<br>
     p.move(70,70);<br>
</div>
то   и   в  третьей,   и   в   четвертой   строке  сработает   функция
Point::move. Однако  благодаря ключевому  слову virtual она  в третьей
строке  вызовет   Circle::show  и   Circle::hide,  а  в   четвертой  -
Point::show  и Point::hide.   Это  замечательное свойство  - во  время
выполнения программы определять, функцию  из какого именно класса надо
использовать - называется поздним связыванием (late binding).
</p><p>
Благодаря виртуальным функциям объекты получают еще одно замечательное
качество.  Вы  ведь  можете  работать  не  с  самими  объектами,  а  с
указателями  или ссылками  на  них.  А по  правилам  языка ссылка  или
указатель  на базовый  тип  совместима со  ссылкой  или указателем  на
производный.  То  есть,  работая   с  указателями,  вы  вполне  можете
написать, например, такой цикл:
<div class="code">
      Point *a[2];<br>
      Circle c;<br>
      Point p;<br>
      a[0] = &c;<br>
      a[1] = &p;<br>
      <br>
      for (int i=0; i&lt;2; i++)<br>
      &nbsp;&nbsp;a[i]->show();<br>
</div>
и  не  задумываться о  том,  на  какой  именно тип  объекта  указывает
конкретный  элемент  массива  -   благодаря  тому,  что  функция  show
объявлена  виртуальной, для  точки  будет вызвана  Point::show, а  для
окружности - Circle::show. 
</p><p>
Это и есть <em>полиморфизм</em> - способность объекта 
вести себя по разному в зависимости от того, как им пользуются. Если с 
ним работают через ссылку или указатель на базовый класс, то он и ведет 
себя как базовый (разумеется, объект Circle рисовать будет окружность, 
а не точку, но по <em>интерфейсу</em>, то есть, по набору доступных 
полей и методов, это будет именно объект базового класса. 
</p>
    </td>
  </tr>
</table>


<br>

<table width="700" border="0" cellspacing="0" cellpadding="0">
   <tr>
      <td align="justify">
         <h2><a name="inh-abstr"></a>Абстрактные классы. 
	      Чистые виртуальные функции.
	 </h2>
<p>
Сейчас наша сеть наследования выглядит  так - базовый класс Point, его
производный  класс -  Circle.  Можно  расширить эту  сеть  - например,
написать еще производных от Point  классов - Rectangle, Polygon, и так
далее. Однако такая схема наследования  не совсем логична. Point - это
уже  некий реальный  объект, который  помимо свойств,  характерных для
всех фигур  (в нашем утрированном  примере это координаты x,y  и метод
move) содержит  еще и  специфические только для  своего типа  детали -
методы show  и hide. Гораздо  логичнее выделить все общее  в отдельный
класс, например,  в класс Figure, а специфичные  для конкретной фигуры
детали определять непосредственно в производных классах.
</p><p>
Ну, с координатами при таком подходе проблем нет. Но нам надо внести в
базовый класс метод move, который вызывает  show и hide. А show и hide
уже относятся к тем самым специфическим особенностям, которые мы хотим
удалить из базового класса. Решить  эту проблему в С++ помогают чистые
виртуальные  функции  (pure  virtual  functions).  Вот  как  могло  бы
выглядеть соотвесвующее определение базового класса:
<div class="code">
          class Figure {<br>
          protected:<br>
          &nbsp;&nbsp;int x, y;<br>
          public:<br>
          &nbsp;&nbsp;Figure(int _x, int _y) : x(_x), y(_y) {};<br>
	  <br>
          &nbsp;&nbsp;void move(int new_x, int new_y) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;hide();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;x = new_x; <br>
          &nbsp;&nbsp;&nbsp;&nbsp;y = new_y;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;show();<br>
          &nbsp;&nbsp;};<br>
	  <br>
          &nbsp;&nbsp;virtual void show() = 0;<br>
          &nbsp;&nbsp;virtual void hide() = 0;<br>
          };<br>
</div>
Обратите внимание, как записаны в определении класса show и hide:
<div class="code"> 
            virtual void show() = 0;<br>
            virtual void hide() = 0;<br>
</div>
Это и есть  чистые виртуальные функции. Класс, в  котором есть хотя бы
одна чистая виртуальная функция, непригоден напрямую для использования
- транслятор   просто   не  позволит   вам   создавать  объекты   типа
Figure.  Однако  он вполне  подходит  (как  и  задумано) для  базового
класса. Кроме  того, указатель (или ссылка) на  Figure может содержать
адрес  или ссылаться  на объект  любого производного  от  него класса.
Такие классы с чистыми виртуальными функциями называют абстрактными.
</p><p>
Теперь мы можем более логично построить нашу сеть наследования, сделав
класс Point наравне с другими производным от Figure:
<div class="code">
        class Point: public Figure {<br>
        public:<br>
        &nbsp;&nbsp;Point(int _x, int _y) : Figure(_x,_y) {};<br>
        &nbsp;&nbsp;void show() { /* show для точки */ };<br>
        &nbsp;&nbsp;void hide() { /* hide для точки */ };<br>
        };<br>
	<br>
        class Circle: public Figure {<br>
        protected:<br>
        &nbsp;&nbsp;int r;<br>
        public:<br>
        &nbsp;&nbsp;Circle(int _x, int _y, int _r)<br>
	&nbsp;&nbsp;&nbsp;&nbsp;: Figure(_x,_y), r(_r)<br>
	&nbsp;&nbsp;{};<br>
        &nbsp;&nbsp;void show() { /* show для окружности */ };<br>
        &nbsp;&nbsp;void hide() { /* hide для окружности */ };<br>
        };<br>
	<br>
        class Section: public Figure {<br>
        protected:<br>
        &nbsp;&nbsp;int len;<br>
        public:<br>
        &nbsp;&nbsp;Section(int _x, int _y, int _len) <br>
        &nbsp;&nbsp;&nbsp;&nbsp;: Figure(_x,_y), len(_len) <br>
	&nbsp;&nbsp;{};<br>
        &nbsp;&nbsp;void show() { /* show для отрезка */ };<br>
        &nbsp;&nbsp;void hide() { /* hide для отрезка */ };<br>
        };<br>
</div>
Соответственно, если нас  не интересуют специфические детали конкретных
объектов, мы можем работать с ними по интерфейсу Figure:
<div class="code">
       Figure *ptr[3];<br>
       <br>
       Point p(0,0);<br>
       Circle c(10,10, 20);<br>
       Section s(20,20,2);<br>
       <br>
       ptr[0] = &p;<br>
       ptr[1] = &c;<br>
       ptr[2] = &s;<br>
       <br>
       // Прячем все фигуры в массиве, <br>
       // независимо от типа<br>
       for (int i=0; i&lt;3; i++)<br>
       &nbsp;&nbsp;ptr[i]->hide();<br>
</div>
Обратите внимание на цикл в  последнем примере. Это снова иллюстрация 
<em>полиморфизма</em> - очень полезного свойства имеющих общую базу 
объектов. Все они могут работать
по  интерфейсу любого  своего базового  класса. Подобный  стиль работы
широко   применяется  в  объектно   ориентированном  программировании.
Например,  в  С++ стиле  ввода-вывода  вы  можете  считывать данные  с
терминала, из файла, даже из  массива - и будете при этом пользоваться
одними же и теми функциями.
</p>
    </td>
  </tr>
</table>


</div>
</body>
</html>
